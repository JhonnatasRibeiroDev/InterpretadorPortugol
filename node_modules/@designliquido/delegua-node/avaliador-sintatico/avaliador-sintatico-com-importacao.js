"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AvaliadorSintaticoComImportacao = void 0;
const delegua_1 = require("@designliquido/delegua");
const delegua_2 = __importDefault(require("@designliquido/delegua/tipos-de-simbolos/delegua"));
const delegua_3 = __importDefault(require("@designliquido/delegua/tipos-de-dados/delegua"));
const primitivas_dicionario_1 = __importDefault(require("@designliquido/delegua/bibliotecas/primitivas-dicionario"));
const primitivas_numero_1 = __importDefault(require("@designliquido/delegua/bibliotecas/primitivas-numero"));
const primitivas_texto_1 = __importDefault(require("@designliquido/delegua/bibliotecas/primitivas-texto"));
const primitivas_vetor_1 = __importDefault(require("@designliquido/delegua/bibliotecas/primitivas-vetor"));
const declaracoes_1 = require("../declaracoes");
const construtos_1 = require("../construtos");
class AvaliadorSintaticoComImportacao extends delegua_1.AvaliadorSintatico {
    constructor(importador) {
        super();
        this.arquivosImportados = [];
        this.importador = importador;
    }
    declaracaoImportar() {
        this.consumir(delegua_2.default.PARENTESE_ESQUERDO, "Esperado '(' após declaração.");
        const caminho = this.expressao();
        const simboloFechamento = this.consumir(delegua_2.default.PARENTESE_DIREITO, "Esperado ')' após declaração.");
        // Chegando aqui sem erros, a importação é sintaticamente válida.
        const literalCaminho = caminho;
        if (!literalCaminho.valor.endsWith('.delegua')) {
            return new construtos_1.ImportarBiblioteca(literalCaminho.hashArquivo, literalCaminho.linha, literalCaminho.valor);
        }
        const resultadoImportacao = this.importador.importar(literalCaminho.valor, false);
        // Havendo erros no lexador, levantamos um erro de avaliação sintática na
        // importação.
        if (resultadoImportacao.retornoLexador.erros.length > 0) {
            throw this.erro(simboloFechamento, `Erros encontrados ao importar o arquivo ${literalCaminho.valor}: ${resultadoImportacao.retornoLexador.erros.reduce((acumulado, proximo) => (acumulado += proximo.mensagem + "; "), "")}`);
        }
        const avaliadorSintaticoModulo = new AvaliadorSintaticoComImportacao(this.importador);
        const resultadoAvaliacaoSintaticaModulo = avaliadorSintaticoModulo.analisar(resultadoImportacao.retornoLexador, resultadoImportacao.hashArquivo, this.arquivosImportados);
        this.arquivosImportados.push(literalCaminho.valor);
        const definicoesClasse = resultadoAvaliacaoSintaticaModulo.declaracoes.filter((d) => d.constructor.name === "Classe");
        for (const definicaoClasse of definicoesClasse) {
            this.tiposDefinidosEmCodigo[definicaoClasse.simbolo.lexema] =
                definicaoClasse;
        }
        return new declaracoes_1.ModuloDeclaracoes(simboloFechamento.linha, simboloFechamento.hashArquivo, [], resultadoAvaliacaoSintaticaModulo.declaracoes);
    }
    // TODO: Remover ao implementar módulo no núcleo.
    resolverEntidadeChamadaAcessoMetodoOuPropriedade(entidadeChamadaResolvida) {
        const construtoTipado = entidadeChamadaResolvida;
        switch (entidadeChamadaResolvida.tipo) {
            case delegua_3.default.DICIONARIO:
            case delegua_3.default.DICIONÁRIO:
                if (!(construtoTipado.simbolo.lexema in primitivas_dicionario_1.default)) {
                    throw this.erro(construtoTipado.simbolo, `${construtoTipado.simbolo.lexema} não é uma primitiva de dicionário.`);
                }
                const primitivaDicionarioSelecionada = primitivas_dicionario_1.default[construtoTipado.simbolo.lexema];
                return new delegua_1.AcessoMetodo(construtoTipado.hashArquivo, construtoTipado.objeto, construtoTipado.simbolo.lexema, primitivaDicionarioSelecionada.tipoRetorno);
            case delegua_3.default.INTEIRO:
            case delegua_3.default.NUMERO:
            case delegua_3.default.NÚMERO:
                if (!(construtoTipado.simbolo.lexema in primitivas_numero_1.default)) {
                    throw this.erro(construtoTipado.simbolo, `${construtoTipado.simbolo.lexema} não é uma primitiva de número.`);
                }
                const primitivaNumeroSelecionada = primitivas_numero_1.default[construtoTipado.simbolo.lexema];
                return new delegua_1.AcessoMetodo(construtoTipado.hashArquivo, construtoTipado.objeto, construtoTipado.simbolo.lexema, primitivaNumeroSelecionada.tipoRetorno);
            case 'modulo':
            case 'módulo':
                if (construtoTipado.simbolo.lexema in this.tiposDefinidosEmCodigo) {
                    // Construtor de classe.
                    return new delegua_1.Variavel(construtoTipado.hashArquivo, construtoTipado.simbolo, construtoTipado.objeto.tipo);
                }
                return new delegua_1.AcessoMetodo(construtoTipado.hashArquivo, construtoTipado.objeto, construtoTipado.simbolo.lexema);
            case delegua_3.default.TEXTO:
                if (!(construtoTipado.simbolo.lexema in primitivas_texto_1.default)) {
                    throw this.erro(construtoTipado.simbolo, `${construtoTipado.simbolo.lexema} não é uma primitiva de texto.`);
                }
                const primitivaTextoSelecionada = primitivas_texto_1.default[construtoTipado.simbolo.lexema];
                return new delegua_1.AcessoMetodo(construtoTipado.hashArquivo, construtoTipado.objeto, construtoTipado.simbolo.lexema, primitivaTextoSelecionada.tipoRetorno);
            case delegua_3.default.VETOR:
            case delegua_3.default.VETOR_NUMERO:
            case delegua_3.default.VETOR_NÚMERO:
            case delegua_3.default.VETOR_TEXTO:
                if (!(construtoTipado.simbolo.lexema in primitivas_vetor_1.default)) {
                    throw this.erro(construtoTipado.simbolo, `${construtoTipado.simbolo.lexema} não é uma primitiva de vetor.`);
                }
                const primitivaVetorSelecionada = primitivas_vetor_1.default[construtoTipado.simbolo.lexema];
                return new delegua_1.AcessoMetodo(construtoTipado.hashArquivo, construtoTipado.objeto, construtoTipado.simbolo.lexema, primitivaVetorSelecionada.tipoRetorno);
        }
        return entidadeChamadaResolvida;
    }
    logicaComumInferenciaTiposVariaveisEConstantes(inicializador, tipo) {
        switch (inicializador.constructor.name) {
            case "ImportarBiblioteca":
            case "ModuloDeclaracoes":
                return "módulo";
        }
        return super.logicaComumInferenciaTiposVariaveisEConstantes(inicializador, tipo);
    }
    /**
     * No modo LAIR, a pilha de escopos não deve ser reinicializada a cada execução.
     * @returns Nada.
     */
    inicializarPilhaEscopos() {
        if (this.modoLair && !this.pilhaEscopos.eVazio()) {
            return;
        }
        super.inicializarPilhaEscopos();
    }
    analisar(retornoLexador, hashArquivo, arquivosImportados) {
        this.arquivosImportados = arquivosImportados || [];
        return super.analisar(retornoLexador, hashArquivo);
    }
}
exports.AvaliadorSintaticoComImportacao = AvaliadorSintaticoComImportacao;
//# sourceMappingURL=avaliador-sintatico-com-importacao.js.map