"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NucleoExecucao = void 0;
const caminho = __importStar(require("path"));
const readline = __importStar(require("readline"));
const chalk_1 = __importDefault(require("chalk"));
const json_colorizer_1 = require("json-colorizer");
const dialetos_1 = require("@designliquido/delegua/avaliador-sintatico/dialetos");
const dialetos_2 = require("@designliquido/delegua/interpretador/dialetos");
const lexador_1 = require("@designliquido/delegua/lexador");
const dialetos_3 = require("@designliquido/delegua/lexador/dialetos");
const lexador_2 = require("@designliquido/birl/lexador");
const avaliador_sintatico_1 = require("@designliquido/birl/avaliador-sintatico");
const interpretador_1 = require("@designliquido/birl/interpretador");
// Aparentemente o Jest não trabalha bem com barreling de pacotes externos,
// então cada importação precisa ser feita separadamente.
const lexador_3 = require("@designliquido/mapler/lexador");
const avaliador_sintatico_2 = require("@designliquido/mapler/avaliador-sintatico");
const resolvedor_1 = require("@designliquido/mapler/resolvedor");
const interpretador_2 = require("@designliquido/mapler/interpretador");
const lexador_4 = require("@designliquido/portugol-studio/lexador");
const avaliador_sintatico_3 = require("@designliquido/portugol-studio/avaliador-sintatico");
const interpretador_3 = require("@designliquido/portugol-studio/interpretador");
const avaliador_sintatico_4 = require("@designliquido/potigol/avaliador-sintatico");
const interpretador_4 = require("@designliquido/potigol/interpretador");
const lexador_5 = require("@designliquido/potigol/lexador");
const lexador_6 = require("@designliquido/visualg/lexador");
const avaliador_sintatico_5 = require("@designliquido/visualg/avaliador-sintatico");
const interpretador_5 = require("@designliquido/visualg/interpretador");
const importador_1 = require("./importador");
const depuracao_1 = require("./depuracao");
const formatadores_1 = require("./formatadores");
const lexador_json_1 = require("./lexador/lexador-json");
const interpretador_6 = require("./interpretador");
const interpretador_com_depuracao_importacao_1 = require("./interpretador/interpretador-com-depuracao-importacao");
const nucleo_comum_1 = require("./nucleo-comum");
const avaliador_sintatico_com_importacao_1 = require("./avaliador-sintatico/avaliador-sintatico-com-importacao");
class NucleoExecucao extends nucleo_comum_1.NucleoComum {
    constructor(versao, funcaoDeRetorno = null, funcaoDeRetornoMesmaLinha = null, funcaoLimpaTela = null) {
        super();
        this.dialetos = {
            birl: "BIRL",
            delegua: "padrão",
            delégua: "padrão",
            egua: "Égua",
            égua: "Égua",
            mapler: "Mapler",
            pitugues: "Pituguês",
            pituguês: "Pituguês",
            potigol: "Potigol",
            "portugol-studio": "Portugol Studio",
            visualg: "VisuAlg",
        };
        this.versao = versao;
        this.arquivosAbertos = {};
        this.conteudoArquivosAbertos = {};
        this.funcaoDeRetorno = funcaoDeRetorno || console.log;
        // `process.stdout.write.bind(process.stdout)` é necessário por causa de
        // https://stackoverflow.com/questions/28874665/node-js-cannot-read-property-defaultencoding-of-undefined
        this.funcaoDeRetornoMesmaLinha =
            funcaoDeRetornoMesmaLinha ||
                process.stdout.write.bind(process.stdout);
        this.funcaoLimpaTela = funcaoLimpaTela || this.funcaoLimpaTelaPadrao;
    }
    funcaoLimpaTelaPadrao() {
        process.stdout.write("\x1Bc");
    }
    configurarDialeto(dialeto = "delegua", performance = false, depurador = false) {
        this.dialeto = dialeto;
        this.modoDepuracao = depurador;
        switch (dialeto) {
            case "birl":
                this.lexador = new lexador_2.LexadorBirl();
                this.avaliadorSintatico = new avaliador_sintatico_1.AvaliadorSintaticoBirl();
                this.importador = new importador_1.Importador(this.lexador, this.arquivosAbertos, this.conteudoArquivosAbertos, depurador);
                this.interpretador = new interpretador_1.InterpretadorBirl(process.cwd(), this.funcaoDeRetorno, this.funcaoDeRetornoMesmaLinha);
                break;
            case "egua":
                if (depurador) {
                    throw new Error("Dialeto " + dialeto + " não suporta depuração.");
                }
                this.lexador = new dialetos_3.LexadorEguaClassico();
                this.avaliadorSintatico = new dialetos_1.AvaliadorSintaticoEguaClassico();
                this.importador = new importador_1.Importador(this.lexador, this.arquivosAbertos, this.conteudoArquivosAbertos, depurador);
                this.interpretador = new dialetos_2.InterpretadorEguaClassico(process.cwd());
                break;
            case "mapler":
                this.lexador = new lexador_3.LexadorMapler();
                this.avaliadorSintatico = new avaliador_sintatico_2.AvaliadorSintaticoMapler();
                this.resolvedor = new resolvedor_1.ResolvedorMapler();
                this.importador = new importador_1.Importador(this.lexador, this.arquivosAbertos, this.conteudoArquivosAbertos, depurador);
                this.interpretador = depurador
                    ? new interpretador_2.InterpretadorMaplerComDepuracao(process.cwd(), this.funcaoDeRetorno)
                    : new interpretador_2.InterpretadorMapler(process.cwd(), false, this.funcaoDeRetorno, this.funcaoDeRetornoMesmaLinha);
                break;
            case "pitugues":
            case "pituguês":
                this.lexador = new dialetos_3.LexadorPitugues();
                this.avaliadorSintatico = new dialetos_1.AvaliadorSintaticoPitugues();
                this.importador = new importador_1.Importador(this.lexador, this.arquivosAbertos, this.conteudoArquivosAbertos, depurador);
                this.interpretador = depurador
                    ? new interpretador_com_depuracao_importacao_1.InterpretadorComDepuracaoImportacao(this.importador, process.cwd(), this.funcaoDeRetorno, this.funcaoDeRetornoMesmaLinha)
                    : new interpretador_6.InterpretadorComImportacao(this.importador, process.cwd(), performance, this.funcaoDeRetorno, this.funcaoDeRetornoMesmaLinha);
                break;
            case "portugol-ipt":
                this.lexador = new dialetos_3.LexadorPortugolIpt();
                this.avaliadorSintatico = new dialetos_1.AvaliadorSintaticoPortugolIpt();
                this.importador = new importador_1.Importador(this.lexador, this.arquivosAbertos, this.conteudoArquivosAbertos, depurador);
                this.interpretador = depurador
                    ? new dialetos_2.InterpretadorPortugolIpt(process.cwd(), this.funcaoDeRetornoMesmaLinha, this.funcaoDeRetornoMesmaLinha)
                    : new dialetos_2.InterpretadorPortugolIpt(process.cwd(), this.funcaoDeRetornoMesmaLinha, this.funcaoDeRetornoMesmaLinha);
                break;
            case "portugol-studio":
                this.lexador = new lexador_4.LexadorPortugolStudio();
                this.avaliadorSintatico =
                    new avaliador_sintatico_3.AvaliadorSintaticoPortugolStudio();
                this.importador = new importador_1.Importador(this.lexador, this.arquivosAbertos, this.conteudoArquivosAbertos, depurador);
                this.interpretador = depurador
                    ? new interpretador_3.InterpretadorPortugolStudioComDepuracao(process.cwd(), this.funcaoDeRetorno, this.funcaoDeRetornoMesmaLinha, this.funcaoLimpaTela)
                    : new interpretador_3.InterpretadorPortugolStudio(process.cwd(), performance, this.funcaoDeRetorno, this.funcaoLimpaTela);
                break;
            case "potigol":
                this.lexador = new lexador_5.LexadorPotigol();
                this.avaliadorSintatico = new avaliador_sintatico_4.AvaliadorSintaticoPotigol();
                this.importador = new importador_1.Importador(this.lexador, this.arquivosAbertos, this.conteudoArquivosAbertos, depurador);
                this.interpretador = depurador
                    ? new interpretador_4.InterpretadorPotigolComDepuracao(process.cwd(), this.funcaoDeRetorno, this.funcaoDeRetorno)
                    : new interpretador_4.InterpretadorPotigol(process.cwd(), performance, this.funcaoDeRetorno);
                break;
            case "visualg":
                this.lexador = new lexador_6.LexadorVisuAlg();
                this.avaliadorSintatico = new avaliador_sintatico_5.AvaliadorSintaticoVisuAlg();
                this.importador = new importador_1.Importador(this.lexador, this.arquivosAbertos, this.conteudoArquivosAbertos, depurador);
                this.interpretador = depurador
                    ? new interpretador_5.InterpretadorVisuAlgComDepuracao(process.cwd(), this.funcaoDeRetorno, this.funcaoDeRetornoMesmaLinha, this.funcaoLimpaTela)
                    : new interpretador_5.InterpretadorVisuAlg(process.cwd(), false, this.funcaoDeRetorno, this.funcaoDeRetornoMesmaLinha, this.funcaoLimpaTela);
                this.interpretador.deveEscreverPrompt = true;
                break;
            default:
                this.lexador = new lexador_1.Lexador(performance);
                this.importador = new importador_1.Importador(this.lexador, this.arquivosAbertos, this.conteudoArquivosAbertos, depurador);
                this.avaliadorSintatico = new avaliador_sintatico_com_importacao_1.AvaliadorSintaticoComImportacao(this.importador);
                this.interpretador = depurador
                    ? new interpretador_com_depuracao_importacao_1.InterpretadorComDepuracaoImportacao(this.importador, process.cwd(), this.funcaoDeRetorno, this.funcaoDeRetornoMesmaLinha)
                    : new interpretador_6.InterpretadorComImportacao(this.importador, process.cwd(), performance, this.funcaoDeRetorno, this.funcaoDeRetornoMesmaLinha);
                break;
        }
        if (depurador) {
            this.iniciarDepuracao();
        }
    }
    async executarCodigoComoArgumento(codigo) {
        const retornoLexador = this.lexador.mapear([codigo], -1);
        const retornoAvaliadorSintatico = this.avaliadorSintatico.analisar(retornoLexador, -1);
        const { erros } = await this.executar(retornoAvaliadorSintatico.declaracoes);
        if (erros.length > 0)
            process.exit(70); // Código com exceções não tratadas
    }
    /**
     * Execução por arquivo.
     * @param caminhoRelativoArquivo O caminho no sistema operacional do arquivo a ser aberto.
     */
    async carregarEExecutarArquivo(caminhoRelativoArquivo) {
        const caminhoAbsolutoPrimeiroArquivo = caminho.resolve(caminhoRelativoArquivo);
        const novoDiretorioBase = caminho.dirname(caminhoAbsolutoPrimeiroArquivo);
        this.importador.diretorioBase = novoDiretorioBase;
        this.interpretador.diretorioBase = novoDiretorioBase;
        const retornoImportador = this.importador.importar(caminhoRelativoArquivo, true);
        if (this.afericaoErrosLexador(retornoImportador.retornoLexador)) {
            process.exit(65); // Código para erro de avaliação antes da execução
        }
        const retornoAvaliadorSintatico = this.avaliadorSintatico.analisar(retornoImportador.retornoLexador, retornoImportador.hashArquivo);
        if (this.afericaoErrosAvaliadorSintatico(retornoAvaliadorSintatico)) {
            process.exit(65); // Código para erro de avaliação antes da execução
        }
        let errosExecucao = {
            lexador: [],
            avaliadorSintatico: [],
            interpretador: [],
        };
        // Se a interface de entrada e saída ainda não está definida, definimos agora.
        // A interface pode ser definida por um teste unitário antes da execução
        // aqui, por exemplo.
        let interfaceLeitura;
        if (!this.interpretador.interfaceEntradaSaida) {
            interfaceLeitura = readline.createInterface({
                input: process.stdin,
                output: process.stdout,
                prompt: "\n> ",
            });
            this.interpretador.interfaceEntradaSaida = interfaceLeitura;
        }
        if (this.modoDepuracao) {
            let declaracoes = retornoAvaliadorSintatico.declaracoes;
            if (this.resolvedor) {
                declaracoes = await this.resolvedor.resolver(declaracoes);
            }
            try {
                this.interpretador.prepararParaDepuracao(declaracoes);
            }
            catch (erro) {
                console.error(chalk_1.default.red(`[Erro de execução]`) +
                    ` Dialeto ${this.dialeto} não suporta depuração.`);
            }
        }
        else {
            const { erros } = await this.executar(retornoAvaliadorSintatico.declaracoes);
            errosExecucao = erros;
        }
        if (interfaceLeitura &&
            (interfaceLeitura instanceof readline.Interface ||
                interfaceLeitura.hasOwnProperty("close"))) {
            interfaceLeitura.close();
        }
        if (errosExecucao.length > 0)
            process.exitCode = 70; // Código com exceções não tratadas
        return;
    }
    /**
     * LAIR (Leia-Avalie-Imprima-Repita) é o modo em que Delégua executa em modo console,
     * ou seja, esperando como entrada linhas de código fornecidas pelo usuário.
     */
    async iniciarLairDelegua() {
        const lexadorJson = new lexador_json_1.LexadorJson();
        const formatadorJson = new formatadores_1.FormatadorJson();
        // No modo LAIR, o avaliador sintático precisa manter as referências
        // de tipos declaradas anteriormente.
        this.avaliadorSintatico.modoLair = true;
        this.funcaoDeRetorno(`Usando dialeto: ${this.dialetos[this.dialeto]}`);
        this.funcaoDeRetorno(`Console da Linguagem Delégua v${this.versao}`);
        this.funcaoDeRetorno("Pressione Ctrl + C para sair");
        const interfaceLeitura = readline.createInterface({
            input: process.stdin,
            output: process.stdout,
            prompt: "\ndelegua> ",
        });
        const isto = this;
        this.interpretador.interfaceEntradaSaida = interfaceLeitura;
        interfaceLeitura.prompt();
        interfaceLeitura.on("line", async (linha) => {
            const { resultado } = await isto.executarUmaLinha(linha);
            if (resultado && resultado.length) {
                const resultadoLexacao = lexadorJson.getTokens(resultado[0]);
                const resultadoFormatacao = formatadorJson.formatar(resultadoLexacao);
                isto.funcaoDeRetorno((0, json_colorizer_1.colorize)(resultadoFormatacao));
            }
            interfaceLeitura.prompt();
        });
    }
    /**
     * A execução do código de fato.
     * @param retornoImportador Dados retornados do Importador, como o retorno do Lexador, do Avaliador
     *                          Sintático e respectivos erros.
     * @param manterAmbiente Indicação se ambiente deve ser mantido ou não. Normalmente verdadeiro
     *                       para LAIR, falso para execução por arquivo.
     * @returns Um objeto com o resultado da execução.
     */
    async executar(declaracoes, manterAmbiente = false) {
        var _a, _b;
        if (this.resolvedor) {
            declaracoes = await this.resolvedor.resolver(declaracoes);
        }
        const retornoInterpretador = await this.interpretador.interpretar(declaracoes, manterAmbiente);
        if (retornoInterpretador.erros.length > 0) {
            for (const erroInterpretador of retornoInterpretador.erros) {
                if (erroInterpretador.hasOwnProperty("simbolo")) {
                    this.erroEmTempoDeExecucao(erroInterpretador);
                }
                else {
                    if (erroInterpretador.hasOwnProperty("erroInterno")) {
                        const erroEmJavaScript = erroInterpretador;
                        console.error(chalk_1.default.red(`[Linha: ${erroEmJavaScript.linha}] Erro em JavaScript: `) + `${(_a = erroEmJavaScript.erroInterno) === null || _a === void 0 ? void 0 : _a.message}`);
                        console.error(chalk_1.default.red(`Pilha de execução: `) +
                            `${(_b = erroEmJavaScript.erroInterno) === null || _b === void 0 ? void 0 : _b.stack}`);
                    }
                    else {
                        console.error(chalk_1.default.red(`Erro em JavaScript: `) +
                            JSON.stringify(erroInterpretador));
                    }
                }
            }
        }
        return {
            erros: retornoInterpretador.erros,
            resultado: retornoInterpretador.resultado,
        };
    }
    /**
     * Executa uma linha. Usado pelo modo LAIR e pelo servidor de depuração, quando recebe um comando 'avaliar'.
     * @param linha A linha a ser avaliada.
     * @returns O resultado da execução, com os retornos e respectivos erros, se houverem.
     */
    async executarUmaLinha(linha) {
        const retornoLexador = this.lexador.mapear([linha], -1);
        const retornoAvaliadorSintatico = this.avaliadorSintatico.analisar(retornoLexador, -1);
        if (this.afericaoErrosLexador(retornoLexador) || this.afericaoErrosAvaliadorSintatico(retornoAvaliadorSintatico)) {
            return { resultado: [] };
        }
        return await this.executar(retornoAvaliadorSintatico.declaracoes, true);
    }
    /**
     * Instancia um servidor de depuração, normalmente recebendo requisições na porta 7777.
     */
    iniciarDepuracao() {
        this.servidorDepuracao = new depuracao_1.ServidorDepuracao(this);
        this.servidorDepuracao.iniciarServidorDepuracao();
        this.interpretador.finalizacaoDaExecucao =
            this.finalizarDepuracao.bind(this);
    }
    /**
     * Pede ao servidor de depuração que finalize a execução.
     * Se não for feito, o servidor de depuração mantém um _stream_ aberto e nunca finaliza.
     * Mais informações: https://stackoverflow.com/a/47456805/1314276
     */
    finalizarDepuracao() {
        if (this.servidorDepuracao) {
            this.servidorDepuracao.finalizarServidorDepuracao();
        }
    }
    erroEmTempoDeExecucao(erro) {
        var _a;
        const linha = ((_a = erro === null || erro === void 0 ? void 0 : erro.simbolo) === null || _a === void 0 ? void 0 : _a.linha) || (erro === null || erro === void 0 ? void 0 : erro.linha);
        const mensagem = (erro === null || erro === void 0 ? void 0 : erro.mensagem) || (erro === null || erro === void 0 ? void 0 : erro.message);
        console.error(chalk_1.default.red(`Erro: [Linha: ${linha}]`) + ` ${mensagem}`);
    }
}
exports.NucleoExecucao = NucleoExecucao;
//# sourceMappingURL=nucleo-execucao.js.map