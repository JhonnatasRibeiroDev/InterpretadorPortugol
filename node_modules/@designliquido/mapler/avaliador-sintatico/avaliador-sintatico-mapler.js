"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AvaliadorSintaticoMapler = void 0;
const avaliador_sintatico_base_1 = require("@designliquido/delegua/avaliador-sintatico/avaliador-sintatico-base");
const declaracoes_1 = require("@designliquido/delegua/declaracoes");
const construtos_1 = require("@designliquido/delegua/construtos");
const declaracao_futura_1 = require("../declaracoes/declaracao-futura");
const lexico_regular_1 = __importDefault(require("../tipos-de-simbolos/lexico-regular"));
const delegua_1 = require("@designliquido/delegua");
class AvaliadorSintaticoMapler extends avaliador_sintatico_base_1.AvaliadorSintaticoBase {
    constructor() {
        super();
        this.lendoModulos = false;
        this.modulos = [];
    }
    criarVetorNDimensional(dimensoes) {
        if (dimensoes.length > 0) {
            const dimensao = dimensoes[0] + 1;
            const resto = dimensoes.slice(1);
            const novoArray = Array(dimensao);
            for (let i = 0; i <= dimensao; i++) {
                novoArray[i] = this.criarVetorNDimensional(resto);
            }
            return novoArray;
        }
        else {
            return undefined;
        }
    }
    validarDimensoesVetor() {
        let dimensoes = [];
        do {
            const numeroInicial = this.consumir(lexico_regular_1.default.NUMERO, 'Esperado índice inicial para inicialização de dimensão de vetor.');
            this.consumir(lexico_regular_1.default.PONTO, 'Esperado primeiro ponto após índice inicial para inicialização de dimensão de vetor.');
            this.consumir(lexico_regular_1.default.PONTO, 'Esperado segundo ponto após índice inicial para inicialização de dimensão de vetor.');
            const numeroFinal = this.consumir(lexico_regular_1.default.NUMERO, 'Esperado índice final para inicialização de dimensão de vetor.');
            dimensoes.push(Number(numeroFinal.literal) - Number(numeroInicial.literal));
        } while (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.VIRGULA));
        return dimensoes;
    }
    logicaComumParametroMapler() {
        const identificadores = [];
        do {
            identificadores.push(this.consumir(lexico_regular_1.default.IDENTIFICADOR, 'Esperado nome de variável.'));
        } while (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.VIRGULA));
        this.consumir(lexico_regular_1.default.DOIS_PONTOS, 'Esperado dois-pontos após nome de variável.');
        if (!this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.CADEIA, lexico_regular_1.default.CARACTERE, lexico_regular_1.default.INTEIRO, lexico_regular_1.default.LOGICO, lexico_regular_1.default.MODULO, lexico_regular_1.default.REAL, lexico_regular_1.default.VETOR)) {
            throw this.erro(this.simbolos[this.atual], 'Tipo de variável não conhecido.');
        }
        const simboloAnterior = this.simbolos[this.atual - 1];
        const tipoVariavel = simboloAnterior.tipo;
        return {
            identificadores,
            tipo: tipoVariavel,
            simbolo: simboloAnterior,
        };
    }
    /**
     * Validação do segmento de declaração de variáveis (opcional).
     * @returns Vetor de Construtos para inicialização de variáveis.
     */
    validarSegmentoVariaveis() {
        const inicializacoes = [];
        while (!this.verificarTipoSimboloAtual(lexico_regular_1.default.INICIO)) {
            if (this.simbolos[this.atual].tipo === lexico_regular_1.default.COMENTARIO) {
                inicializacoes.push(this.declaracaoComentario());
                continue;
            }
            const dadosVariaveis = this.logicaComumParametroMapler();
            // Se chegou até aqui, variáveis são válidas.
            // Devem ser declaradas com um valor inicial padrão.
            for (let identificador of dadosVariaveis.identificadores) {
                switch (dadosVariaveis.tipo) {
                    case lexico_regular_1.default.CADEIA:
                    case lexico_regular_1.default.CARACTERE:
                        inicializacoes.push(new declaracoes_1.Var(identificador, new construtos_1.Literal(this.hashArquivo, Number(dadosVariaveis.simbolo.linha), ''), 'texto'));
                        break;
                    case lexico_regular_1.default.INTEIRO:
                        inicializacoes.push(new declaracoes_1.Var(identificador, new construtos_1.Literal(this.hashArquivo, Number(dadosVariaveis.simbolo.linha), 0), 'inteiro'));
                        break;
                    case lexico_regular_1.default.REAL:
                        inicializacoes.push(new declaracoes_1.Var(identificador, new construtos_1.Literal(this.hashArquivo, Number(dadosVariaveis.simbolo.linha), 0), 'real'));
                        break;
                    case lexico_regular_1.default.LOGICO:
                        inicializacoes.push(new declaracoes_1.Var(identificador, new construtos_1.Literal(this.hashArquivo, Number(dadosVariaveis.simbolo.linha), false), 'lógico'));
                        break;
                    case lexico_regular_1.default.MODULO:
                        // Para efeitos práticos, declarar um módulo (função) como uma
                        // variável apenas serve para dizer ao interpretador que as
                        // declarações das funções propriamente ditas irão ao
                        // final do código.
                        this.modulos.push(identificador.lexema);
                        break;
                    case lexico_regular_1.default.VETOR:
                        // TODO: Validar vetor
                        this.consumir(lexico_regular_1.default.COLCHETE_ESQUERDO, 'Esperado colchete esquerdo após palavra reservada "vetor".');
                        const dimensoes = this.validarDimensoesVetor();
                        this.consumir(lexico_regular_1.default.COLCHETE_DIREITO, 'Esperado colchete direito após declaração de dimensões de vetor.');
                        this.consumir(lexico_regular_1.default.DE, 'Esperado palavra reservada "de" após declaração de dimensões de vetor.');
                        if (!this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.CARACTERE, lexico_regular_1.default.INTEIRO, lexico_regular_1.default.LOGICO, lexico_regular_1.default.REAL, lexico_regular_1.default.VETOR)) {
                            throw this.erro(this.simbolos[this.atual], 'Tipo de variável não conhecido para inicialização de vetor.');
                        }
                        inicializacoes.push(new declaracoes_1.Var(identificador, new construtos_1.Literal(this.hashArquivo, Number(dadosVariaveis.simbolo.linha), this.criarVetorNDimensional(dimensoes)), 'vetor'));
                        break;
                }
            }
            this.consumir(lexico_regular_1.default.PONTO_VIRGULA, "Esperado ';' após declaração de variável.");
        }
        return inicializacoes;
    }
    estaNoFinal() {
        return this.atual === this.simbolos.length;
    }
    primario() {
        const simboloAtual = this.simbolos[this.atual];
        if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.FALSO))
            return new construtos_1.Literal(this.hashArquivo, Number(simboloAtual.linha), false);
        if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.VERDADEIRO))
            return new construtos_1.Literal(this.hashArquivo, Number(simboloAtual.linha), true);
        if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.IDENTIFICADOR)) {
            const simboloIdentificador = this.simbolos[this.atual - 1];
            if (this.modulos.includes(simboloIdentificador.lexema)) {
                // TODO: Chamar função
                return new declaracao_futura_1.DeclaracaoFutura(simboloIdentificador);
                // return new Expressao(new Chamada(simboloAtual.hashArquivo, funcaoDeclaracao.funcao, null, []))
            }
            return new construtos_1.Variavel(this.hashArquivo, simboloIdentificador);
        }
        if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.NUMERO, lexico_regular_1.default.CADEIA, lexico_regular_1.default.CARACTERE)) {
            const simboloAnterior = this.simbolos[this.atual - 1];
            return new construtos_1.Literal(this.hashArquivo, Number(simboloAnterior.linha), simboloAnterior.literal);
        }
        if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.PARENTESE_ESQUERDO)) {
            const expressao = this.expressao();
            this.consumir(lexico_regular_1.default.PARENTESE_DIREITO, "Esperado ')' após a expressão.");
            return new construtos_1.Agrupamento(this.hashArquivo, Number(simboloAtual.linha), expressao);
        }
        if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.PONTO_VIRGULA)) {
            return null;
        }
        throw this.erro(this.simbolos[this.atual], 'Esperado expressão.');
    }
    comparacaoIgualdade() {
        let expressao = this.comparar();
        while (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.DIFERENTE, lexico_regular_1.default.IGUAL)) {
            const simboloAnterior = this.simbolos[this.atual - 1];
            const direito = this.comparar();
            expressao = new construtos_1.Binario(this.hashArquivo, expressao, simboloAnterior, direito);
        }
        return expressao;
    }
    ou() {
        let expressao = this.e();
        while (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.OU)) {
            const operador = this.simbolos[this.atual - 1];
            const direito = this.e();
            expressao = new construtos_1.Logico(this.hashArquivo, expressao, operador, direito);
        }
        return expressao;
    }
    /**
     * Método que resolve atribuições.
     * @returns Um construto do tipo `Atribuir`, `Conjunto` ou `AtribuicaoPorIndice`.
     */
    atribuir() {
        const expressao = this.ou();
        if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.SETA_ATRIBUICAO)) {
            const setaAtribuicao = this.simbolos[this.atual - 1];
            const valor = this.atribuir();
            if (expressao instanceof construtos_1.Variavel) {
                return new construtos_1.Atribuir(this.hashArquivo, expressao, valor);
            }
            if (expressao instanceof construtos_1.AcessoIndiceVariavel) {
                return new construtos_1.AtribuicaoPorIndice(this.hashArquivo, expressao.linha, expressao.entidadeChamada, expressao.indice, valor);
            }
            this.erro(setaAtribuicao, 'Tarefa de atribuição inválida');
        }
        return expressao;
    }
    expressao() {
        if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.LER))
            return this.declaracaoLeia();
        return this.atribuir();
    }
    blocoEscopo() {
        const declaracoes = [];
        while (this.simbolos[this.atual].tipo !== lexico_regular_1.default.FIM) {
            declaracoes.push(this.resolverDeclaracaoForaDeBloco());
        }
        return declaracoes.filter((d) => d);
    }
    chamar() {
        let expressao = this.primario();
        while (true) {
            if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.PARENTESE_ESQUERDO)) {
                expressao = this.finalizarChamada(expressao);
            }
            else if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.COLCHETE_ESQUERDO)) {
                const indices = [];
                do {
                    indices.push(this.expressao());
                } while (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.VIRGULA));
                const indice = indices[0];
                const simboloFechamento = this.consumir(lexico_regular_1.default.COLCHETE_DIREITO, "Esperado ']' após escrita do indice.");
                expressao = new construtos_1.AcessoIndiceVariavel(this.hashArquivo, expressao, indice, simboloFechamento);
            }
            else {
                break;
            }
        }
        return expressao;
    }
    corpoDaFuncao(tipo) {
        const simboloAnterior = this.simbolos[this.atual - 1];
        // TODO: Verificar como Mapler lida com varíaveis em módulos.
        // this.validarSegmentoVariaveis();
        const corpo = this.blocoEscopo();
        this.consumir(lexico_regular_1.default.FIM, `Isso nunca dá erro.`);
        this.consumir(tipo, `Esperado palavra reservada "${tipo.toLowerCase()}" após palavra reservada "fim" para finalização da declaração.`);
        this.consumir(lexico_regular_1.default.PONTO_VIRGULA, `Esperado ponto-e-vírgula após palavras reservadas "fim ${tipo.toLowerCase()}."`);
        return new construtos_1.FuncaoConstruto(this.hashArquivo, Number(simboloAnterior.linha), [], corpo);
    }
    declaracaoComentario() {
        const simboloComentario = this.avancarEDevolverAnterior();
        return new construtos_1.Comentario(simboloComentario.hashArquivo, simboloComentario.linha, simboloComentario.literal, false);
    }
    declaracaoEnquanto() {
        const simboloAtual = this.avancarEDevolverAnterior();
        const condicao = this.expressao();
        this.consumir(lexico_regular_1.default.FACA, "Esperado paravra reservada 'faca' após condição de continuidade em declaracão 'enquanto'.");
        const declaracoes = [];
        do {
            declaracoes.push(this.resolverDeclaracaoForaDeBloco());
        } while (![lexico_regular_1.default.FIM].includes(this.simbolos[this.atual].tipo) &&
            ![lexico_regular_1.default.ENQUANTO].includes(this.simbolos[this.atual + 1].tipo));
        this.consumir(lexico_regular_1.default.FIM, "Esperado palavra-chave 'fim' para iniciar o fechamento de declaração 'enquanto'.");
        this.consumir(lexico_regular_1.default.ENQUANTO, "Esperado palavra-chave 'enquanto' para o fechamento de declaração 'enquanto'.");
        this.consumir(lexico_regular_1.default.PONTO_VIRGULA, "Esperado palavra-chave ';' para o fechamento de declaração 'enquanto'.");
        return new declaracoes_1.Enquanto(condicao, new declaracoes_1.Bloco(simboloAtual.hashArquivo, Number(simboloAtual.linha), declaracoes.filter((d) => d)));
    }
    declaracaoEscolha() {
        throw new Error('Método não implementado.');
    }
    logicaComumEscreva() {
        const simboloAtual = this.simbolos[this.atual];
        const argumentos = [];
        do {
            const valor = this.resolverDeclaracaoForaDeBloco();
            argumentos.push(new construtos_1.FormatacaoEscrita(this.hashArquivo, Number(simboloAtual.linha), valor));
        } while (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.VIRGULA));
        this.consumir(lexico_regular_1.default.PONTO_VIRGULA, "Esperado quebra de linha após fechamento de parênteses pós instrução 'escreva'.");
        return argumentos;
    }
    declaracaoEscreva() {
        const simboloAtual = this.avancarEDevolverAnterior();
        const argumentos = this.logicaComumEscreva();
        return new declaracoes_1.Escreva(Number(simboloAtual.linha), this.hashArquivo, argumentos);
    }
    declaracaoEscrevaMesmaLinha() {
        const simboloAtual = this.avancarEDevolverAnterior();
        const argumentos = this.logicaComumEscreva();
        return new declaracoes_1.EscrevaMesmaLinha(Number(simboloAtual.linha), this.hashArquivo, argumentos);
    }
    /**
     * Criação de declaração "repita".
     * @returns Um construto do tipo Fazer
     */
    declaracaoFazer() {
        const simboloAtual = this.avancarEDevolverAnterior();
        const declaracoes = [];
        do {
            declaracoes.push(this.resolverDeclaracaoForaDeBloco());
        } while (![lexico_regular_1.default.ATE].includes(this.simbolos[this.atual].tipo));
        this.consumir(lexico_regular_1.default.ATE, "Esperado palavra-chave 'ate' após declaração de bloco em instrução 'repita'.");
        const condicao = this.expressao();
        // this.consumir(
        //     tiposDeSimbolos.QUEBRA_LINHA,
        //     "Esperado quebra de linha após condição de continuidade em instrução 'repita'."
        // );
        return new declaracoes_1.Fazer(this.hashArquivo, Number(simboloAtual.linha), new declaracoes_1.Bloco(this.hashArquivo, Number(simboloAtual.linha), declaracoes.filter((d) => d)), condicao);
    }
    /**
     * Criação de declaração "interrompa".
     * Em Mapler, "sustar" é chamada de "interrompa".
     * @returns Uma declaração do tipo Sustar.
     */
    declaracaoInterrompa() {
        const simboloAtual = this.avancarEDevolverAnterior();
        // TODO: Contar blocos para colocar esta condição de erro.
        /* if (this.blocos < 1) {
            this.erro(this.simbolos[this.atual - 1], "'interrompa' deve estar dentro de um laço de repetição.");
        } */
        return new declaracoes_1.Sustar(simboloAtual);
    }
    /**
     * Análise de uma declaração `leia()`. No Mapler, `leia()` aceita 1..N argumentos.
     * @returns Uma declaração `Leia`.
     */
    declaracaoLeia() {
        const simboloAtual = this.avancarEDevolverAnterior();
        const argumentos = [];
        do {
            argumentos.push(this.resolverDeclaracaoForaDeBloco());
        } while (!this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.PONTO_VIRGULA));
        return new declaracoes_1.Leia(simboloAtual, argumentos);
    }
    /**
     * Um módulo em Mapler nada mais é do que uma função.
     * Um módulo aparentemente não especifica tipo de retorno.
     * @returns Uma declaração de função.
     */
    declaracaoModulo() {
        const simboloModulo = this.avancarEDevolverAnterior();
        const simboloNomeModulo = this.consumir(lexico_regular_1.default.IDENTIFICADOR, `Esperado nome do módulo após palavra reservada "modulo".`);
        return new declaracoes_1.FuncaoDeclaracao(simboloNomeModulo, this.corpoDaFuncao(simboloModulo.tipo), null, []);
    }
    declaracaoPara() {
        const simboloPara = this.avancarEDevolverAnterior();
        const simboloVariavelIteracao = this.consumir(lexico_regular_1.default.IDENTIFICADOR, `Esperado identificador após palavra reservada "para".`);
        this.consumir(lexico_regular_1.default.DE, `Esperado paravra reservada "de" após identificador em declaração "para".`);
        const literalOuVariavelInicio = this.expressao();
        this.consumir(lexico_regular_1.default.ATE, `Esperado paravra reservada "ate" após literal ou identificador de estado inicial em declaração "para".`);
        const literalOuVariavelFim = this.expressao();
        this.consumir(lexico_regular_1.default.PASSO, `Esperado paravra reservada "passo" após literal ou identificador de estado final em declaração "para".`);
        let operadorCondicao = new delegua_1.Simbolo(lexico_regular_1.default.MENOR_IGUAL, '<=', null, Number(simboloPara.linha), this.hashArquivo);
        let operadorCondicaoIncremento = new delegua_1.Simbolo(lexico_regular_1.default.MENOR, '<', null, Number(simboloPara.linha), this.hashArquivo);
        // Se o valor do passo é uma variável, o passo só pode ser resolvido em
        // tempo de execução.
        let passo;
        let resolverIncrementoEmExecucao = false;
        if (literalOuVariavelInicio instanceof construtos_1.Literal && literalOuVariavelFim instanceof construtos_1.Literal) {
            passo = this.unario();
            if (passo.hasOwnProperty('operador') && passo.operador.tipo === lexico_regular_1.default.SUBTRACAO) {
                operadorCondicao = new delegua_1.Simbolo(lexico_regular_1.default.MAIOR_IGUAL, '>=', null, Number(simboloPara.linha), this.hashArquivo);
                operadorCondicaoIncremento = new delegua_1.Simbolo(lexico_regular_1.default.MAIOR, '>', null, Number(simboloPara.linha), this.hashArquivo);
            }
        }
        else {
            // Passo e operador de condição precisam ser resolvidos em tempo de execução.
            passo = undefined;
            operadorCondicao = undefined;
            operadorCondicaoIncremento = undefined;
            resolverIncrementoEmExecucao = true;
        }
        this.consumir(lexico_regular_1.default.FACA, `Esperado palavra reservada "faca" após literal ou identificador de estado inicial em declaração "para".`);
        const declaracoesBlocoPara = [];
        let simboloAtualBlocoPara = this.simbolos[this.atual];
        while (simboloAtualBlocoPara.tipo !== lexico_regular_1.default.FIM) {
            declaracoesBlocoPara.push(this.resolverDeclaracaoForaDeBloco());
            simboloAtualBlocoPara = this.simbolos[this.atual];
        }
        this.consumir(lexico_regular_1.default.FIM, '');
        this.consumir(lexico_regular_1.default.PARA, "Esperado palavra reservada 'para' após palavra reservada 'fim' para encerrar declaração 'para'.");
        this.consumir(lexico_regular_1.default.PONTO_VIRGULA, "Esperado ponto-e-vírgula após palavra reservada 'para' para encerrar declaração 'para'.");
        const corpo = new declaracoes_1.Bloco(this.hashArquivo, Number(simboloPara.linha) + 1, declaracoesBlocoPara.filter((d) => d));
        const declaracaoPara = new declaracoes_1.Para(this.hashArquivo, Number(simboloPara.linha), 
        // Inicialização.
        new construtos_1.Atribuir(this.hashArquivo, new construtos_1.Variavel(this.hashArquivo, simboloVariavelIteracao, 'inteiro'), literalOuVariavelInicio), 
        // Condição.
        new construtos_1.Binario(this.hashArquivo, new construtos_1.Variavel(this.hashArquivo, simboloVariavelIteracao), operadorCondicao, literalOuVariavelFim), 
        // Incremento, feito em construto especial `FimPara`.
        new construtos_1.FimPara(this.hashArquivo, Number(simboloPara.linha), new construtos_1.Binario(this.hashArquivo, new construtos_1.Variavel(this.hashArquivo, simboloVariavelIteracao), operadorCondicaoIncremento, literalOuVariavelFim), new declaracoes_1.Expressao(new construtos_1.Atribuir(this.hashArquivo, new construtos_1.Variavel(this.hashArquivo, simboloVariavelIteracao, 'inteiro'), new construtos_1.Binario(this.hashArquivo, new construtos_1.Variavel(this.hashArquivo, simboloVariavelIteracao), new delegua_1.Simbolo(lexico_regular_1.default.ADICAO, '', null, Number(simboloPara.linha), this.hashArquivo), passo)))), corpo);
        declaracaoPara.resolverIncrementoEmExecucao = resolverIncrementoEmExecucao;
        return declaracaoPara;
    }
    declaracaoSe() {
        const simboloSe = this.avancarEDevolverAnterior();
        const condicao = this.expressao();
        this.consumir(lexico_regular_1.default.ENTAO, "Esperado palavra reservada 'entao' após condição em declaração 'se'.");
        const declaracoes = [];
        let caminhoSenao = null;
        do {
            declaracoes.push(this.resolverDeclaracaoForaDeBloco());
            if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.SENAO)) {
                const simboloSenao = this.simbolos[this.atual - 1];
                const declaracoesSenao = [];
                do {
                    declaracoesSenao.push(this.resolverDeclaracaoForaDeBloco());
                } while (![lexico_regular_1.default.FIM].includes(this.simbolos[this.atual].tipo) &&
                    ![lexico_regular_1.default.SE].includes(this.simbolos[this.atual + 1].tipo));
                caminhoSenao = new declaracoes_1.Bloco(this.hashArquivo, Number(simboloSenao.linha), declaracoesSenao.filter((d) => d));
            }
        } while (![lexico_regular_1.default.FIM].includes(this.simbolos[this.atual].tipo) &&
            ![lexico_regular_1.default.SE].includes(this.simbolos[this.atual + 1].tipo));
        this.consumir(lexico_regular_1.default.FIM, "Esperado palavra-chave 'fim' para iniciar o fechamento de declaração 'se'.");
        this.consumir(lexico_regular_1.default.SE, "Esperado palavra-chave 'se' para o fechamento de declaração 'se'.");
        this.consumir(lexico_regular_1.default.PONTO_VIRGULA, "Esperado palavra-chave ';' para o fechamento de declaração 'se'.");
        return new declaracoes_1.Se(condicao, new declaracoes_1.Bloco(this.hashArquivo, Number(simboloSe.linha), declaracoes.filter((d) => d)), [], caminhoSenao);
    }
    resolverDeclaracaoForaDeBloco() {
        const simboloAtual = this.simbolos[this.atual];
        switch (simboloAtual.tipo) {
            case lexico_regular_1.default.COMENTARIO:
                return this.declaracaoComentario();
            case lexico_regular_1.default.ENQUANTO:
                return this.declaracaoEnquanto();
            case lexico_regular_1.default.ESCREVER:
                return this.declaracaoEscreva();
            case lexico_regular_1.default.FIM:
                this.lendoModulos = true;
                this.avancarEDevolverAnterior();
                return null;
            case lexico_regular_1.default.LER:
                return this.declaracaoLeia();
            case lexico_regular_1.default.MODULO:
                if (!this.lendoModulos) {
                    throw this.erro(simboloAtual, 'Esperado instrução "FIM" antes de começar a ler módulos.');
                }
                return this.declaracaoModulo();
            case lexico_regular_1.default.PARA:
                return this.declaracaoPara();
            // case tiposDeSimbolos.PARENTESE_DIREITO:
            //     throw new Error('Não deveria estar caindo aqui.');
            case lexico_regular_1.default.REPITA:
                return this.declaracaoFazer();
            case lexico_regular_1.default.SE:
                return this.declaracaoSe();
            default:
                return this.expressao();
        }
    }
    /**
     * No Mapler, há uma determinada cadência de validação de símbolos.
     * @param retornoLexador Os símbolos entendidos pelo Lexador.
     * @param hashArquivo Obrigatório por interface mas não usado aqui.
     */
    analisar(retornoLexador, hashArquivo) {
        this.erros = [];
        this.atual = 0;
        this.blocos = 0;
        this.lendoModulos = false;
        this.modulos = [];
        this.hashArquivo = hashArquivo || 0;
        this.simbolos = (retornoLexador === null || retornoLexador === void 0 ? void 0 : retornoLexador.simbolos) || [];
        let declaracoes = [];
        while (this.simbolos[this.atual].tipo === lexico_regular_1.default.COMENTARIO) {
            declaracoes.push(this.declaracaoComentario());
        }
        this.consumir(lexico_regular_1.default.VARIAVEIS, "Esperado expressão 'variaveis' para inicializar programa.");
        declaracoes = declaracoes.concat(this.validarSegmentoVariaveis());
        const simboloInicio = this.consumir(lexico_regular_1.default.INICIO, `Esperado expressão 'inicio' para marcar o início do programa.`);
        declaracoes.push(new declaracoes_1.InicioAlgoritmo(simboloInicio.linha, simboloInicio.hashArquivo));
        while (!this.estaNoFinal()) {
            declaracoes.push(this.resolverDeclaracaoForaDeBloco());
        }
        return {
            declaracoes: declaracoes.filter((d) => d),
            erros: this.erros,
        };
    }
}
exports.AvaliadorSintaticoMapler = AvaliadorSintaticoMapler;
//# sourceMappingURL=avaliador-sintatico-mapler.js.map