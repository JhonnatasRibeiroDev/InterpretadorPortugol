"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnalisadorSemanticoMapler = void 0;
const construtos_1 = require("@designliquido/delegua/construtos");
const erros_1 = require("@designliquido/delegua/interfaces/erros");
const analisador_semantico_base_1 = require("@designliquido/delegua/analisador-semantico/analisador-semantico-base");
const pilha_variaveis_1 = require("@designliquido/delegua/analisador-semantico/pilha-variaveis");
class AnalisadorSemanticoMapler extends analisador_semantico_base_1.AnalisadorSemanticoBase {
    constructor() {
        super();
        this.pilhaVariaveis = new pilha_variaveis_1.PilhaVariaveis();
        this.variaveis = {};
        this.funcoes = {};
        this.atual = 0;
        this.diagnosticos = [];
    }
    erro(simbolo, mensagem) {
        this.diagnosticos.push({
            simbolo: simbolo,
            mensagem: mensagem,
            hashArquivo: simbolo.hashArquivo,
            linha: simbolo.linha,
            severidade: erros_1.DiagnosticoSeveridade.ERRO,
        });
    }
    aviso(simbolo, mensagem) {
        this.diagnosticos.push({
            simbolo: simbolo,
            mensagem: mensagem,
            hashArquivo: simbolo.hashArquivo,
            linha: simbolo.linha,
            severidade: erros_1.DiagnosticoSeveridade.AVISO,
        });
    }
    visitarExpressaoDeAtribuicao(expressao) {
        // TODO: Readaptar para trabalhar com `expressao.alvo` sendo um construto.
        let simboloAlvo;
        switch (expressao.alvo.constructor.name) {
            case 'Variavel':
                const alvoVariavel = expressao.alvo;
                simboloAlvo = alvoVariavel.simbolo;
                break;
            default:
                // throw new Error(`Implementar atribuição para ${expressao.alvo.constructor.name}.`);
                return Promise.resolve();
        }
        let valor = this.variaveis[simboloAlvo.lexema];
        if (!valor) {
            this.erro(simboloAlvo, `Variável ${simboloAlvo.lexema} ainda não foi declarada até este ponto.`);
            return Promise.resolve();
        }
        if (valor.tipo) {
            if (expressao.valor instanceof construtos_1.Literal && valor.tipo.includes('[]')) {
                this.erro(simboloAlvo, `Atribuição inválida, esperado tipo '${valor.tipo}' na atribuição.`);
                return Promise.resolve();
            }
            if (expressao.valor instanceof construtos_1.Vetor && !valor.tipo.includes('[]')) {
                this.erro(simboloAlvo, `Atribuição inválida, esperado tipo '${valor.tipo}' na atribuição.`);
                return Promise.resolve();
            }
            if (expressao.valor instanceof construtos_1.Literal) {
                let valorLiteral = typeof expressao.valor.valor;
                if (!['qualquer'].includes(valor.tipo)) {
                    if (valorLiteral === 'string') {
                        if (valor.tipo != 'texto') {
                            this.erro(simboloAlvo, `Esperado tipo '${valor.tipo}' na atribuição.`);
                            return Promise.resolve();
                        }
                    }
                    if (valorLiteral === 'number') {
                        if (!['inteiro', 'real'].includes(valor.tipo)) {
                            this.erro(simboloAlvo, `Esperado tipo '${valor.tipo}' na atribuição.`);
                            return Promise.resolve();
                        }
                    }
                }
            }
        }
        if (this.variaveis[simboloAlvo.lexema]) {
            this.variaveis[simboloAlvo.lexema].valor = expressao.valor;
        }
    }
    visitarDeclaracaoDeExpressao(declaracao) {
        return declaracao.expressao.aceitar(this);
    }
    visitarDeclaracaoVar(declaracao) {
        this.variaveis[declaracao.simbolo.lexema] = {
            imutavel: false,
            tipo: declaracao.tipo,
            valor: declaracao.inicializador !== null
                ? declaracao.inicializador.valor !== undefined
                    ? declaracao.inicializador.valor
                    : declaracao.inicializador
                : undefined,
            valorDefinido: true,
        };
        return Promise.resolve();
    }
    visitarExpressaoRetornar(declaracao) {
        return Promise.resolve(null);
    }
    analisar(declaracoes) {
        this.variaveis = {};
        this.atual = 0;
        this.diagnosticos = [];
        while (this.atual < declaracoes.length) {
            declaracoes[this.atual].aceitar(this);
            this.atual++;
        }
        return {
            diagnosticos: this.diagnosticos,
        };
    }
}
exports.AnalisadorSemanticoMapler = AnalisadorSemanticoMapler;
//# sourceMappingURL=analisador-semantico-mapler.js.map