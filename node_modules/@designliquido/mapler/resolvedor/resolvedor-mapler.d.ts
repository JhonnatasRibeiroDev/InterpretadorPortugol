import { Aleatorio, CabecalhoPrograma, Classe, Comentario, Const, ConstMultiplo, Expressao, FuncaoDeclaracao, Enquanto, Escolha, Escreva, EscrevaMesmaLinha, Fazer, Importar, InicioAlgoritmo, Para, ParaCada, Se, TendoComo, Tente, Var, VarMultiplo, Atribuir, AcessoIndiceVariavel, AcessoElementoMatriz, AcessoMetodoOuPropriedade, Agrupamento, AtribuicaoPorIndice, AtribuicaoPorIndicesMatriz, Binario, Bloco, Continua, Chamada, DefinirValor, FuncaoConstruto, Variavel, Constante, Dicionario, ExpressaoRegular, Falhar, FimPara, FormatacaoEscrita, Isto, Leia, Literal, Logico, Retorna, Super, Sustar, Tupla, TipoDe, Unario, Vetor, Declaracao, Construto, AcessoMetodo, AcessoPropriedade, ArgumentoReferenciaFuncao, ReferenciaFuncao } from '@designliquido/delegua';
import { VisitanteComumInterface } from '@designliquido/delegua/interfaces';
import { ContinuarQuebra, RetornoQuebra, SustarQuebra } from '@designliquido/delegua/quebras';
import { DeclaracaoFutura } from '../declaracoes/declaracao-futura';
/**
 * Um resolvedor executa após a avaliação sintática, para:
 * - Resolver referências marcadas como futuras;
 * - Trazer declarações de módulos antes do bloco de execução, antes da interpretação.
 *
 * Em Mapler, isso acontece porque módulos (funções) são declarados após o bloco principal de execução.
 * Em Delégua, as declarações precisam vir antes da execução propriamente dita.
 * No entanto, não é papel do avaliador sintático colocar isso em ordem, até porque a avaliação sintática
 * serve a diferentes propósitos, como a formatação de código, por exemplo.
 */
export declare class ResolvedorMapler implements VisitanteComumInterface {
    declaracoesModulos: {
        [nome: string]: FuncaoDeclaracao;
    };
    constructor();
    visitarExpressaoFuncaoConstruto(expressao: FuncaoConstruto): Promise<any> | void;
    visitarExpressaoArgumentoReferenciaFuncao(expressao: ArgumentoReferenciaFuncao): Promise<any> | void;
    visitarExpressaoReferenciaFuncao(expressao: ReferenciaFuncao): Promise<any> | void;
    visitarExpressaoAcessoMetodo(expressao: AcessoMetodo): Promise<any> | void;
    visitarExpressaoAcessoPropriedade(expressao: AcessoPropriedade): Promise<any> | void;
    visitarDeclaracaoAleatorio(declaracao: Aleatorio): Promise<any>;
    visitarDeclaracaoCabecalhoPrograma(declaracao: CabecalhoPrograma): Promise<any>;
    visitarDeclaracaoClasse(declaracao: Classe): void | Promise<any>;
    visitarDeclaracaoComentario(declaracao: Comentario): void | Promise<any>;
    visitarDeclaracaoConst(declaracao: Const): Promise<any>;
    visitarDeclaracaoConstMultiplo(declaracao: ConstMultiplo): Promise<any>;
    visitarDeclaracaoDeExpressao(declaracao: Expressao): void | Promise<any>;
    visitarDeclaracaoDefinicaoFuncao(declaracao: FuncaoDeclaracao): void;
    visitarDeclaracaoEnquanto(declaracao: Enquanto): void | Promise<any>;
    visitarDeclaracaoEscolha(declaracao: Escolha): void | Promise<any>;
    visitarDeclaracaoEscreva(declaracao: Escreva): void | Promise<any>;
    visitarDeclaracaoEscrevaMesmaLinha(declaracao: EscrevaMesmaLinha): void | Promise<any>;
    visitarDeclaracaoFazer(declaracao: Fazer): Promise<any>;
    visitarDeclaracaoFutura(declaracao: DeclaracaoFutura): Promise<any>;
    visitarDeclaracaoImportar(declaracao: Importar): void | Promise<any>;
    visitarDeclaracaoInicioAlgoritmo(declaracao: InicioAlgoritmo): Promise<any>;
    visitarDeclaracaoPara(declaracao: Para): Promise<any>;
    visitarDeclaracaoParaCada(declaracao: ParaCada): Promise<any>;
    visitarDeclaracaoSe(declaracao: Se): Promise<any>;
    visitarDeclaracaoTendoComo(declaracao: TendoComo): void | Promise<any>;
    visitarDeclaracaoTente(declaracao: Tente): void | Promise<any>;
    visitarDeclaracaoVar(declaracao: Var): Promise<any>;
    visitarDeclaracaoVarMultiplo(declaracao: VarMultiplo): Promise<any>;
    visitarExpressaoDeAtribuicao(expressao: Atribuir<string>): void | Promise<any>;
    visitarExpressaoAcessoIndiceVariavel(expressao: AcessoIndiceVariavel<string>): void | Promise<any>;
    visitarExpressaoAcessoElementoMatriz(expressao: AcessoElementoMatriz<string>): void | Promise<any>;
    visitarExpressaoAcessoMetodoOuPropriedade(expressao: AcessoMetodoOuPropriedade<string>): void | Promise<any>;
    visitarExpressaoAgrupamento(expressao: Agrupamento): Promise<any>;
    visitarExpressaoAtribuicaoPorIndice(expressao: AtribuicaoPorIndice): Promise<any>;
    visitarExpressaoAtribuicaoPorIndicesMatriz(expressao: AtribuicaoPorIndicesMatriz): Promise<any>;
    visitarExpressaoBinaria(expressao: Binario<string>): void | Promise<any>;
    visitarExpressaoBloco(declaracao: Bloco): Promise<any>;
    visitarExpressaoContinua(declaracao?: Continua): ContinuarQuebra;
    visitarExpressaoDeChamada(expressao: Chamada): void | Promise<any>;
    visitarExpressaoDefinirValor(expressao: DefinirValor<string>): void | Promise<any>;
    visitarExpressaoDeVariavel(expressao: Variavel<string> | Constante<string>): void | Promise<any>;
    visitarExpressaoDicionario(expressao: Dicionario): void | Promise<any>;
    visitarExpressaoExpressaoRegular(expressao: ExpressaoRegular<string>): Promise<RegExp>;
    visitarExpressaoFalhar(expressao: Falhar): Promise<any>;
    visitarExpressaoFimPara(declaracao: FimPara): void | Promise<any>;
    visitarExpressaoFormatacaoEscrita(declaracao: FormatacaoEscrita): void | Promise<any>;
    visitarExpressaoIsto(expressao: Isto): void | Promise<any>;
    visitarExpressaoLeia(expressao: Leia): Promise<any>;
    visitarExpressaoLiteral(expressao: Literal): Promise<any>;
    visitarExpressaoLogica(expressao: Logico<string>): void | Promise<any>;
    visitarExpressaoRetornar(declaracao: Retorna): Promise<RetornoQuebra>;
    visitarExpressaoSuper(expressao: Super<string>): void | Promise<any>;
    visitarExpressaoSustar(declaracao?: Sustar): SustarQuebra;
    visitarExpressaoTupla(expressao: Tupla): Promise<any>;
    visitarExpressaoTipoDe(expressao: TipoDe<string>): Promise<any>;
    visitarExpressaoUnaria(expressao: Unario<string>): void | Promise<any>;
    visitarExpressaoVetor(expressao: Vetor): void | Promise<any>;
    protected resolverDeclaracaoOuConstrutoForaDeBloco(declaracaoOuConstruto: Declaracao | Construto): Promise<any>;
    /**
     * Resolve referências futuras e reordena declarações para
     * correta execução pelo interpretador.
     * @param declaracoes O vetor original de declarações vindo da avaliação sintática.
     * @returns Um novo vetor de declarações, preparado para interpretação.
     */
    resolver(declaracoes: Declaracao[]): Promise<Declaracao[]>;
}
//# sourceMappingURL=resolvedor-mapler.d.ts.map