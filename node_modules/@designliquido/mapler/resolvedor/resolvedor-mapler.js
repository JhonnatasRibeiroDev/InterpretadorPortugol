"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResolvedorMapler = void 0;
const delegua_1 = require("@designliquido/delegua");
const quebras_1 = require("@designliquido/delegua/quebras");
/**
 * Um resolvedor executa após a avaliação sintática, para:
 * - Resolver referências marcadas como futuras;
 * - Trazer declarações de módulos antes do bloco de execução, antes da interpretação.
 *
 * Em Mapler, isso acontece porque módulos (funções) são declarados após o bloco principal de execução.
 * Em Delégua, as declarações precisam vir antes da execução propriamente dita.
 * No entanto, não é papel do avaliador sintático colocar isso em ordem, até porque a avaliação sintática
 * serve a diferentes propósitos, como a formatação de código, por exemplo.
 */
class ResolvedorMapler {
    constructor() {
        this.declaracoesModulos = {};
    }
    visitarExpressaoFuncaoConstruto(expressao) {
        return Promise.resolve(expressao);
    }
    visitarExpressaoArgumentoReferenciaFuncao(expressao) {
        return Promise.resolve(expressao);
    }
    visitarExpressaoReferenciaFuncao(expressao) {
        return Promise.resolve(expressao);
    }
    visitarExpressaoAcessoMetodo(expressao) {
        return Promise.resolve(expressao);
    }
    visitarExpressaoAcessoPropriedade(expressao) {
        return Promise.resolve(expressao);
    }
    visitarDeclaracaoAleatorio(declaracao) {
        return Promise.resolve(declaracao);
    }
    visitarDeclaracaoCabecalhoPrograma(declaracao) {
        return Promise.resolve(declaracao);
    }
    visitarDeclaracaoClasse(declaracao) {
        return Promise.resolve(declaracao);
    }
    visitarDeclaracaoComentario(declaracao) {
        return Promise.resolve(declaracao);
    }
    visitarDeclaracaoConst(declaracao) {
        return Promise.resolve(declaracao);
    }
    visitarDeclaracaoConstMultiplo(declaracao) {
        return Promise.resolve(declaracao);
    }
    visitarDeclaracaoDeExpressao(declaracao) {
        return Promise.resolve(declaracao);
    }
    visitarDeclaracaoDefinicaoFuncao(declaracao) { }
    visitarDeclaracaoEnquanto(declaracao) {
        return Promise.resolve(declaracao);
    }
    visitarDeclaracaoEscolha(declaracao) {
        return Promise.resolve(declaracao);
    }
    visitarDeclaracaoEscreva(declaracao) {
        return Promise.resolve(declaracao);
    }
    visitarDeclaracaoEscrevaMesmaLinha(declaracao) {
        return Promise.resolve(declaracao);
    }
    async visitarDeclaracaoFazer(declaracao) {
        declaracao.condicaoEnquanto = await this.resolverDeclaracaoOuConstrutoForaDeBloco(declaracao.condicaoEnquanto);
        declaracao.caminhoFazer = await this.visitarExpressaoBloco(declaracao.caminhoFazer);
        return declaracao;
    }
    async visitarDeclaracaoFutura(declaracao) {
        const declaracaoModuloCorrespondente = this.declaracoesModulos[declaracao.identificadorFuturo];
        return Promise.resolve(new delegua_1.Expressao(new delegua_1.Chamada(declaracao.hashArquivo, declaracaoModuloCorrespondente.funcao, [])));
    }
    visitarDeclaracaoImportar(declaracao) {
        return Promise.resolve(declaracao);
    }
    visitarDeclaracaoInicioAlgoritmo(declaracao) {
        return Promise.resolve(declaracao);
    }
    async visitarDeclaracaoPara(declaracao) {
        if (declaracao.inicializador) {
            declaracao.inicializador = await this.resolverDeclaracaoOuConstrutoForaDeBloco(declaracao.inicializador);
        }
        declaracao.condicao = await this.resolverDeclaracaoOuConstrutoForaDeBloco(declaracao.condicao);
        return declaracao;
    }
    visitarDeclaracaoParaCada(declaracao) {
        return Promise.resolve(declaracao);
    }
    async visitarDeclaracaoSe(declaracao) {
        declaracao.condicao = await this.resolverDeclaracaoOuConstrutoForaDeBloco(declaracao.condicao);
        declaracao.caminhoEntao = await this.resolverDeclaracaoOuConstrutoForaDeBloco(declaracao.caminhoEntao);
        if (declaracao.caminhoSenao) {
            declaracao.caminhoSenao = await this.resolverDeclaracaoOuConstrutoForaDeBloco(declaracao.caminhoSenao);
        }
        return declaracao;
    }
    visitarDeclaracaoTendoComo(declaracao) {
        return Promise.resolve(declaracao);
    }
    visitarDeclaracaoTente(declaracao) {
        return Promise.resolve(declaracao);
    }
    visitarDeclaracaoVar(declaracao) {
        return Promise.resolve(declaracao);
    }
    visitarDeclaracaoVarMultiplo(declaracao) {
        return Promise.resolve(declaracao);
    }
    visitarExpressaoDeAtribuicao(expressao) {
        return Promise.resolve(expressao);
    }
    visitarExpressaoAcessoIndiceVariavel(expressao) {
        return Promise.resolve(expressao);
    }
    visitarExpressaoAcessoElementoMatriz(expressao) {
        return Promise.resolve(expressao);
    }
    visitarExpressaoAcessoMetodoOuPropriedade(expressao) {
        return Promise.resolve(expressao);
    }
    visitarExpressaoAgrupamento(expressao) {
        return Promise.resolve(expressao);
    }
    visitarExpressaoAtribuicaoPorIndice(expressao) {
        return Promise.resolve(expressao);
    }
    visitarExpressaoAtribuicaoPorIndicesMatriz(expressao) {
        return Promise.resolve(expressao);
    }
    visitarExpressaoBinaria(expressao) {
        return Promise.resolve(expressao);
    }
    async visitarExpressaoBloco(declaracao) {
        const declaracoesResolvidas = [];
        for (let blocoDeclaracao of declaracao.declaracoes) {
            declaracoesResolvidas.push(await this.resolverDeclaracaoOuConstrutoForaDeBloco(blocoDeclaracao));
        }
        declaracao.declaracoes = declaracoesResolvidas;
        return declaracao;
    }
    visitarExpressaoContinua(declaracao) {
        return new quebras_1.ContinuarQuebra();
    }
    visitarExpressaoDeChamada(expressao) {
        return Promise.resolve(expressao);
    }
    visitarExpressaoDefinirValor(expressao) {
        return Promise.resolve(expressao);
    }
    visitarExpressaoDeVariavel(expressao) {
        return Promise.resolve(expressao);
    }
    visitarExpressaoDicionario(expressao) {
        return Promise.resolve(expressao);
    }
    visitarExpressaoExpressaoRegular(expressao) {
        return Promise.resolve(null);
    }
    visitarExpressaoFalhar(expressao) {
        return Promise.resolve(expressao);
    }
    visitarExpressaoFimPara(declaracao) {
        return Promise.resolve(declaracao);
    }
    visitarExpressaoFormatacaoEscrita(declaracao) {
        return Promise.resolve(declaracao);
    }
    visitarExpressaoIsto(expressao) {
        return Promise.resolve(expressao);
    }
    visitarExpressaoLeia(expressao) {
        return Promise.resolve(expressao);
    }
    visitarExpressaoLiteral(expressao) {
        return Promise.resolve(expressao);
    }
    visitarExpressaoLogica(expressao) {
        return Promise.resolve(expressao);
    }
    visitarExpressaoRetornar(declaracao) {
        return Promise.resolve(declaracao);
    }
    visitarExpressaoSuper(expressao) {
        return Promise.resolve(expressao);
    }
    visitarExpressaoSustar(declaracao) {
        return new quebras_1.SustarQuebra();
    }
    visitarExpressaoTupla(expressao) {
        return Promise.resolve(expressao);
    }
    visitarExpressaoTipoDe(expressao) {
        return Promise.resolve(expressao);
    }
    visitarExpressaoUnaria(expressao) {
        return Promise.resolve(expressao);
    }
    visitarExpressaoVetor(expressao) {
        return Promise.resolve(expressao);
    }
    async resolverDeclaracaoOuConstrutoForaDeBloco(declaracaoOuConstruto) {
        switch (declaracaoOuConstruto.constructor.name) {
            case 'Bloco':
                return this.visitarExpressaoBloco(declaracaoOuConstruto);
            case 'DeclaracaoFutura':
                return this.visitarDeclaracaoFutura(declaracaoOuConstruto);
            case 'Enquanto':
                return this.visitarDeclaracaoEnquanto(declaracaoOuConstruto);
            case 'Escreva':
                return this.visitarDeclaracaoEscreva(declaracaoOuConstruto);
            case 'Leia':
                return this.visitarExpressaoLeia(declaracaoOuConstruto);
            case 'FuncaoDeclaracao':
                return this.visitarDeclaracaoDefinicaoFuncao(declaracaoOuConstruto);
            case 'Para':
                return this.visitarDeclaracaoPara(declaracaoOuConstruto);
            case 'Fazer':
                return this.visitarDeclaracaoFazer(declaracaoOuConstruto);
            case 'Se':
                return this.visitarDeclaracaoSe(declaracaoOuConstruto);
            default:
                return Promise.resolve(declaracaoOuConstruto);
        }
    }
    /**
     * Resolve referências futuras e reordena declarações para
     * correta execução pelo interpretador.
     * @param declaracoes O vetor original de declarações vindo da avaliação sintática.
     * @returns Um novo vetor de declarações, preparado para interpretação.
     */
    async resolver(declaracoes) {
        const declaracoesResolvidas = [];
        for (let declaracaoModulo of declaracoes.filter((declaracao) => declaracao instanceof delegua_1.FuncaoDeclaracao)) {
            const declaracaoModuloTipada = declaracaoModulo;
            this.declaracoesModulos[declaracaoModuloTipada.simbolo.lexema] = declaracaoModuloTipada;
            declaracoesResolvidas.push(declaracaoModuloTipada);
        }
        for (let declaracao of declaracoes) {
            declaracoesResolvidas.push(await this.resolverDeclaracaoOuConstrutoForaDeBloco(declaracao));
        }
        return declaracoesResolvidas.filter((d) => d);
    }
}
exports.ResolvedorMapler = ResolvedorMapler;
//# sourceMappingURL=resolvedor-mapler.js.map