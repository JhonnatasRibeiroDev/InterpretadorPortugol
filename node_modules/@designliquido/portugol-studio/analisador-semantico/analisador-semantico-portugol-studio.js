"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnalisadorSemanticoPortugolStudio = void 0;
const declaracoes_1 = require("@designliquido/delegua/declaracoes");
const analisador_semantico_base_1 = require("@designliquido/delegua/analisador-semantico/analisador-semantico-base");
const erros_1 = require("@designliquido/delegua/interfaces/erros");
const pilha_variaveis_1 = require("./pilha-variaveis");
const construtos_1 = require("@designliquido/delegua/construtos");
const inferenciador_1 = require("../interpretador/inferenciador");
const tipos_de_dados_1 = __importDefault(require("../tipos-de-dados"));
class AnalisadorSemanticoPortugolStudio extends analisador_semantico_base_1.AnalisadorSemanticoBase {
    constructor() {
        super();
        this.corpoMetodoPrincipal = [];
        this.pilhaVariaveis = new pilha_variaveis_1.PilhaVariaveis();
        this.variaveis = {};
        this.funcoes = {};
        this.atual = 0;
        this.diagnosticos = [];
    }
    adicionarDiagnostico(simbolo, mensagem, severidade = erros_1.DiagnosticoSeveridade.ERRO) {
        this.diagnosticos.push({
            simbolo: simbolo,
            mensagem: mensagem,
            hashArquivo: simbolo.hashArquivo,
            linha: simbolo.linha,
            severidade: severidade,
        });
    }
    visitarDeclaracaoEscrevaMesmaLinha(declaracao) {
        declaracao.argumentos.forEach((argumento) => {
            if (argumento instanceof construtos_1.Variavel && !this.variaveis[argumento.simbolo.lexema]) {
                this.adicionarDiagnostico(argumento.simbolo, `Variável não declarada: ${argumento.simbolo.lexema}`);
            }
        });
        return Promise.resolve();
    }
    visitarDeclaracaoDefinicaoFuncao(declaracao) {
        for (let parametro of declaracao.funcao.parametros) {
            if (parametro.hasOwnProperty('tipoDado') && !parametro.tipoDado) {
                this.adicionarDiagnostico(declaracao.simbolo, `O tipo '${parametro.tipoDado}' não é valido`);
            }
        }
        if (declaracao.funcao.parametros.length >= 255) {
            this.adicionarDiagnostico(declaracao.simbolo, 'Não pode haver mais de 255 parâmetros');
        }
        this.funcoes[declaracao.simbolo.lexema] = {
            valor: declaracao.funcao,
        };
        return Promise.resolve();
    }
    visitarDeclaracaoVar(declaracao) {
        const { simbolo, inicializador } = declaracao;
        if (inicializador instanceof construtos_1.Variavel) {
            const { simbolo: simboloInicializador } = inicializador;
            const variavelExistente = this.variaveis[simboloInicializador.lexema];
            if (!variavelExistente) {
                this.adicionarDiagnostico(simboloInicializador, `Variável não declarada: ${simboloInicializador.lexema}.`);
                return Promise.resolve();
            }
            const tipoInferido = (0, inferenciador_1.inferirTipoVariavel)(variavelExistente.valor);
            if (tipoInferido !== declaracao.tipo) {
                const erroTipo = this.validarCompatibilidadeTipos(tipoInferido, declaracao.tipo);
                if (erroTipo) {
                    this.adicionarDiagnostico(simbolo, erroTipo);
                    return Promise.resolve();
                }
            }
        }
        this.variaveis[simbolo.lexema] = {
            imutavel: false,
            tipo: declaracao.tipo,
            valor: inicializador !== null
                ? inicializador.valor !== undefined
                    ? inicializador.valor
                    : inicializador
                : undefined,
            valorDefinido: true,
        };
        return Promise.resolve();
    }
    visitarExpressaoDeVariavel(expressao) {
        /* TODO - Atualmente o tipo "caracter vem como instância de variável,
        causando assim erros como reportado na issue #31
         */
        return Promise.resolve();
    }
    validarCompatibilidadeTipos(tipoInferido, tipoEsperado) {
        switch (tipoEsperado) {
            case tipos_de_dados_1.default.CADEIA:
                if (tipoInferido !== tipos_de_dados_1.default.CARACTER) {
                    return `Não é possível atribuir um valor do tipo '${tipoInferido}' a uma variável do tipo '${tipoEsperado}'.`;
                }
                break;
            case tipos_de_dados_1.default.REAL:
                if (tipoInferido !== tipos_de_dados_1.default.INTEIRO) {
                    return `Não é possível atribuir um valor do tipo '${tipoInferido}' a uma variável do tipo '${tipoEsperado}'.`;
                }
                break;
            default:
                return `Não é possível atribuir um valor do tipo '${tipoInferido}' a uma variável do tipo '${tipoEsperado}'.`;
        }
        return null;
    }
    visitarExpressaoDeAtribuicao(expressao) {
        const { valor, alvo } = expressao;
        let simboloAlvo = null;
        let nomeVariavel = null;
        switch (alvo.constructor.name) {
            case 'Variavel':
                const alvoVariavel = alvo;
                simboloAlvo = alvoVariavel.simbolo;
                nomeVariavel = simboloAlvo.lexema;
                break;
            default:
                return Promise.reject('Terminar');
        }
        if (valor instanceof construtos_1.Variavel) {
            const variavelExistente = this.variaveis[valor.simbolo.lexema];
            if (!variavelExistente) {
                this.adicionarDiagnostico(valor.simbolo, `Variável não declarada: ${valor.simbolo.lexema}.`);
                return Promise.resolve();
            }
            const tipoInferido = (0, inferenciador_1.inferirTipoVariavel)(variavelExistente.valor);
            if (tipoInferido !== variavelExistente.tipo) {
                const erroTipo = this.validarCompatibilidadeTipos(variavelExistente.tipo, tipoInferido);
                if (erroTipo) {
                    this.adicionarDiagnostico(valor.simbolo, erroTipo);
                    return Promise.resolve();
                }
            }
        }
        const variavel = this.variaveis[nomeVariavel];
        if (!variavel) {
            this.adicionarDiagnostico(simboloAlvo, `Variável não declarada: ${simboloAlvo.lexema}.`);
            return Promise.resolve();
        }
        if (variavel.imutavel) {
            this.adicionarDiagnostico(simboloAlvo, 'Não é possível alterar o valor de uma constante.');
            return Promise.resolve();
        }
        if (variavel.tipo && valor instanceof construtos_1.Literal) {
            const tipoInferido = (0, inferenciador_1.inferirTipoVariavel)(valor.valor);
            if (tipoInferido !== variavel.tipo) {
                const erroTipo = this.validarCompatibilidadeTipos(tipoInferido, variavel.tipo);
                if (erroTipo) {
                    this.adicionarDiagnostico(simboloAlvo, erroTipo);
                    return Promise.resolve();
                }
            }
        }
        this.variaveis[nomeVariavel].valor = valor;
    }
    visitarExpressaoDeChamada(expressao) {
        if (expressao.entidadeChamada instanceof construtos_1.Variavel) {
            const variavel = expressao.entidadeChamada;
            const funcaoChamada = this.variaveis[variavel.simbolo.lexema] || this.funcoes[variavel.simbolo.lexema];
            if (!funcaoChamada) {
                this.adicionarDiagnostico(variavel.simbolo, `Função não declarada: ${variavel.simbolo.lexema}`);
                return Promise.resolve();
            }
            const funcao = funcaoChamada.valor;
            if (funcao.parametros.length != expressao.argumentos.length) {
                this.adicionarDiagnostico(variavel.simbolo, `Esperava ${funcao.parametros.length} ${funcao.parametros.length > 1 ? 'parâmetros' : 'parâmetro'}, mas foi passado ${expressao.argumentos.length}.`);
            }
            for (let [indice, argumento] of expressao.argumentos.entries()) {
                const parametroCorrespondente = funcao.parametros[indice];
                if (parametroCorrespondente.tipoDado) {
                    const tipoDadoParametro = parametroCorrespondente.tipoDado.toLowerCase();
                    if (argumento instanceof construtos_1.Variavel) {
                        const lexemaVariavelCorrespondente = argumento.simbolo.lexema;
                        const tipoVariavelCorrespondente = this.variaveis[lexemaVariavelCorrespondente].tipo.toLowerCase();
                        if (tipoVariavelCorrespondente !== tipoDadoParametro) {
                            this.adicionarDiagnostico(variavel.simbolo, `O tipo do valor passado para o parâmetro '${parametroCorrespondente.nome.lexema}' (${tipoVariavelCorrespondente}) é diferente do esperado pela função (${tipoDadoParametro}).`);
                        }
                    }
                    if (argumento instanceof construtos_1.Literal) {
                        switch (argumento.valor.constructor.name) {
                            case 'Number':
                                if (!['inteiro', 'real'].includes(tipoDadoParametro)) {
                                    this.adicionarDiagnostico(variavel.simbolo, `O tipo do valor passado para o parâmetro '${parametroCorrespondente.nome.lexema}' (inteiro ou real) é diferente do esperado pela função (${tipoDadoParametro}).`);
                                }
                                break;
                        }
                    }
                }
                else {
                    this.adicionarDiagnostico(variavel.simbolo, 'Tipo de dados não especificado');
                }
            }
        }
        return Promise.resolve();
    }
    visitarExpressaoAtribuicaoPorIndice(expressao) {
        const atribuir = new construtos_1.Atribuir(expressao.hashArquivo, expressao.objeto, expressao.valor, expressao.indice);
        this.visitarExpressaoDeAtribuicao(atribuir);
        return Promise.resolve();
    }
    visitarDeclaracaoDeExpressao(declaracao) {
        switch (declaracao.expressao.constructor.name) {
            case 'Atribuir':
                this.visitarExpressaoDeAtribuicao(declaracao.expressao);
                break;
            case 'Chamada':
                this.visitarExpressaoDeChamada(declaracao.expressao);
                break;
            case 'Variavel':
                this.visitarExpressaoDeVariavel(declaracao.expressao);
                break;
            case 'AtribuicaoPorIndice':
                this.visitarExpressaoAtribuicaoPorIndice(declaracao.expressao);
                break;
            default:
                console.log(declaracao.expressao);
                break;
        }
        return Promise.resolve();
    }
    visitarDeclaracaoConst(declaracao) {
        this.variaveis[declaracao.simbolo.lexema] = {
            imutavel: true,
            tipo: declaracao.tipo,
            valor: declaracao.inicializador !== null
                ? declaracao.inicializador.valor !== undefined
                    ? declaracao.inicializador.valor
                    : declaracao.inicializador
                : undefined,
            valorDefinido: true,
        };
        return Promise.resolve();
    }
    analisar(declaracoes) {
        this.variaveis = {};
        this.atual = 0;
        this.diagnosticos = [];
        this.corpoMetodoPrincipal = [];
        const declaracaoMetodoPrincipal = declaracoes.find((declaracao) => declaracao instanceof declaracoes_1.FuncaoDeclaracao && declaracao.simbolo.lexema === 'inicio');
        if (declaracaoMetodoPrincipal) {
            this.corpoMetodoPrincipal = declaracaoMetodoPrincipal.funcao.corpo;
        }
        for (const declaracao of declaracoes) {
            if (declaracao instanceof declaracoes_1.FuncaoDeclaracao || declaracao instanceof declaracoes_1.Var) {
                if (declaracao.simbolo.lexema !== 'inicio') {
                    declaracao.aceitar(this);
                }
            }
        }
        while (this.atual < this.corpoMetodoPrincipal.length) {
            this.corpoMetodoPrincipal[this.atual].aceitar(this);
            this.atual++;
        }
        return {
            diagnosticos: this.diagnosticos,
        };
    }
}
exports.AnalisadorSemanticoPortugolStudio = AnalisadorSemanticoPortugolStudio;
//# sourceMappingURL=analisador-semantico-portugol-studio.js.map