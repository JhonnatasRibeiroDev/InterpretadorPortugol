"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.avaliarArgumentosEscreva = avaliarArgumentosEscreva;
exports.visitarExpressaoImportarComum = visitarExpressaoImportarComum;
exports.visitarExpressaoLeiaComum = visitarExpressaoLeiaComum;
exports.visitarExpressaoMatrizComum = visitarExpressaoMatrizComum;
const construtos_1 = require("@designliquido/delegua/construtos");
const declaracoes_1 = require("@designliquido/delegua/declaracoes");
const estruturas_1 = require("@designliquido/delegua/estruturas");
const excecoes_1 = require("@designliquido/delegua/excecoes");
const inferenciador_1 = require("./inferenciador");
const arquivos = __importStar(require("../bibliotecas/arquivos"));
const calendario = __importStar(require("../bibliotecas/calendario"));
const internet = __importStar(require("../bibliotecas/internet"));
const matematica = __importStar(require("../bibliotecas/matematica"));
const objetos = __importStar(require("../bibliotecas/objetos"));
const texto = __importStar(require("../bibliotecas/texto"));
const tipos = __importStar(require("../bibliotecas/tipos"));
const util = __importStar(require("../bibliotecas/util"));
function carregarBibliotecaArquivos() {
    const metodos = {
        abrir_arquivo: new estruturas_1.FuncaoPadrao(2, arquivos.abrir_arquivo),
        fechar_arquivo: new estruturas_1.FuncaoPadrao(1, arquivos.fechar_arquivo),
        fim_arquivo: new estruturas_1.FuncaoPadrao(1, arquivos.fim_arquivo),
        ler_linha: new estruturas_1.FuncaoPadrao(1, arquivos.ler_linha),
        escrever_linha: new estruturas_1.FuncaoPadrao(2, arquivos.escrever_linha),
        substituir_texto: new estruturas_1.FuncaoPadrao(4, arquivos.substituir_texto),
        arquivo_existe: new estruturas_1.FuncaoPadrao(1, arquivos.arquivo_existe),
        apagar_arquivo: new estruturas_1.FuncaoPadrao(1, arquivos.apagar_arquivo),
        criar_pasta: new estruturas_1.FuncaoPadrao(1, arquivos.criar_pasta),
        listar_pastas: new estruturas_1.FuncaoPadrao(2, arquivos.listar_pastas),
        listar_arquivos: new estruturas_1.FuncaoPadrao(2, arquivos.listar_arquivos),
        listar_arquivos_por_tipo: new estruturas_1.FuncaoPadrao(3, arquivos.listar_arquivos_por_tipo),
    };
    const objetoArquivos = new estruturas_1.DeleguaModulo('Arquivos');
    objetoArquivos.componentes = metodos;
    return objetoArquivos;
}
function carregarBibliotecaCalendario() {
    const metodos = {
        dia_mes_atual: new estruturas_1.FuncaoPadrao(0, calendario.dia_mes_atual),
        dia_semana_atual: new estruturas_1.FuncaoPadrao(0, calendario.dia_semana_atual),
        mes_atual: new estruturas_1.FuncaoPadrao(0, calendario.mes_atual),
        ano_atual: new estruturas_1.FuncaoPadrao(0, calendario.ano_atual),
        hora_atual: new estruturas_1.FuncaoPadrao(0, calendario.hora_atual),
        minuto_atual: new estruturas_1.FuncaoPadrao(0, calendario.minuto_atual),
        segundo_atual: new estruturas_1.FuncaoPadrao(0, calendario.segundo_atual),
        milisegundo_atual: new estruturas_1.FuncaoPadrao(0, calendario.milisegundo_atual),
        dia_semana_completo: new estruturas_1.FuncaoPadrao(0, calendario.dia_semana_completo),
        dia_semana_curto: new estruturas_1.FuncaoPadrao(0, calendario.dia_semana_completo),
    };
    const objetoCalendario = new estruturas_1.DeleguaModulo('Calendario');
    objetoCalendario.componentes = metodos;
    return objetoCalendario;
}
function carregarBibliotecaInternet() {
    const metodos = {
        definir_tempo_limite: new estruturas_1.FuncaoPadrao(1, internet.definir_tempo_limite),
        obter_texto: new estruturas_1.FuncaoPadrao(1, internet.obter_texto),
        baixar_imagem: new estruturas_1.FuncaoPadrao(2, internet.baixar_imagem),
        endereco_disponivel: new estruturas_1.FuncaoPadrao(1, internet.endereco_disponivel),
    };
    const objetoInternet = new estruturas_1.DeleguaModulo('Internet');
    objetoInternet.componentes = metodos;
    return objetoInternet;
}
function carregarBibliotecaMatematica() {
    const metodos = {
        potencia: new estruturas_1.FuncaoPadrao(2, matematica.potencia),
        raiz: new estruturas_1.FuncaoPadrao(2, matematica.raiz),
        arredondar: new estruturas_1.FuncaoPadrao(2, matematica.arredondar),
        logaritmo: new estruturas_1.FuncaoPadrao(2, matematica.logaritmo),
        seno: new estruturas_1.FuncaoPadrao(1, matematica.seno),
        cosseno: new estruturas_1.FuncaoPadrao(1, matematica.cosseno),
        tangente: new estruturas_1.FuncaoPadrao(1, matematica.tangente),
        valor_absoluto: new estruturas_1.FuncaoPadrao(1, matematica.valor_absoluto),
        maior_numero: new estruturas_1.FuncaoPadrao(2, matematica.maior_numero),
        menor_numero: new estruturas_1.FuncaoPadrao(2, matematica.menor_numero),
    };
    const objetoMatematica = new estruturas_1.DeleguaModulo('Matematica');
    objetoMatematica.componentes = metodos;
    return objetoMatematica;
}
function carregarBibliotecaObjetos() {
    const metodos = {
        atribuir_propriedade: new estruturas_1.FuncaoPadrao(3, objetos.atribuir_propriedade),
        contem_propriedade: new estruturas_1.FuncaoPadrao(2, objetos.contem_propriedade),
        criar_objeto: new estruturas_1.FuncaoPadrao(0, objetos.criar_objeto),
        criar_objeto_via_json: new estruturas_1.FuncaoPadrao(1, objetos.criar_objeto_via_json),
        criar_objeto_via_xml: new estruturas_1.FuncaoPadrao(1, objetos.criar_objeto_via_xml),
        liberar_objeto: new estruturas_1.FuncaoPadrao(1, objetos.liberar_objeto),
        obter_json: new estruturas_1.FuncaoPadrao(1, objetos.obter_json),
        obter_propriedade_tipo_cadeia: new estruturas_1.FuncaoPadrao(2, objetos.obter_propriedade_tipo_cadeia),
        obter_propriedade_tipo_cadeia_em_vetor: new estruturas_1.FuncaoPadrao(3, objetos.obter_propriedade_tipo_cadeia_em_vetor),
        obter_propriedade_tipo_caracter: new estruturas_1.FuncaoPadrao(2, objetos.obter_propriedade_tipo_caracter),
        obter_propriedade_tipo_caracter_em_vetor: new estruturas_1.FuncaoPadrao(3, objetos.obter_propriedade_tipo_caracter_em_vetor),
        obter_propriedade_tipo_inteiro: new estruturas_1.FuncaoPadrao(2, objetos.obter_propriedade_tipo_inteiro),
        obter_propriedade_tipo_inteiro_em_vetor: new estruturas_1.FuncaoPadrao(3, objetos.obter_propriedade_tipo_inteiro_em_vetor),
        obter_propriedade_tipo_logico: new estruturas_1.FuncaoPadrao(2, objetos.obter_propriedade_tipo_logico),
        obter_propriedade_tipo_logico_em_vetor: new estruturas_1.FuncaoPadrao(3, objetos.obter_propriedade_tipo_logico_em_vetor),
        obter_propriedade_tipo_objeto: new estruturas_1.FuncaoPadrao(2, objetos.obter_propriedade_tipo_objeto),
        obter_propriedade_tipo_objeto_em_vetor: new estruturas_1.FuncaoPadrao(3, objetos.obter_propriedade_tipo_objeto_em_vetor),
        obter_propriedade_tipo_real: new estruturas_1.FuncaoPadrao(2, objetos.obter_propriedade_tipo_real),
        obter_propriedade_tipo_real_em_vetor: new estruturas_1.FuncaoPadrao(3, objetos.obter_propriedade_tipo_real_em_vetor),
        obter_tamanho_vetor_propriedade: new estruturas_1.FuncaoPadrao(2, objetos.obter_tamanho_vetor_propriedade),
        tipo_propriedade: new estruturas_1.FuncaoPadrao(2, objetos.tipo_propriedade),
    };
    const objetoObjetos = new estruturas_1.DeleguaModulo('Objetos');
    objetoObjetos.componentes = metodos;
    return objetoObjetos;
}
function carregarBibliotecaTexto() {
    const metodos = {
        numero_caracteres: new estruturas_1.FuncaoPadrao(1, texto.numero_caracteres),
        caixa_alta: new estruturas_1.FuncaoPadrao(1, texto.caixa_alta),
        caixa_baixa: new estruturas_1.FuncaoPadrao(1, texto.caixa_baixa),
        substituir: new estruturas_1.FuncaoPadrao(1, texto.substituir),
        preencher_a_esquerda: new estruturas_1.FuncaoPadrao(1, texto.preencher_a_esquerda),
        obter_caracter: new estruturas_1.FuncaoPadrao(1, texto.obter_caracter),
        posicao_texto: new estruturas_1.FuncaoPadrao(1, texto.posicao_texto),
        extrair_subtexto: new estruturas_1.FuncaoPadrao(1, texto.extrair_subtexto),
    };
    const objetoTexto = new estruturas_1.DeleguaModulo('Texto');
    objetoTexto.componentes = metodos;
    return objetoTexto;
}
function carregarBibliotecaTipos() {
    const metodos = {
        cadeia_e_inteiro: new estruturas_1.FuncaoPadrao(2, tipos.cadeia_e_inteiro),
        cadeia_e_real: new estruturas_1.FuncaoPadrao(1, tipos.cadeia_e_real),
        cadeia_e_logico: new estruturas_1.FuncaoPadrao(1, tipos.cadeia_e_logico),
        cadeia_e_caracter: new estruturas_1.FuncaoPadrao(1, tipos.cadeia_e_caracter),
        cadeia_para_caracter: new estruturas_1.FuncaoPadrao(1, tipos.cadeia_para_caracter),
        cadeia_para_inteiro: new estruturas_1.FuncaoPadrao(2, tipos.cadeia_para_inteiro),
        cadeia_para_real: new estruturas_1.FuncaoPadrao(1, tipos.cadeia_para_real),
        cadeia_para_logico: new estruturas_1.FuncaoPadrao(1, tipos.cadeia_para_logico),
        inteiro_e_caracter: new estruturas_1.FuncaoPadrao(1, tipos.inteiro_e_caracter),
        inteiro_para_cadeia: new estruturas_1.FuncaoPadrao(2, tipos.inteiro_para_cadeia),
        inteiro_para_caracter: new estruturas_1.FuncaoPadrao(1, tipos.inteiro_para_caracter),
        inteiro_para_logico: new estruturas_1.FuncaoPadrao(1, tipos.inteiro_para_logico),
        inteiro_para_real: new estruturas_1.FuncaoPadrao(1, tipos.inteiro_para_real),
        caracter_e_inteiro: new estruturas_1.FuncaoPadrao(1, tipos.caracter_e_inteiro),
        caracter_e_logico: new estruturas_1.FuncaoPadrao(1, tipos.caracter_e_logico),
        caracter_para_cadeia: new estruturas_1.FuncaoPadrao(1, tipos.caracter_para_cadeia),
        caracter_para_inteiro: new estruturas_1.FuncaoPadrao(1, tipos.caracter_para_inteiro),
        caracter_para_logico: new estruturas_1.FuncaoPadrao(1, tipos.caracter_para_logico),
        logico_para_cadeia: new estruturas_1.FuncaoPadrao(1, tipos.logico_para_cadeia),
        logico_para_inteiro: new estruturas_1.FuncaoPadrao(1, tipos.logico_para_inteiro),
        logico_para_caracter: new estruturas_1.FuncaoPadrao(1, tipos.logico_para_caracter),
        real_para_inteiro: new estruturas_1.FuncaoPadrao(1, tipos.real_para_inteiro),
    };
    const objetoTipos = new estruturas_1.DeleguaModulo('Tipos');
    objetoTipos.componentes = metodos;
    return objetoTipos;
}
function carregarBibliotecaUtil() {
    const metodos = {
        obter_diretorio_usuario: new estruturas_1.FuncaoPadrao(0, util.obter_diretorio_usuario),
        numero_elementos: new estruturas_1.FuncaoPadrao(1, util.numero_elementos),
        numero_linhas: new estruturas_1.FuncaoPadrao(1, util.numero_linhas),
        numero_colunas: new estruturas_1.FuncaoPadrao(1, util.numero_colunas),
        sorteia: new estruturas_1.FuncaoPadrao(2, util.sorteia),
        aguarde: new estruturas_1.FuncaoPadrao(1, util.aguarde),
        tempo_decorrido: new estruturas_1.FuncaoPadrao(0, util.tempo_decorrido),
    };
    const objetoUtil = new estruturas_1.DeleguaModulo('Util');
    objetoUtil.componentes = metodos;
    return objetoUtil;
}
/**
 * Avaliação de argumentos para `escreva`. Diferentemente de outros dialetos, aqui não ocorre `trimEnd`, já que `\n`
 * É significativo para Portugol Studio.
 * @param interpretador A instância do interpretador.
 * @param argumentos Os argumentos.
 * @returns {string} O texto formatado.
 */
async function avaliarArgumentosEscreva(interpretador, argumentos) {
    let formatoTexto = '';
    for (const argumento of argumentos) {
        const resultadoAvaliacao = await interpretador.avaliar(argumento);
        let valor = (resultadoAvaliacao === null || resultadoAvaliacao === void 0 ? void 0 : resultadoAvaliacao.hasOwnProperty('valor')) ? resultadoAvaliacao.valor : resultadoAvaliacao;
        formatoTexto += `${interpretador.paraTexto(valor)} `;
    }
    return formatoTexto;
}
async function visitarExpressaoImportarComum(expressao) {
    switch (expressao.caminho.valor) {
        case 'Arquivos':
            return carregarBibliotecaArquivos();
        case 'Calendario':
            return carregarBibliotecaCalendario();
        case 'Internet':
            return carregarBibliotecaInternet();
        case 'Matematica':
            return carregarBibliotecaMatematica();
        case 'Objetos':
            return carregarBibliotecaObjetos();
        case 'Texto':
            return carregarBibliotecaTexto();
        case 'Tipos':
            return carregarBibliotecaTipos();
        case 'Util':
            return carregarBibliotecaUtil();
        default:
            throw new excecoes_1.ErroEmTempoDeExecucao(null, `Biblioteca não implementada: ${expressao.caminho}.`);
    }
}
function desenveloparConstruto(expressao) {
    if (expressao instanceof declaracoes_1.Expressao) {
        return desenveloparConstruto(expressao.expressao);
    }
    return expressao;
}
/**
 * Execução da leitura de valores da entrada configurada no
 * início da aplicação.
 * @param {Leia} expressao Expressão do tipo Leia.
 * @returns Não retorna valor.
 */
async function visitarExpressaoLeiaComum(interpretador, interfaceEntradaSaida, expressao) {
    const mensagem = '> ';
    for (let argumento of expressao.argumentos) {
        const promessaLeitura = () => new Promise((resolucao) => interfaceEntradaSaida.question(mensagem, (resposta) => {
            resolucao(resposta);
        }));
        const valorLido = await promessaLeitura();
        const construtoVariavel = desenveloparConstruto(argumento);
        if (construtoVariavel instanceof construtos_1.AcessoIndiceVariavel) {
            // Aqui faz a mesma coisa que `AtribuicaoPorIndice`.
            // Pode ser interessante modificar o avaliador sintático para emitir este
            // construto e simplificar esta parte.
            const promises = await Promise.all([
                interpretador.avaliar(construtoVariavel.entidadeChamada),
                interpretador.avaliar(construtoVariavel.indice),
            ]);
            const variavel = promises[0];
            const indice = promises[1];
            variavel.valor[indice.valor] = (0, inferenciador_1.converterValor)(variavel.subtipo, valorLido);
        }
        else {
            interpretador.pilhaEscoposExecucao.definirVariavel(construtoVariavel.simbolo.lexema, valorLido);
        }
    }
}
async function visitarExpressaoMatrizComum(interpretador, expressao) {
    if (expressao.valores && expressao.valores.length > 0) {
        return await resolverValoresMatriz(interpretador, expressao.valores);
    }
    // Caso não existam valores de inicialização, cada dimensão é inicializada
    // com valores padrão, de acordo com seu tipo.
    return await inicializarDimensaoMatrizVazia(interpretador, expressao.dimensoes, expressao.tipoDados);
}
async function inicializarDimensaoMatrizVazia(interpretador, dimensoes, tipoDeDados) {
    const valoresResolvidos = [];
    const copiaDimensoes = [...dimensoes];
    const dimensaoAtual = copiaDimensoes.shift();
    const tamanhoDimensao = await interpretador.avaliar(dimensaoAtual);
    const valorTamanhoDimensao = tamanhoDimensao.hasOwnProperty('valor') ? tamanhoDimensao.valor : tamanhoDimensao;
    for (let i = 0; i < valorTamanhoDimensao; i++) {
        if (copiaDimensoes.length > 0) {
            valoresResolvidos.push(await inicializarDimensaoMatrizVazia(interpretador, copiaDimensoes, tipoDeDados));
        }
        else {
            switch (tipoDeDados) {
                case 'inteiro':
                case 'real':
                    valoresResolvidos.push(0);
                    break;
                case 'caracter':
                case 'cadeia':
                    valoresResolvidos.push('');
                    break;
                case 'logico':
                case 'lógico':
                    valoresResolvidos.push(false);
                    break;
            }
        }
    }
    return valoresResolvidos;
}
/**
 * Função recursiva que visita todos os valores de uma matriz, quando os valores são conhecidos.
 * @param interpretador A instância do interpretador.
 * @param valores A matriz de valores das dimensões ainda não resolvidas.
 */
async function resolverValoresMatriz(interpretador, valores) {
    const valoresResolvidos = [];
    for (let i = 0; i < valores.length; i++) {
        if (Array.isArray(valores[i])) {
            valoresResolvidos.push(await resolverValoresMatriz(interpretador, valores[i]));
        }
        else {
            valoresResolvidos.push(await interpretador.avaliar(valores[i]));
        }
    }
    return valoresResolvidos;
}
//# sourceMappingURL=comum.js.map