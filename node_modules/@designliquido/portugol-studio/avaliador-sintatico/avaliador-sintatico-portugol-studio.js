"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AvaliadorSintaticoPortugolStudio = void 0;
const construtos_1 = require("@designliquido/delegua/construtos");
const declaracoes_1 = require("@designliquido/delegua/declaracoes");
const avaliador_sintatico_base_1 = require("@designliquido/delegua/avaliador-sintatico/avaliador-sintatico-base");
const erro_avaliador_sintatico_1 = require("@designliquido/delegua/avaliador-sintatico/erro-avaliador-sintatico");
const construtos_2 = require("../construtos");
const lexico_regular_1 = __importDefault(require("../tipos-de-simbolos/lexico-regular"));
const lexador_1 = require("@designliquido/delegua/lexador");
const tipos_de_dados_1 = __importDefault(require("../tipos-de-dados"));
const avaliador_sintatico_1 = require("@designliquido/delegua/avaliador-sintatico");
const informacao_escopo_1 = require("@designliquido/delegua/avaliador-sintatico/informacao-escopo");
/**
 * O avaliador sintático (_Parser_) é responsável por transformar os símbolos do Lexador em estruturas de alto nível.
 * Essas estruturas de alto nível são as partes que executam lógica de programação de fato.
 * Há dois grupos de estruturas de alto nível: Construtos e Declarações.
 */
class AvaliadorSintaticoPortugolStudio extends avaliador_sintatico_base_1.AvaliadorSintaticoBase {
    constructor() {
        super();
        this.declaracoes = [];
        this.pilhaEscopos = new avaliador_sintatico_1.PilhaEscopos();
    }
    verificarTipoSimboloAtual(tipo) {
        return this.simbolos[this.atual] && this.simbolos[this.atual].tipo === tipo;
    }
    avancarEDevolverAnterior() {
        this.atual += 1;
        return this.simbolos[this.atual - 1];
    }
    estaNoFinal() {
        return ((this.blocos === 1 && this.simbolos[this.atual].tipo === lexico_regular_1.default.CHAVE_DIREITA) ||
            this.atual === this.simbolos.length);
    }
    declaracaoEscreva() {
        throw new Error('Método não implementado.');
    }
    validarEscopoProgramaEAvaliacaoSintatica() {
        // Um programa completamente vazio é inválido.
        if (this.simbolos.length === 0) {
            throw this.erro(new lexador_1.Simbolo('VAZIO', '', '', -1, this.hashArquivo), "Esperada expressão 'programa' para inicializar programa.");
        }
        // Podem haver comentários antes da declaração do programa em si.
        while ([lexico_regular_1.default.COMENTARIO, lexico_regular_1.default.LINHA_COMENTARIO].includes(this.simbolos[this.atual].tipo)) {
            this.declaracoes.push(this.resolverDeclaracaoForaDeBloco());
        }
        this.consumir(lexico_regular_1.default.PROGRAMA, "Esperada expressão 'programa' para inicializar programa.");
        this.consumir(lexico_regular_1.default.CHAVE_ESQUERDA, "Esperada chave esquerda após expressão 'programa' para inicializar programa.");
        this.blocos += 1;
        this.pilhaEscopos.empilhar(new informacao_escopo_1.InformacaoEscopo());
        while (!this.estaNoFinal()) {
            const declaracaoOuVetor = this.resolverDeclaracaoForaDeBloco();
            if (Array.isArray(declaracaoOuVetor)) {
                this.declaracoes = this.declaracoes.concat(declaracaoOuVetor);
            }
            else {
                this.declaracoes.push(declaracaoOuVetor);
            }
        }
        this.consumir(lexico_regular_1.default.CHAVE_DIREITA, 'Esperado chave direita final para término do programa.');
        this.pilhaEscopos.removerUltimo();
        // Podem haver comentários depois da declaração do programa em si.
        while (this.simbolos[this.atual] &&
            [lexico_regular_1.default.COMENTARIO, lexico_regular_1.default.LINHA_COMENTARIO].includes(this.simbolos[this.atual].tipo)) {
            this.declaracoes.push(this.resolverDeclaracaoForaDeBloco());
        }
        const encontrarDeclaracaoInicio = this.declaracoes.filter((d) => d instanceof declaracoes_1.FuncaoDeclaracao && d.simbolo.lexema === 'inicio');
        if (encontrarDeclaracaoInicio.length <= 0) {
            throw this.erro(this.simbolos[0], "Função 'inicio()' para iniciar o programa não foi definida.");
        }
        // A última declaração do programa deve ser uma chamada a inicio()
        const declaracaoInicio = encontrarDeclaracaoInicio[0];
        this.declaracoes.push(new declaracoes_1.Expressao(new construtos_1.Chamada(declaracaoInicio.hashArquivo, declaracaoInicio.funcao, [])));
    }
    comparacaoIgualdade() {
        let expressao = this.comparar();
        while (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.DIFERENTE, lexico_regular_1.default.IGUAL_IGUAL)) {
            const simboloAnterior = this.simbolos[this.atual - 1];
            const direito = this.comparar();
            expressao = new construtos_1.Binario(this.hashArquivo, expressao, simboloAnterior, direito);
        }
        return expressao;
    }
    primario() {
        const simboloAtual = this.simbolos[this.atual];
        switch (simboloAtual.tipo) {
            case lexico_regular_1.default.IDENTIFICADOR:
                const simboloIdentificador = this.avancarEDevolverAnterior();
                // Se o próximo símbolo é um incremento ou um decremento,
                // aqui deve retornar um unário correspondente.
                // Caso contrário, apenas retornar um construto de variável.
                if (this.simbolos[this.atual] &&
                    [lexico_regular_1.default.INCREMENTAR, lexico_regular_1.default.DECREMENTAR].includes(this.simbolos[this.atual].tipo)) {
                    const simboloIncrementoDecremento = this.avancarEDevolverAnterior();
                    return new construtos_1.Unario(this.hashArquivo, simboloIncrementoDecremento, new construtos_1.Variavel(this.hashArquivo, simboloIdentificador), 'DEPOIS');
                }
                return new construtos_1.Variavel(this.hashArquivo, simboloIdentificador);
            case lexico_regular_1.default.PARENTESE_ESQUERDO:
                this.avancarEDevolverAnterior();
                const expressao = this.expressao();
                this.consumir(lexico_regular_1.default.PARENTESE_DIREITO, "Esperado ')' após a expressão.");
                return new construtos_1.Agrupamento(this.hashArquivo, Number(simboloAtual.linha), expressao);
            case lexico_regular_1.default.CADEIA:
            case lexico_regular_1.default.CARACTER:
            case lexico_regular_1.default.INTEIRO:
            case lexico_regular_1.default.REAL:
                const simboloVariavel = this.avancarEDevolverAnterior();
                const dicionarioTiposDelegua = {
                    'CADEIA': 'texto',
                    'CARACTER': 'texto',
                    'INTEIRO': 'inteiro',
                    'REAL': 'número'
                };
                return new construtos_1.Literal(this.hashArquivo, Number(simboloVariavel.linha), simboloVariavel.literal, dicionarioTiposDelegua[simboloAtual.tipo]);
            case lexico_regular_1.default.FALSO:
                this.avancarEDevolverAnterior();
                return new construtos_1.Literal(this.hashArquivo, Number(simboloAtual.linha), false, 'lógico');
            case lexico_regular_1.default.VERDADEIRO:
                this.avancarEDevolverAnterior();
                return new construtos_1.Literal(this.hashArquivo, Number(simboloAtual.linha), true, 'lógico');
            default:
                throw this.erro(simboloAtual, 'Não deveria cair aqui.');
        }
    }
    chamar() {
        let expressao = this.primario();
        while (true) {
            if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.PARENTESE_ESQUERDO)) {
                expressao = this.finalizarChamada(expressao);
            }
            else if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.PONTO)) {
                const nome = this.consumir(lexico_regular_1.default.IDENTIFICADOR, "Esperado nome do método após '.'.");
                expressao = new construtos_1.AcessoMetodoOuPropriedade(this.hashArquivo, expressao, nome);
            }
            else if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.COLCHETE_ESQUERDO)) {
                const indices = [];
                do {
                    indices.push(this.expressao());
                } while (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.VIRGULA));
                const indice = indices[0];
                const simboloFechamento = this.consumir(lexico_regular_1.default.COLCHETE_DIREITO, "Esperado ']' após escrita do indice.");
                expressao = new construtos_1.AcessoIndiceVariavel(this.hashArquivo, expressao, indice, simboloFechamento);
            }
            else {
                break;
            }
        }
        return expressao;
    }
    /**
     * Se símbolo de operação é `+`, `-`, `+=` ou `-=`, monta objeto `Binario` para
     * ser avaliado pelo Interpretador.
     * @returns Um Construto, normalmente um `Binario`, ou `Unario` se houver alguma operação unária para ser avaliada.
     */
    adicaoOuSubtracao() {
        let expressao = this.multiplicar();
        while (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.SUBTRACAO, lexico_regular_1.default.ADICAO, lexico_regular_1.default.MAIS_IGUAL, lexico_regular_1.default.MENOS_IGUAL)) {
            const operador = this.simbolos[this.atual - 1];
            const direito = this.multiplicar();
            expressao = new construtos_1.Binario(this.hashArquivo, expressao, operador, direito);
        }
        return expressao;
    }
    atribuir() {
        const expressao = this.ou();
        if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.IGUAL)) {
            const operadorAtribuicao = this.simbolos[this.atual - 1];
            const valor = this.atribuir();
            if (expressao instanceof construtos_1.Variavel) {
                return new construtos_1.Atribuir(this.hashArquivo, expressao, valor);
            }
            if (expressao instanceof construtos_1.AcessoIndiceVariavel) {
                return new construtos_1.AtribuicaoPorIndice(this.hashArquivo, expressao.linha, expressao.entidadeChamada, expressao.indice, valor);
            }
            this.erro(operadorAtribuicao, 'Tarefa de atribuição inválida');
        }
        return expressao;
    }
    declaracaoEscrevaMesmaLinha() {
        const simboloAtual = this.avancarEDevolverAnterior();
        this.consumir(lexico_regular_1.default.PARENTESE_ESQUERDO, "Esperado '(' antes dos valores em escreva.");
        const argumentos = [];
        do {
            argumentos.push(this.expressao());
        } while (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.VIRGULA));
        this.consumir(lexico_regular_1.default.PARENTESE_DIREITO, "Esperado ')' após os valores em escreva.");
        return new declaracoes_1.EscrevaMesmaLinha(Number(simboloAtual.linha), simboloAtual.hashArquivo, argumentos);
    }
    /**
     * Declaração para inclusão de uma biblioteca.
     * Exemplo: `inclua biblioteca Matematica --> mat` seria o mesmo que
     * `const mat = importar('Matematica')` em Delégua, ou
     * `inclua biblioteca Matematica` (sem o nome da variável) seria o
     * mesmo que `const Matematica = importar('Matematica')`
     * @returns Uma declaração do tipo `Importar`.
     */
    declaracaoInclua() {
        this.avancarEDevolverAnterior();
        this.consumir(lexico_regular_1.default.BIBLIOTECA, 'Esperado palavra reservada "biblioteca" após "inclua".');
        const nomeBiblioteca = this.consumir(lexico_regular_1.default.IDENTIFICADOR, 'Esperado identificador com nome de biblioteca após palavra reservada "biblioteca"');
        let constanteBiblioteca = nomeBiblioteca;
        if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.SETA)) {
            constanteBiblioteca = this.consumir(lexico_regular_1.default.IDENTIFICADOR, 'Esperado identificador com nome de constante de biblioteca após seta de atribuição em declaração "inclua".');
        }
        return new declaracoes_1.Const(constanteBiblioteca, new declaracoes_1.Importar(new construtos_1.Literal(this.hashArquivo, nomeBiblioteca.linha, nomeBiblioteca.lexema)));
    }
    blocoEscopo() {
        this.consumir(lexico_regular_1.default.CHAVE_ESQUERDA, "Esperado '}' antes do bloco.");
        this.blocos += 1;
        this.pilhaEscopos.empilhar(new informacao_escopo_1.InformacaoEscopo());
        let declaracoes = [];
        while (!this.verificarTipoSimboloAtual(lexico_regular_1.default.CHAVE_DIREITA) && !this.estaNoFinal()) {
            const declaracaoOuVetor = this.resolverDeclaracaoForaDeBloco();
            if (Array.isArray(declaracaoOuVetor)) {
                declaracoes = declaracoes.concat(declaracaoOuVetor);
            }
            else {
                declaracoes.push(declaracaoOuVetor);
            }
        }
        this.consumir(lexico_regular_1.default.CHAVE_DIREITA, "Esperado '}' após o bloco.");
        this.blocos -= 1;
        this.pilhaEscopos.removerUltimo();
        return declaracoes;
    }
    declaracaoSe() {
        this.avancarEDevolverAnterior();
        this.consumir(lexico_regular_1.default.PARENTESE_ESQUERDO, "Esperado '(' após 'se'.");
        const condicao = this.expressao();
        this.consumir(lexico_regular_1.default.PARENTESE_DIREITO, "Esperado ')' após condição do se.");
        const caminhoEntao = this.resolverDeclaracaoForaDeBloco();
        let caminhoSenao = null;
        if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.SENAO)) {
            caminhoSenao = this.resolverDeclaracaoForaDeBloco();
        }
        return new declaracoes_1.Se(condicao, caminhoEntao, [], caminhoSenao);
    }
    declaracaoEnquanto() {
        try {
            this.avancarEDevolverAnterior();
            this.blocos += 1;
            this.consumir(lexico_regular_1.default.PARENTESE_ESQUERDO, "Esperado '(' após 'enquanto'.");
            const condicao = this.expressao();
            this.consumir(lexico_regular_1.default.PARENTESE_DIREITO, "Esperado ')' após condição.");
            const corpo = this.resolverDeclaracaoForaDeBloco();
            return new declaracoes_1.Enquanto(condicao, corpo);
        }
        finally {
            this.blocos -= 1;
        }
    }
    declaracaoEscolha() {
        try {
            this.avancarEDevolverAnterior();
            const condicao = this.expressao();
            this.consumir(lexico_regular_1.default.CHAVE_ESQUERDA, "Esperado '{' antes do escopo do 'escolha'.");
            this.blocos += 1;
            const caminhos = [];
            let caminhoPadrao = null;
            while (!this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.CHAVE_DIREITA) && !this.estaNoFinal()) {
                if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.CASO)) {
                    if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.CONTRARIO)) {
                        if (caminhoPadrao !== null) {
                            const excecao = new erro_avaliador_sintatico_1.ErroAvaliadorSintatico(this.simbolos[this.atual], "Você só pode ter um 'contrario' em cada declaração de 'escolha'.");
                            this.erros.push(excecao);
                            throw excecao;
                        }
                        this.consumir(lexico_regular_1.default.DOIS_PONTOS, "Esperado ':' após declaração do 'contrario'.");
                        const declaracoes = [];
                        do {
                            declaracoes.push(this.resolverDeclaracaoForaDeBloco());
                            this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.PARE);
                        } while (!this.verificarTipoSimboloAtual(lexico_regular_1.default.CASO) &&
                            !this.verificarTipoSimboloAtual(lexico_regular_1.default.CONTRARIO) &&
                            !this.verificarTipoSimboloAtual(lexico_regular_1.default.CHAVE_DIREITA));
                        caminhoPadrao = {
                            declaracoes,
                        };
                        continue;
                    }
                    const caminhoCondicoes = [this.expressao()];
                    this.consumir(lexico_regular_1.default.DOIS_PONTOS, "Esperado ':' após o 'caso'.");
                    while (this.verificarTipoSimboloAtual(lexico_regular_1.default.CASO)) {
                        this.consumir(lexico_regular_1.default.CASO, null);
                        caminhoCondicoes.push(this.expressao());
                        this.consumir(lexico_regular_1.default.DOIS_PONTOS, "Esperado ':' após declaração do 'caso'.");
                    }
                    let declaracoes = [];
                    do {
                        const retornoDeclaracao = this.resolverDeclaracaoForaDeBloco();
                        if (Array.isArray(retornoDeclaracao)) {
                            declaracoes = declaracoes.concat(retornoDeclaracao);
                        }
                        else {
                            declaracoes.push(retornoDeclaracao);
                        }
                        this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.PARE);
                    } while (!this.verificarTipoSimboloAtual(lexico_regular_1.default.CASO) &&
                        !this.verificarTipoSimboloAtual(lexico_regular_1.default.CONTRARIO) &&
                        !this.verificarTipoSimboloAtual(lexico_regular_1.default.CHAVE_DIREITA));
                    caminhos.push({
                        condicoes: caminhoCondicoes,
                        declaracoes,
                    });
                }
            }
            return new declaracoes_1.Escolha(condicao, caminhos, caminhoPadrao);
        }
        finally {
            this.blocos -= 1;
        }
    }
    /**
     * No Portugol Studio, a palavra reservada é `faca`, sem acento.
     */
    declaracaoFazer() {
        const simboloFaca = this.avancarEDevolverAnterior();
        try {
            this.blocos += 1;
            const caminhoFazer = this.resolverDeclaracaoForaDeBloco();
            this.consumir(lexico_regular_1.default.ENQUANTO, "Esperado declaração do 'enquanto' após o escopo do 'fazer'.");
            this.consumir(lexico_regular_1.default.PARENTESE_ESQUERDO, "Esperado '(' após declaração 'enquanto'.");
            const condicaoEnquanto = this.expressao();
            this.consumir(lexico_regular_1.default.PARENTESE_DIREITO, "Esperado ')' após declaração do 'enquanto'.");
            return new declaracoes_1.Fazer(simboloFaca.hashArquivo, Number(simboloFaca.linha), caminhoFazer, condicaoEnquanto);
        }
        finally {
            this.blocos -= 1;
        }
    }
    simboloAtual() {
        return this.simbolos[this.atual];
    }
    verificarDefinicaoTipo(lexema) {
        const tipos = [...Object.values(tipos_de_dados_1.default)];
        const contemTipo = tipos.find((tipo) => tipo === lexema);
        if (contemTipo && this.verificarTipoProximoSimbolo(lexico_regular_1.default.COLCHETE_ESQUERDO)) {
            const tiposVetores = ['inteiro[]', 'numero[]', 'número[]', 'real[]', 'texto[]'];
            this.avancarEDevolverAnterior();
            if (!this.verificarTipoProximoSimbolo(lexico_regular_1.default.COLCHETE_DIREITO)) {
                throw this.erro(this.simbolos[this.atual], "Esperado símbolo de fechamento do vetor ']'.");
            }
            const contemTipoVetor = tiposVetores.find((tipo) => tipo === `${lexema}[]`);
            this.avancarEDevolverAnterior();
            return contemTipoVetor;
        }
        return contemTipo;
    }
    logicaComumParametros() {
        const parametros = [];
        do {
            if (parametros.length >= 255) {
                this.erro(this.simbolos[this.atual], 'Não pode haver mais de 255 parâmetros');
            }
            const parametro = {
                abrangencia: 'padrao',
            };
            if (!this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.CADEIA, lexico_regular_1.default.REAL, lexico_regular_1.default.IDENTIFICADOR, lexico_regular_1.default.INTEIRO)) {
                throw this.erro(this.simbolos[this.atual], 'Esperado tipo de parâmetro válido para declaração de função.');
            }
            const lexema = this.simbolos[this.atual - 1].lexema;
            let tipoDadoParametro = this.verificarDefinicaoTipo(lexema);
            parametro.tipoDado = tipoDadoParametro;
            parametro.nome = this.consumir(lexico_regular_1.default.IDENTIFICADOR, 'Esperado nome do parâmetro.');
            // Em Portugol Studio, um parâmetro múltiplo é terminado por abre e fecha colchetes.
            if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.COLCHETE_ESQUERDO)) {
                this.consumir(lexico_regular_1.default.COLCHETE_DIREITO, 'Esperado colchete direito após colchete esquerdo ao definir parâmetro múltiplo em função.');
                parametro.abrangencia = 'multiplo';
            }
            if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.IGUAL)) {
                parametro.valorPadrao = this.primario();
            }
            parametros.push(parametro);
            if (parametro.abrangencia === 'multiplo')
                break;
        } while (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.VIRGULA));
        return parametros;
    }
    corpoDaFuncao(tipo) {
        // O parêntese esquerdo é considerado o símbolo inicial para
        // fins de pragma.
        const parenteseEsquerdo = this.consumir(lexico_regular_1.default.PARENTESE_ESQUERDO, `Esperado '(' após o nome ${tipo}.`);
        let parametros = [];
        if (!this.verificarTipoSimboloAtual(lexico_regular_1.default.PARENTESE_DIREITO)) {
            parametros = this.logicaComumParametros();
        }
        this.consumir(lexico_regular_1.default.PARENTESE_DIREITO, "Esperado ')' após parâmetros.");
        const corpo = this.blocoEscopo();
        return new construtos_1.FuncaoConstruto(this.hashArquivo, Number(parenteseEsquerdo.linha), parametros, corpo);
    }
    /**
     * Declaração de apenas uma variável.
     * Neste caso, o símbolo que determina o tipo da variável já foi consumido,
     * e o retorno conta com apenas uma variável retornada.
     */
    declaracaoDeVariavel() {
        switch (this.simboloAnterior().tipo) {
            case lexico_regular_1.default.INTEIRO:
                const identificador = this.consumir(lexico_regular_1.default.IDENTIFICADOR, `Esperado identificador após palavra reservada '${tipos_de_dados_1.default.INTEIRO}'.`);
                this.consumir(lexico_regular_1.default.IGUAL, 'Esperado símbolo igual para inicialização de variável.');
                let inicializador;
                switch (this.simbolos[this.atual].tipo) {
                    case lexico_regular_1.default.INTEIRO:
                        const literalInicializacao = this.avancarEDevolverAnterior();
                        const valorInicializacao = Number(literalInicializacao.literal);
                        inicializador = new construtos_1.Literal(this.hashArquivo, Number(literalInicializacao.linha), valorInicializacao, 'inteiro');
                        break;
                    case lexico_regular_1.default.IDENTIFICADOR:
                        // TODO: Montar escopo de variáveis conhecidas e verificar o tipo e existência até aqui.
                        const variavelInicializacao = this.avancarEDevolverAnterior();
                        inicializador = new construtos_1.Variavel(this.hashArquivo, variavelInicializacao);
                        break;
                    default:
                        throw this.erro(this.simbolos[this.atual], `Esperado literal ou identificador inteiro para atribuição de variável. Tipo atual: ${this.simbolos[this.atual].lexema}.`);
                }
                return new declaracoes_1.Var(identificador, inicializador, 'inteiro');
        }
    }
    declaracaoCadeiasCaracteres() {
        const simboloCadeia = this.consumir(lexico_regular_1.default.CADEIA, 'Esse erro nunca deve acontecer (declaracaoCadeiasCaracteres).');
        const inicializacoes = [];
        do {
            const identificador = this.consumir(lexico_regular_1.default.IDENTIFICADOR, "Esperado identificador após palavra reservada 'cadeia'.");
            const dimensoes = this.logicaComumDimensoesMatrizes();
            if (dimensoes.length > 0) {
                inicializacoes.push(this.declaracaoVetorOuMatriz(simboloCadeia, identificador, dimensoes, tipos_de_dados_1.default.CADEIA));
            }
            else {
                inicializacoes.push(this.declaracaoVariavelSemDimensoes(simboloCadeia, identificador, tipos_de_dados_1.default.CADEIA));
            }
        } while (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.VIRGULA));
        return inicializacoes;
    }
    declaracaoCaracteres() {
        const simboloCaracter = this.consumir(lexico_regular_1.default.CARACTER, '');
        const inicializacoes = [];
        do {
            const identificador = this.consumir(lexico_regular_1.default.IDENTIFICADOR, `Esperado identificador após palavra reservada '${tipos_de_dados_1.default.CARACTER}'.`);
            const dimensoes = this.logicaComumDimensoesMatrizes();
            if (dimensoes.length > 0) {
                inicializacoes.push(this.declaracaoVetorOuMatriz(simboloCaracter, identificador, dimensoes, tipos_de_dados_1.default.CARACTER));
            }
            else {
                inicializacoes.push(this.declaracaoVariavelSemDimensoes(simboloCaracter, identificador, tipos_de_dados_1.default.CARACTER));
            }
        } while (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.VIRGULA));
        return inicializacoes;
    }
    declaracaoComentarioMultilinha() {
        const conteudos = [];
        let simboloComentario;
        let simboloAtual;
        do {
            simboloComentario = this.avancarEDevolverAnterior();
            conteudos.push(simboloComentario.literal);
            simboloAtual = this.simbolos[this.atual];
        } while (simboloAtual && simboloAtual.tipo === lexico_regular_1.default.LINHA_COMENTARIO);
        return new construtos_1.Comentario(simboloComentario.hashArquivo, simboloComentario.linha, conteudos, true);
    }
    declaracaoComentarioUmaLinha() {
        const simboloComentario = this.avancarEDevolverAnterior();
        return new construtos_1.Comentario(simboloComentario.hashArquivo, simboloComentario.linha, simboloComentario.literal, false);
    }
    declaracaoExpressao(simboloAnterior) {
        const expressao = this.expressao();
        // Ponto-e-vírgula é opcional aqui.
        this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.PONTO_E_VIRGULA);
        if (!expressao) {
            throw new erro_avaliador_sintatico_1.ErroAvaliadorSintatico(simboloAnterior, 'Esperado expressão.');
        }
        return new declaracoes_1.Expressao(expressao);
    }
    /**
     * Método recursivo que lê os valores de inicialização de uma matriz de N dimensões.
     * @param {Construto[]} dimensoes O número de dimensões faltantes.
     * Cada passo recursivo usa o primeiro valor e chama a função passando esse vetor, mas sem
     * o primeiro valor.
     */
    lerValoresAtribuicaoMatriz(dimensoes) {
        this.consumir(lexico_regular_1.default.CHAVE_ESQUERDA, 'Esperado chave esquerda após sinal de igual em lado direito da atribuição de vetor.');
        // Neste caso, chave esquerda não é bloco.
        const valores = [];
        do {
            if (dimensoes.length === 1) {
                valores.push(this.primario());
            }
            else {
                const valoresProximaDimensao = this.lerValoresAtribuicaoMatriz(dimensoes.slice(1));
                valores.push(valoresProximaDimensao);
            }
        } while (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.VIRGULA));
        this.consumir(lexico_regular_1.default.CHAVE_DIREITA, 'Esperado chave direita após valores de vetor em lado direito da atribuição de vetor.');
        // TODO: Recolocar.
        /* if (dimensoes !== valores.length) {
            throw this.erro(
                simboloInteiro,
                `Esperado ${dimensoes} números, mas foram fornecidos ${valores.length} valores do lado direito da atribuição.`
            );
        } */
        return valores;
    }
    declaracaoVetorOuMatriz(simboloTipo, identificador, dimensoes, tipoDados = 'inteiro') {
        let valorInicializacao = new construtos_2.Matriz(this.hashArquivo, Number(simboloTipo.linha), dimensoes, tipoDados, null);
        if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.IGUAL)) {
            valorInicializacao.valores = this.lerValoresAtribuicaoMatriz(dimensoes);
        }
        const tipoDadosFinal = `${tipoDados}[]`;
        this.pilhaEscopos.definirTipoVariavel(identificador.lexema, tipoDadosFinal);
        return new declaracoes_1.Var(identificador, valorInicializacao, tipoDadosFinal);
    }
    declaracaoVariavelSemDimensoes(simboloInteiro, identificador, tipoDados = 'inteiro') {
        // Inicializações de variáveis podem ter valores definidos.
        let valorInicializacao = new construtos_1.Literal(this.hashArquivo, Number(simboloInteiro.linha), 0);
        if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.IGUAL)) {
            valorInicializacao = this.expressao();
        }
        this.pilhaEscopos.definirTipoVariavel(identificador.lexema, tipoDados);
        return new declaracoes_1.Var(identificador, valorInicializacao, tipoDados);
    }
    logicaComumDimensoesMatrizes() {
        let dimensoes = [];
        while (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.COLCHETE_ESQUERDO)) {
            // Portugol Studio permite declarar vetores sem posições definidas.
            // Quando isso acontece, definimos a quantidade de posições de uma dimensão como -1.
            if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.COLCHETE_DIREITO)) {
                const simboloColcheteDireito = this.simbolos[this.atual - 1];
                dimensoes.push(new construtos_1.Literal(this.hashArquivo, simboloColcheteDireito.linha, -1));
            }
            else {
                let construtoNumeroPosicoes = this.primario();
                dimensoes.push(construtoNumeroPosicoes);
                this.consumir(lexico_regular_1.default.COLCHETE_DIREITO, 'Esperado fechamento de identificação de número de posições de uma dimensão de vetor ou matriz.');
            }
        }
        return dimensoes;
    }
    declaracaoInteiros() {
        const simboloInteiro = this.consumir(lexico_regular_1.default.INTEIRO, '');
        const inicializacoes = [];
        do {
            const identificador = this.consumir(lexico_regular_1.default.IDENTIFICADOR, "Esperado identificador após palavra reservada 'inteiro'.");
            const dimensoes = this.logicaComumDimensoesMatrizes();
            if (dimensoes.length > 0) {
                inicializacoes.push(this.declaracaoVetorOuMatriz(simboloInteiro, identificador, dimensoes));
            }
            else {
                inicializacoes.push(this.declaracaoVariavelSemDimensoes(simboloInteiro, identificador));
            }
        } while (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.VIRGULA));
        return inicializacoes;
    }
    /**
     * Análise de uma declaração `leia()`. No VisuAlg, `leia()` aceita 1..N argumentos.
     * @returns Uma declaração `Leia`.
     */
    declaracaoLeia() {
        const simboloLeia = this.avancarEDevolverAnterior();
        this.consumir(lexico_regular_1.default.PARENTESE_ESQUERDO, "Esperado '(' antes do argumento em instrução `leia`.");
        const argumentos = [];
        do {
            argumentos.push(this.resolverDeclaracaoForaDeBloco());
        } while (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.VIRGULA));
        this.consumir(lexico_regular_1.default.PARENTESE_DIREITO, "Esperado ')' após o argumento em instrução `leia`.");
        return new declaracoes_1.Leia(simboloLeia, argumentos);
    }
    declaracaoLogicos() {
        const simboloLogico = this.consumir(lexico_regular_1.default.LOGICO, '');
        const inicializacoes = [];
        do {
            const identificador = this.consumir(lexico_regular_1.default.IDENTIFICADOR, "Esperado identificador após palavra reservada 'logico'.");
            // Inicializações de variáveis podem ter valores definidos.
            let valorInicializacao = false;
            if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.IGUAL)) {
                if (![lexico_regular_1.default.VERDADEIRO, lexico_regular_1.default.FALSO].includes(this.simbolos[this.atual].tipo)) {
                    throw this.erro(this.simbolos[this.atual], 'Esperado literal verdadeiro ou falso após símbolo de igual em declaração de variável.');
                }
                const literalInicializacao = this.avancarEDevolverAnterior();
                valorInicializacao = literalInicializacao.lexema.toLowerCase() === 'verdadeiro' ? true : false;
            }
            inicializacoes.push(new declaracoes_1.Var(identificador, new construtos_1.Literal(this.hashArquivo, Number(simboloLogico.linha), valorInicializacao), 'lógico'));
        } while (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.VIRGULA));
        return inicializacoes;
    }
    declaracaoRetorne() {
        this.avancarEDevolverAnterior();
        const simboloChave = this.simbolos[this.atual];
        let valor = null;
        if ([
            lexico_regular_1.default.CADEIA,
            lexico_regular_1.default.CARACTER,
            lexico_regular_1.default.FALSO,
            lexico_regular_1.default.IDENTIFICADOR,
            lexico_regular_1.default.INTEIRO,
            lexico_regular_1.default.NEGACAO,
            lexico_regular_1.default.REAL,
            lexico_regular_1.default.VERDADEIRO,
        ].includes(this.simbolos[this.atual].tipo)) {
            valor = this.expressao();
        }
        return new declaracoes_1.Retorna(simboloChave, valor);
    }
    declaracaoPara() {
        try {
            const simboloPara = this.avancarEDevolverAnterior();
            this.blocos += 1;
            this.consumir(lexico_regular_1.default.PARENTESE_ESQUERDO, "Esperado '(' após 'para'.");
            let inicializador;
            if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.PONTO_E_VIRGULA)) {
                inicializador = null;
            }
            else if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.INTEIRO)) {
                inicializador = this.declaracaoDeVariavel();
            }
            else {
                inicializador = this.declaracaoExpressao();
            }
            let condicao = null;
            if (!this.verificarTipoSimboloAtual(lexico_regular_1.default.PONTO_E_VIRGULA)) {
                condicao = this.expressao();
            }
            let incrementar = null;
            if (!this.verificarTipoSimboloAtual(lexico_regular_1.default.PARENTESE_DIREITO)) {
                incrementar = this.expressao();
                this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.INCREMENTAR, lexico_regular_1.default.DECREMENTAR);
            }
            this.consumir(lexico_regular_1.default.PARENTESE_DIREITO, "Esperado ')' após cláusulas");
            const corpo = this.resolverDeclaracaoForaDeBloco();
            return new declaracoes_1.Para(this.hashArquivo, Number(simboloPara.linha), inicializador, condicao, incrementar, corpo);
        }
        finally {
            this.blocos -= 1;
        }
    }
    declaracaoReais() {
        const simboloReal = this.consumir(lexico_regular_1.default.REAL, '');
        const inicializacoes = [];
        do {
            const identificador = this.consumir(lexico_regular_1.default.IDENTIFICADOR, `Esperado identificador após palavra reservada '${tipos_de_dados_1.default.REAL}'.`);
            const dimensoes = this.logicaComumDimensoesMatrizes();
            if (dimensoes.length > 0) {
                inicializacoes.push(this.declaracaoVetorOuMatriz(simboloReal, identificador, dimensoes, tipos_de_dados_1.default.REAL));
            }
            else {
                inicializacoes.push(this.declaracaoVariavelSemDimensoes(simboloReal, identificador, tipos_de_dados_1.default.REAL));
            }
        } while (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.VIRGULA));
        return inicializacoes;
    }
    expressao() {
        return this.atribuir();
    }
    expressaoLimpa() {
        const simboloLimpa = this.avancarEDevolverAnterior();
        this.consumir(lexico_regular_1.default.PARENTESE_ESQUERDO, 'Esperado parêntese esquerdo após palavra reservada "limpa".');
        this.consumir(lexico_regular_1.default.PARENTESE_DIREITO, 'Esperado parêntese direito após parêntese esquerdo que acompanha palavra reservada "limpa".');
        return new construtos_2.Limpa(simboloLimpa.hashArquivo, simboloLimpa.linha);
    }
    funcao(tipo) {
        const simboloFuncao = this.avancarEDevolverAnterior();
        // No Portugol Studio, se temos um símbolo de tipo após `função`,
        // teremos um retorno no corpo da função.
        if ([
            lexico_regular_1.default.REAL,
            lexico_regular_1.default.INTEIRO,
            lexico_regular_1.default.CADEIA,
            lexico_regular_1.default.CARACTER,
            lexico_regular_1.default.LOGICO,
        ].includes(this.simbolos[this.atual].tipo)) {
            // Por enquanto apenas consumimos o símbolo sem ações adicionais.
            this.avancarEDevolverAnterior();
        }
        this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.VAZIO);
        const nomeFuncao = this.consumir(lexico_regular_1.default.IDENTIFICADOR, `Esperado nome ${tipo}.`);
        return new declaracoes_1.FuncaoDeclaracao(nomeFuncao, this.corpoDaFuncao(tipo));
    }
    declaracaoDeConstantes() {
        let identificador;
        let tipo;
        if ([
            lexico_regular_1.default.REAL,
            lexico_regular_1.default.INTEIRO,
            lexico_regular_1.default.CADEIA,
            lexico_regular_1.default.CARACTER,
            lexico_regular_1.default.LOGICO,
        ].includes(this.simbolos[this.atual].tipo)) {
            tipo = this.avancarEDevolverAnterior();
        }
        identificador = this.consumir(lexico_regular_1.default.IDENTIFICADOR, 'Esperado nome da constante.');
        this.consumir(lexico_regular_1.default.IGUAL, "Esperado '=' após identificador em instrução 'constante'.");
        const inicializador = this.expressao();
        this.pilhaEscopos.definirTipoVariavel(identificador.lexema, tipo.lexema);
        return new declaracoes_1.Const(identificador, inicializador, tipo.lexema);
    }
    resolverDeclaracaoForaDeBloco() {
        const simboloAtual = this.simbolos[this.atual];
        switch (simboloAtual.tipo) {
            case lexico_regular_1.default.CADEIA:
                return this.declaracaoCadeiasCaracteres();
            case lexico_regular_1.default.CARACTER:
                return this.declaracaoCaracteres();
            case lexico_regular_1.default.CHAVE_ESQUERDA:
                const simboloInicioBloco = this.simbolos[this.atual];
                return new declaracoes_1.Bloco(simboloInicioBloco.hashArquivo, Number(simboloInicioBloco.linha), this.blocoEscopo());
            case lexico_regular_1.default.COMENTARIO:
                return this.declaracaoComentarioUmaLinha();
            case lexico_regular_1.default.CONSTANTE:
                this.avancarEDevolverAnterior();
                return this.declaracaoDeConstantes();
            case lexico_regular_1.default.ENQUANTO:
                return this.declaracaoEnquanto();
            case lexico_regular_1.default.ESCOLHA:
                return this.declaracaoEscolha();
            case lexico_regular_1.default.ESCREVA:
                return this.declaracaoEscrevaMesmaLinha();
            case lexico_regular_1.default.FACA:
                return this.declaracaoFazer();
            case lexico_regular_1.default.FUNCAO:
                return this.funcao('funcao');
            case lexico_regular_1.default.INCLUA:
                return this.declaracaoInclua();
            case lexico_regular_1.default.INTEIRO:
                return this.declaracaoInteiros();
            case lexico_regular_1.default.LEIA:
                return this.declaracaoLeia();
            case lexico_regular_1.default.LIMPA:
                return this.expressaoLimpa();
            case lexico_regular_1.default.LINHA_COMENTARIO:
                return this.declaracaoComentarioMultilinha();
            case lexico_regular_1.default.LOGICO:
                return this.declaracaoLogicos();
            case lexico_regular_1.default.PARA:
                return this.declaracaoPara();
            case lexico_regular_1.default.PROGRAMA:
            case lexico_regular_1.default.CHAVE_DIREITA:
                this.avancarEDevolverAnterior();
                return null;
            case lexico_regular_1.default.REAL:
                return this.declaracaoReais();
            case lexico_regular_1.default.RETORNE:
                return this.declaracaoRetorne();
            case lexico_regular_1.default.SE:
                return this.declaracaoSe();
            default:
                return this.declaracaoExpressao(simboloAtual);
        }
    }
    analisar(retornoLexador, hashArquivo) {
        this.erros = [];
        this.atual = 0;
        this.blocos = 0;
        this.hashArquivo = hashArquivo || 0;
        this.simbolos = (retornoLexador === null || retornoLexador === void 0 ? void 0 : retornoLexador.simbolos) || [];
        this.declaracoes = [];
        this.validarEscopoProgramaEAvaliacaoSintatica();
        return {
            declaracoes: this.declaracoes.filter((d) => d),
            erros: this.erros,
        };
    }
}
exports.AvaliadorSintaticoPortugolStudio = AvaliadorSintaticoPortugolStudio;
//# sourceMappingURL=avaliador-sintatico-portugol-studio.js.map