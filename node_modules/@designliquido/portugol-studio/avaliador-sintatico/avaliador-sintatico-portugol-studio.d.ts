import { Comentario, Construto, FuncaoConstruto } from '@designliquido/delegua/construtos';
import { Escreva, Declaracao, Se, Enquanto, Para, Escolha, Fazer, FuncaoDeclaracao, Expressao, Leia, Var, EscrevaMesmaLinha, Retorna, Const } from '@designliquido/delegua/declaracoes';
import { RetornoLexador, RetornoAvaliadorSintatico } from '@designliquido/delegua/interfaces/retornos';
import { AvaliadorSintaticoBase } from '@designliquido/delegua/avaliador-sintatico/avaliador-sintatico-base';
import { ParametroInterface, SimboloInterface } from '@designliquido/delegua/interfaces';
import { TipoDadosElementar } from '@designliquido/delegua/tipo-dados-elementar';
import { Limpa } from '../construtos';
/**
 * O avaliador sintático (_Parser_) é responsável por transformar os símbolos do Lexador em estruturas de alto nível.
 * Essas estruturas de alto nível são as partes que executam lógica de programação de fato.
 * Há dois grupos de estruturas de alto nível: Construtos e Declarações.
 */
export declare class AvaliadorSintaticoPortugolStudio extends AvaliadorSintaticoBase {
    private declaracoes;
    private pilhaEscopos;
    constructor();
    verificarTipoSimboloAtual(tipo: string): boolean;
    avancarEDevolverAnterior(): SimboloInterface<string>;
    estaNoFinal(): boolean;
    declaracaoEscreva(): Escreva;
    private validarEscopoProgramaEAvaliacaoSintatica;
    comparacaoIgualdade(): Construto;
    primario(): Construto;
    chamar(): Construto;
    /**
     * Se símbolo de operação é `+`, `-`, `+=` ou `-=`, monta objeto `Binario` para
     * ser avaliado pelo Interpretador.
     * @returns Um Construto, normalmente um `Binario`, ou `Unario` se houver alguma operação unária para ser avaliada.
     */
    adicaoOuSubtracao(): Construto;
    atribuir(): Construto;
    declaracaoEscrevaMesmaLinha(): EscrevaMesmaLinha;
    /**
     * Declaração para inclusão de uma biblioteca.
     * Exemplo: `inclua biblioteca Matematica --> mat` seria o mesmo que
     * `const mat = importar('Matematica')` em Delégua, ou
     * `inclua biblioteca Matematica` (sem o nome da variável) seria o
     * mesmo que `const Matematica = importar('Matematica')`
     * @returns Uma declaração do tipo `Importar`.
     */
    declaracaoInclua(): Const;
    blocoEscopo(): Declaracao[];
    declaracaoSe(): Se;
    declaracaoEnquanto(): Enquanto;
    declaracaoEscolha(): Escolha;
    /**
     * No Portugol Studio, a palavra reservada é `faca`, sem acento.
     */
    declaracaoFazer(): Fazer;
    simboloAtual(): SimboloInterface;
    verificarDefinicaoTipo(lexema: string): TipoDadosElementar;
    protected logicaComumParametros(): ParametroInterface[];
    corpoDaFuncao(tipo: string): FuncaoConstruto;
    /**
     * Declaração de apenas uma variável.
     * Neste caso, o símbolo que determina o tipo da variável já foi consumido,
     * e o retorno conta com apenas uma variável retornada.
     */
    declaracaoDeVariavel(): Var;
    declaracaoCadeiasCaracteres(): Var[];
    declaracaoCaracteres(): Var[];
    declaracaoComentarioMultilinha(): Comentario;
    declaracaoComentarioUmaLinha(): Comentario;
    declaracaoExpressao(simboloAnterior?: SimboloInterface): Expressao;
    /**
     * Método recursivo que lê os valores de inicialização de uma matriz de N dimensões.
     * @param {Construto[]} dimensoes O número de dimensões faltantes.
     * Cada passo recursivo usa o primeiro valor e chama a função passando esse vetor, mas sem
     * o primeiro valor.
     */
    protected lerValoresAtribuicaoMatriz(dimensoes: Construto[]): any[];
    protected declaracaoVetorOuMatriz(simboloTipo: SimboloInterface, identificador: SimboloInterface, dimensoes: Construto[], tipoDados?: string): Var;
    protected declaracaoVariavelSemDimensoes(simboloInteiro: SimboloInterface, identificador: SimboloInterface, tipoDados?: string): Var;
    protected logicaComumDimensoesMatrizes(): Construto[];
    declaracaoInteiros(): Var[];
    /**
     * Análise de uma declaração `leia()`. No VisuAlg, `leia()` aceita 1..N argumentos.
     * @returns Uma declaração `Leia`.
     */
    declaracaoLeia(): Leia;
    declaracaoLogicos(): Var[];
    declaracaoRetorne(): Retorna;
    declaracaoPara(): Para;
    declaracaoReais(): Var[];
    expressao(): Construto;
    expressaoLimpa(): Limpa;
    funcao(tipo: string): FuncaoDeclaracao;
    declaracaoDeConstantes(): any;
    resolverDeclaracaoForaDeBloco(): Declaracao | Declaracao[] | Construto | Construto[] | any;
    analisar(retornoLexador: RetornoLexador<SimboloInterface>, hashArquivo: number): RetornoAvaliadorSintatico<Declaracao>;
}
//# sourceMappingURL=avaliador-sintatico-portugol-studio.d.ts.map