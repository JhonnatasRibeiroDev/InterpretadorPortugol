"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TIPO_VETOR = exports.TIPO_OBJETO = exports.TIPO_LOGICO = exports.TIPO_REAL = exports.TIPO_CARACTER = exports.TIPO_CADEIA = exports.TIPO_INTEIRO = void 0;
exports.criar_objeto_via_json = criar_objeto_via_json;
exports.criar_objeto_via_xml = criar_objeto_via_xml;
exports.criar_objeto = criar_objeto;
exports.atribuir_propriedade = atribuir_propriedade;
exports.obter_propriedade_tipo_inteiro = obter_propriedade_tipo_inteiro;
exports.obter_propriedade_tipo_real = obter_propriedade_tipo_real;
exports.obter_propriedade_tipo_logico = obter_propriedade_tipo_logico;
exports.obter_propriedade_tipo_caracter = obter_propriedade_tipo_caracter;
exports.obter_propriedade_tipo_cadeia = obter_propriedade_tipo_cadeia;
exports.obter_propriedade_tipo_objeto = obter_propriedade_tipo_objeto;
exports.obter_propriedade_tipo_objeto_em_vetor = obter_propriedade_tipo_objeto_em_vetor;
exports.obter_propriedade_tipo_caracter_em_vetor = obter_propriedade_tipo_caracter_em_vetor;
exports.obter_propriedade_tipo_logico_em_vetor = obter_propriedade_tipo_logico_em_vetor;
exports.obter_propriedade_tipo_real_em_vetor = obter_propriedade_tipo_real_em_vetor;
exports.obter_propriedade_tipo_inteiro_em_vetor = obter_propriedade_tipo_inteiro_em_vetor;
exports.obter_propriedade_tipo_cadeia_em_vetor = obter_propriedade_tipo_cadeia_em_vetor;
exports.obter_tamanho_vetor_propriedade = obter_tamanho_vetor_propriedade;
exports.liberar_objeto = liberar_objeto;
exports.obter_json = obter_json;
exports.contem_propriedade = contem_propriedade;
exports.tipo_propriedade = tipo_propriedade;
const xml2js_1 = require("xml2js");
let cacheObjetos = [];
exports.TIPO_INTEIRO = 1;
exports.TIPO_CADEIA = 2;
exports.TIPO_CARACTER = 3;
exports.TIPO_REAL = 4;
exports.TIPO_LOGICO = 5;
exports.TIPO_OBJETO = 6;
exports.TIPO_VETOR = 7;
async function criar_objeto_via_json(interpretador, json) {
    const obj = JSON.parse(json);
    return cacheObjetos.push(obj) - 1;
}
async function criar_objeto_via_xml(interpretador, xml) {
    const obj = parseXml(xml);
    const objJSON = JSON.parse(obj);
    return cacheObjetos.push(objJSON) - 1;
}
async function criar_objeto() {
    return cacheObjetos.push({}) - 1;
}
async function atribuir_propriedade(interpretador, endereco, propriedade, valor) {
    cacheObjetos[endereco][propriedade] = valor;
}
async function obter_propriedade_tipo_inteiro(interpretador, endereco, propriedade) {
    const valor = cacheObjetos[endereco][propriedade];
    if (typeof valor !== 'number') {
        throw new Error('"O tipo da propriedade informada não corresponde ao tipo identificado na função.\nAltere a função de chamada para o tipo correto."');
    }
    return valor;
}
async function obter_propriedade_tipo_real(interpretador, endereco, propriedade) {
    const valor = cacheObjetos[endereco][propriedade];
    if (typeof valor !== 'number') {
        throw new Error('"O tipo da propriedade informada não corresponde ao tipo identificado na função.\nAltere a função de chamada para o tipo correto."');
    }
    return valor;
}
async function obter_propriedade_tipo_logico(interpretador, endereco, propriedade) {
    const valor = cacheObjetos[endereco][propriedade];
    if (typeof valor !== 'boolean') {
        throw new Error('"O tipo da propriedade informada não corresponde ao tipo identificado na função.\nAltere a função de chamada para o tipo correto."');
    }
    return valor;
}
async function obter_propriedade_tipo_caracter(interpretador, endereco, propriedade) {
    const valor = cacheObjetos[endereco][propriedade];
    if (typeof valor !== 'string' || valor.length !== 1) {
        throw new Error('"O tipo da propriedade informada não corresponde ao tipo identificado na função.\nAltere a função de chamada para o tipo correto."');
    }
    return valor;
}
async function obter_propriedade_tipo_cadeia(interpretador, endereco, propriedade) {
    const valor = cacheObjetos[endereco][propriedade];
    if (typeof valor !== 'string') {
        throw new Error('"O tipo da propriedade informada não corresponde ao tipo identificado na função.\nAltere a função de chamada para o tipo correto."');
    }
    return valor;
}
async function obter_propriedade_tipo_objeto(interpretador, endereco, propriedade) {
    const valor = cacheObjetos[endereco][propriedade];
    if (typeof valor !== 'object' || Array.isArray(valor)) {
        throw new Error('"O tipo da propriedade informada não corresponde ao tipo identificado na função.\nAltere a função de chamada para o tipo correto."');
    }
    return cacheObjetos.push(valor) - 1;
}
async function obter_propriedade_tipo_objeto_em_vetor(interpretador, endereco, propriedade, indice) {
    const vetor = cacheObjetos[endereco][propriedade];
    validarVetor(vetor, indice, propriedade);
    if (typeof vetor[indice] !== 'object' || vetor[indice] === null) {
        throw new Error('"O tipo da propriedade informada não corresponde ao tipo identificado na função.\nAltere a função de chamada para o tipo correto."');
    }
    return cacheObjetos.push(vetor[indice]) - 1;
}
async function obter_propriedade_tipo_caracter_em_vetor(interpretador, endereco, propriedade, indice) {
    const vetor = cacheObjetos[endereco][propriedade];
    validarVetor(vetor, indice, propriedade);
    if (typeof vetor[indice] !== 'string' || vetor[indice].length !== 1) {
        throw new Error('"O tipo da propriedade informada não corresponde ao tipo identificado na função.\nAltere a função de chamada para o tipo correto."');
    }
    return vetor[indice];
}
async function obter_propriedade_tipo_logico_em_vetor(interpretador, endereco, propriedade, indice) {
    const vetor = cacheObjetos[endereco][propriedade];
    validarVetor(vetor, indice, propriedade);
    if (typeof vetor[indice] !== 'boolean') {
        throw new Error('"O tipo da propriedade informada não corresponde ao tipo identificado na função.\nAltere a função de chamada para o tipo correto."');
    }
    return vetor[indice];
}
async function obter_propriedade_tipo_real_em_vetor(interpretador, endereco, propriedade, indice) {
    const vetor = cacheObjetos[endereco][propriedade];
    validarVetor(vetor, indice, propriedade);
    if (typeof vetor[indice] !== 'number' || !Number.isFinite(vetor[indice])) {
        throw new Error('"O tipo da propriedade informada não corresponde ao tipo identificado na função.\nAltere a função de chamada para o tipo correto."');
    }
    return vetor[indice];
}
async function obter_propriedade_tipo_inteiro_em_vetor(interpretador, endereco, propriedade, indice) {
    const vetor = cacheObjetos[endereco][propriedade];
    validarVetor(vetor, indice, propriedade);
    if (typeof vetor[indice] !== 'number' || !Number.isInteger(vetor[indice])) {
        throw new Error('"O tipo da propriedade informada não corresponde ao tipo identificado na função.\nAltere a função de chamada para o tipo correto."');
    }
    return vetor[indice];
}
async function obter_propriedade_tipo_cadeia_em_vetor(interpretador, endereco, propriedade, indice) {
    const vetor = cacheObjetos[endereco][propriedade];
    validarVetor(vetor, indice, propriedade);
    if (typeof vetor[indice] !== 'string') {
        throw new Error('"O tipo da propriedade informada não corresponde ao tipo identificado na função.\nAltere a função de chamada para o tipo correto."');
    }
    return vetor[indice];
}
async function obter_tamanho_vetor_propriedade(interpretador, endereco, propriedade) {
    const vetor = cacheObjetos[endereco][propriedade];
    if (!Array.isArray(vetor)) {
        throw new Error('"O tipo da propriedade informada não corresponde ao tipo identificado na função.\nAltere a função de chamada para o tipo correto."');
    }
    return vetor.length;
}
async function liberar_objeto(interpretador, endereco) {
    delete cacheObjetos[endereco];
}
async function obter_json(interpretador, endereco) {
    const objeto = cacheObjetos[endereco];
    if (!objeto) {
        throw new Error('Não foi possível obter o JSON deste objeto.');
    }
    return JSON.stringify(objeto);
}
async function contem_propriedade(interpretador, endereco, propriedade) {
    return cacheObjetos[endereco].hasOwnProperty(propriedade);
}
async function tipo_propriedade(interpretador, endereco, propriedade) {
    const valor = cacheObjetos[endereco][propriedade];
    if (typeof valor === 'string') {
        return valor.length === 1 ? exports.TIPO_CARACTER : exports.TIPO_CADEIA;
    }
    if (typeof valor === 'number') {
        return exports.TIPO_INTEIRO;
    }
    if (typeof valor === 'boolean') {
        return exports.TIPO_LOGICO;
    }
    if (typeof valor === 'object' && !Array.isArray(valor)) {
        return exports.TIPO_OBJETO;
    }
    if (Array.isArray(valor)) {
        return exports.TIPO_VETOR;
    }
    throw new Error('Tipo de propriedade desconhecida');
}
function validarVetor(vetor, indice, propriedade) {
    if (!Array.isArray(vetor)) {
        throw new Error('A propriedade "' + propriedade + '" não é um vetor.');
    }
    if (indice < 0 || indice >= vetor.length) {
        throw new Error('Você tentou acessar um índice de vetor inválido.\n' +
            'O índice deve ser menor que o número de elementos que o vetor possui.\n' +
            'Por exemplo, se foi declarado um vetor com 5 elementos (inteiro vetor[5]), o maior índice possível é 4.\n' +
            'Além disso, o índice de um vetor não pode ser negativo.');
    }
}
function parseXml(xmlString) {
    let resultString = '';
    (0, xml2js_1.parseString)(xmlString, {
        explicitArray: false,
        explicitRoot: false,
        mergeAttrs: true,
    }, (err, result) => {
        if (err) {
            console.error('Erro processando XML:', err);
            resultString = 'Erro processando XML';
        }
        else {
            resultString = JSON.stringify(result);
        }
    });
    return resultString;
}
//# sourceMappingURL=objetos.js.map