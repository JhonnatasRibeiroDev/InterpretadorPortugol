"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.numero_caracteres = numero_caracteres;
exports.caixa_alta = caixa_alta;
exports.caixa_baixa = caixa_baixa;
exports.substituir = substituir;
exports.preencher_a_esquerda = preencher_a_esquerda;
exports.obter_caracter = obter_caracter;
exports.posicao_texto = posicao_texto;
exports.extrair_subtexto = extrair_subtexto;
async function numero_caracteres(interpretador, cadeia) {
    return Promise.resolve(cadeia.length);
}
async function caixa_alta(interpretador, cad) {
    return Promise.resolve(cad.toUpperCase());
}
async function caixa_baixa(interpretador, cad) {
    return Promise.resolve(cad.toLowerCase());
}
async function substituir(interpretador, cad, texto_pesquisa, texto_substituto) {
    return Promise.resolve(cad.replace(texto_pesquisa, texto_substituto));
}
async function preencher_a_esquerda(interpretador, car, tamanho, cad) {
    if (cad.length < tamanho) {
        const diferenca = tamanho - cad.length;
        const enchimento = car.repeat(diferenca);
        cad = enchimento + cad;
    }
    return Promise.resolve(cad);
}
async function obter_caracter(interpretador, cad, indice) {
    if (indice < 0) {
        throw new Error(`O índice do caracter (${indice}) é menor que 0`);
    }
    if (indice > cad.length - 1) {
        throw new Error(`O índice do caracter (${indice}) é maior que o número de caracteres na cadeia (${cad.length})`);
    }
    return cad.charAt(indice);
}
async function posicao_texto(interpretador, cadeia, texto, posicao_inicial) {
    return Promise.resolve(cadeia.indexOf(texto, posicao_inicial));
}
async function extrair_subtexto(interpretador, cadeia, posicao_inicial, posicao_final) {
    if (posicao_inicial < 0 || posicao_final > cadeia.length) {
        throw new Error('Posição inicial ou final inválida. A posição deve estar entre 0 e o tamanho da cadeia');
    }
    return Promise.resolve(cadeia.substring(posicao_inicial, posicao_final));
}
//# sourceMappingURL=texto.js.map