"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.definir_tempo_limite = definir_tempo_limite;
exports.obter_texto = obter_texto;
exports.baixar_imagem = baixar_imagem;
exports.endereco_disponivel = endereco_disponivel;
const node_fetch_1 = __importDefault(require("node-fetch"));
const fs_1 = require("fs");
const path_1 = require("path");
let timeout = 2000;
async function definir_tempo_limite(interpretador, time) {
    timeout = time;
}
async function fetch_com_timeout(url, options = {}) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    const { signal } = controller;
    try {
        return await (0, node_fetch_1.default)(url, Object.assign(Object.assign({}, options), { signal }));
    }
    finally {
        clearTimeout(timeoutId);
    }
}
async function obter_texto(interpretador, caminho) {
    try {
        const response = await fetch_com_timeout(caminho, { method: 'GET' });
        const conteudo = await response.text();
        if (!conteudo) {
            throw new Error(`O caminho ${caminho} não tem nenhum conteúdo`);
        }
        return conteudo;
    }
    catch (error) {
        throw new Error(`Não foi possível obter o conteúdo de ${caminho}: ${error.message}`);
    }
}
async function baixar_imagem(interpretador, endereco, caminho) {
    let tipoDaImagem;
    let headerDaRequisicao;
    let imagemObtida;
    let arquivo;
    try {
        tipoDaImagem = 'png';
        const responseHead = await fetch_com_timeout(endereco, { method: 'HEAD' });
        headerDaRequisicao = responseHead.headers.get('content-type') || '';
        if (headerDaRequisicao.includes('image/png')) {
            tipoDaImagem = 'png';
        }
        else if (headerDaRequisicao.includes('image/jpeg') || headerDaRequisicao.includes('image/jpg')) {
            tipoDaImagem = 'jpg';
        }
        const responseImage = await fetch_com_timeout(endereco, { method: 'GET' });
        const arrayBuffer = await responseImage.arrayBuffer();
        imagemObtida = Buffer.from(arrayBuffer);
    }
    catch (error) {
        throw new Error(`Não foi possível obter o conteúdo de ${endereco}`);
    }
    arquivo = (0, path_1.resolve)(caminho + `.${tipoDaImagem}`);
    try {
        await new Promise((resolve, reject) => {
            const stream = (0, fs_1.createWriteStream)(arquivo);
            stream.on('finish', resolve);
            stream.on('error', reject);
            stream.write(imagemObtida);
            stream.end();
        });
    }
    catch (error) {
        throw new Error(`Não foi possível salvar a imagem em ${arquivo}\nGaranta que o caminho é válido e todas as pastas existem`);
    }
    return tipoDaImagem;
}
async function endereco_disponivel(interpretador, endereco) {
    try {
        const response = await fetch_com_timeout(endereco, { method: 'HEAD' });
        const status = response.status;
        if (status === 404 || status === 0) {
            return false;
        }
        return true;
    }
    catch (error) {
        return false;
    }
}
//# sourceMappingURL=internet.js.map