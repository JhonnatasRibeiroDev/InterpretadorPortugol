"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.abrir_arquivo = abrir_arquivo;
exports.fechar_arquivo = fechar_arquivo;
exports.fim_arquivo = fim_arquivo;
exports.ler_linha = ler_linha;
exports.escrever_linha = escrever_linha;
exports.substituir_texto = substituir_texto;
exports.arquivo_existe = arquivo_existe;
exports.apagar_arquivo = apagar_arquivo;
exports.criar_pasta = criar_pasta;
exports.listar_pastas = listar_pastas;
exports.listar_arquivos = listar_arquivos;
exports.listar_arquivos_por_tipo = listar_arquivos_por_tipo;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const NUMERO_MAXIMO_ARQUIVOS = 10;
const ModoAcesso = {
    LEITURA: 0,
    ESCRITA: 1,
    ACRESCENTAR: 2,
};
const arquivos = new Array(NUMERO_MAXIMO_ARQUIVOS).fill(null);
async function abrir_arquivo(interpretador, caminhoArquivo, modoAcesso) {
    if (modoAcesso < 0 || modoAcesso > 2) {
        throw new Error(`Modo de acesso inválido: ${modoAcesso}`);
    }
    if (!arquivoAberto(caminhoArquivo)) {
        const indice = obterProximoIndiceLivre();
        arquivos[indice] = {
            caminho: caminhoArquivo,
            modoAcesso,
            stream: modoAcesso === ModoAcesso.LEITURA
                ? fs_1.default.createReadStream(caminhoArquivo, 'utf-8')
                : fs_1.default.createWriteStream(caminhoArquivo, {
                    flags: modoAcesso === ModoAcesso.ACRESCENTAR ? 'a' : 'w',
                    encoding: 'utf-8',
                }),
            leitor: modoAcesso === ModoAcesso.LEITURA ? fs_1.default.promises.readFile(caminhoArquivo, 'utf-8') : null,
            escritor: modoAcesso !== ModoAcesso.LEITURA
                ? fs_1.default.promises.writeFile(caminhoArquivo, '', {
                    flag: modoAcesso === ModoAcesso.ACRESCENTAR ? 'a' : 'w',
                })
                : null,
            fim: false,
        };
        return indice;
    }
    else {
        throw new Error(`O arquivo '${caminhoArquivo}' já está aberto`);
    }
}
async function fechar_arquivo(interpretador, endereco) {
    const arquivo = obterArquivo(endereco);
    if (arquivo) {
        arquivo.stream.close();
        arquivos[endereco] = null;
    }
    else {
        throw new Error(`O endereço de memória especificado não aponta para um arquivo`);
    }
}
function fim_arquivo(interpretador, endereco) {
    const arquivo = obterArquivo(endereco);
    return arquivo.fim;
}
async function ler_linha(interpretador, endereco) {
    const arquivo = obterArquivo(endereco);
    if (arquivo.modoAcesso !== ModoAcesso.LEITURA) {
        throw new Error(`O arquivo '${arquivo.caminho}' está aberto em modo de escrita`);
    }
    const data = await arquivo.leitor;
    return data.split('\n')[0];
}
async function escrever_linha(interpretador, linha, endereco) {
    const arquivo = obterArquivo(endereco);
    if (arquivo.modoAcesso === ModoAcesso.LEITURA) {
        throw new Error(`O arquivo '${arquivo.caminho}' está aberto em modo de leitura`);
    }
    await fs_1.default.promises.appendFile(arquivo.caminho, linha + '\n', 'utf-8');
}
async function substituir_texto(interpretador, endereco, textoPesquisa, textoSubstituto, onlyFirst) {
    const filePath = path_1.default.resolve(endereco);
    const data = await fs_1.default.promises.readFile(filePath, 'utf-8');
    const newText = onlyFirst
        ? data.replace(textoPesquisa, textoSubstituto)
        : data.replace(new RegExp(textoPesquisa, 'g'), textoSubstituto);
    await fs_1.default.promises.writeFile(filePath, newText, 'utf-8');
}
async function arquivo_existe(interpretador, caminhoArquivo) {
    const filePath = path_1.default.resolve(caminhoArquivo);
    return fs_1.default.promises
        .access(filePath, fs_1.default.constants.F_OK)
        .then(() => true)
        .catch(() => false);
}
async function apagar_arquivo(interpretador, caminhoArquivo) {
    const filePath = path_1.default.resolve(caminhoArquivo);
    await fs_1.default.promises.unlink(filePath);
}
async function criar_pasta(interpretador, caminho) {
    const dirPath = path_1.default.resolve(caminho);
    await fs_1.default.promises.mkdir(dirPath, { recursive: true });
}
async function listar_pastas(interpretador, caminhoPai, vetorPastas) {
    const dirPath = path_1.default.resolve(caminhoPai);
    const items = await fs_1.default.promises.readdir(dirPath, { withFileTypes: true });
    const pastas = items.filter((item) => item.isDirectory()).map((item) => item.name);
    if (pastas.length > vetorPastas.length) {
        throw new Error(`Não foi possível listar as pastas pois o vetor passado é muito pequeno. O diretório escolhido possui ${pastas.length} pastas, mas o vetor passado comporta apenas ${vetorPastas.length} elementos.`);
    }
    pastas.forEach((pasta, i) => {
        vetorPastas[i] = pasta;
    });
    for (let i = pastas.length; i < vetorPastas.length; i++) {
        vetorPastas[i] = '';
    }
}
async function listar_arquivos(interpretador, caminhoPai, vetorArquivos) {
    const dirPath = path_1.default.resolve(caminhoPai);
    const items = await fs_1.default.promises.readdir(dirPath, { withFileTypes: true });
    const arquivos = items.filter((item) => item.isFile()).map((item) => item.name);
    if (arquivos.length > vetorArquivos.length) {
        throw new Error(`Não foi possível listar os arquivos pois o vetor passado é muito pequeno. O diretório escolhido possui ${arquivos.length} arquivos, mas o vetor passado comporta apenas ${vetorArquivos.length} elementos.`);
    }
    arquivos.forEach((arquivo, i) => {
        vetorArquivos[i] = arquivo;
    });
    for (let i = arquivos.length; i < vetorArquivos.length; i++) {
        vetorArquivos[i] = '';
    }
}
async function listar_arquivos_por_tipo(interpretador, caminhoPai, vetorArquivos, vetorTipos) {
    const dirPath = path_1.default.resolve(caminhoPai);
    const items = await fs_1.default.promises.readdir(dirPath, { withFileTypes: true });
    const arquivos = items
        .filter((item) => item.isFile() && vetorTipos.some((tipo) => item.name.endsWith(tipo)))
        .map((item) => item.name);
    if (arquivos.length > vetorArquivos.length) {
        throw new Error(`Não foi possível listar os arquivos pois o vetor passado é muito pequeno. O diretório escolhido possui ${arquivos.length} arquivos, mas o vetor passado comporta apenas ${vetorArquivos.length} elementos.`);
    }
    arquivos.forEach((arquivo, i) => {
        vetorArquivos[i] = arquivo;
    });
    for (let i = arquivos.length; i < vetorArquivos.length; i++) {
        vetorArquivos[i] = '';
    }
}
function obterProximoIndiceLivre() {
    const indice = arquivos.findIndex((arquivo) => arquivo === null);
    if (indice === -1) {
        throw new Error('O número máximo de arquivos que podem ser abertos ao mesmo tempo foi atingido');
    }
    return indice;
}
function obterArquivo(endereco) {
    const arquivo = arquivos[endereco];
    if (!arquivo) {
        throw new Error('O endereço de memória especificado não aponta para um arquivo');
    }
    return arquivo;
}
function arquivoAberto(caminho) {
    return arquivos.some((arquivo) => arquivo && arquivo.caminho === caminho);
}
//# sourceMappingURL=arquivos.js.map