"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnalisadorSemanticoBirl = void 0;
const erros_1 = require("@designliquido/delegua/interfaces/erros");
const analisador_semantico_base_1 = require("@designliquido/delegua/analisador-semantico/analisador-semantico-base");
const pilha_variaveis_1 = require("@designliquido/delegua/analisador-semantico/pilha-variaveis");
class AnalisadorSemanticoBirl extends analisador_semantico_base_1.AnalisadorSemanticoBase {
    constructor() {
        super();
        this.pilhaVariaveis = new pilha_variaveis_1.PilhaVariaveis();
        this.variaveis = {};
        this.atual = 0;
        this.diagnosticos = [];
    }
    visitarExpressaoDeAtribuicao(expressao) {
        const { alvo, valor } = expressao;
        // Provavelmente o alvo é sempre `Variavel`
        const alvoVariavel = alvo;
        let variavel = this.variaveis[alvoVariavel.simbolo.lexema];
        if (!variavel) {
            this.adicionarDiagnostico(alvoVariavel.simbolo, `Variável ${alvoVariavel.simbolo.lexema} ainda não foi declarada.`);
            return Promise.resolve();
        }
        if (variavel.imutavel) {
            this.adicionarDiagnostico(alvoVariavel.simbolo, `Constante ${alvoVariavel.simbolo.lexema} não pode ser modificada.`);
            return Promise.resolve();
        }
    }
    visitarDeclaracaoDeExpressao(declaracao) {
        return declaracao.expressao.aceitar(this);
    }
    visitarDeclaracaoVar(declaracao) {
        this.variaveis[declaracao.simbolo.lexema] = {
            imutavel: false,
            tipo: 'número',
        };
        return Promise.resolve();
    }
    visitarExpressaoLeia(expressao) {
        if (!this.variaveis.hasOwnProperty(expressao.argumentos[0].simbolo.lexema)) {
            this.diagnosticos.push({
                simbolo: expressao.argumentos[0].simbolo,
                mensagem: `A variável ${expressao.argumentos[0].simbolo.lexema} não foi declarada.`,
                hashArquivo: expressao.hashArquivo,
                linha: expressao.linha,
                severidade: erros_1.DiagnosticoSeveridade.ERRO,
            });
            return Promise.resolve();
        }
        const tipoVariavelExpressão = this.variaveis[expressao.argumentos[0].simbolo.lexema].tipo;
        const tipoVariavelArgumento = expressao.argumentos[1].valor;
        if (tipoVariavelExpressão !== tipoVariavelArgumento) {
            this.diagnosticos.push({
                simbolo: expressao.argumentos[0].simbolo,
                mensagem: `A variável ${expressao.argumentos[0].simbolo.lexema} não é do tipo ${tipoVariavelArgumento}.`,
                hashArquivo: expressao.hashArquivo,
                linha: expressao.linha,
                severidade: erros_1.DiagnosticoSeveridade.ERRO,
            });
        }
        return Promise.resolve();
    }
    visitarExpressaoRetornar(declaracao) {
        return Promise.resolve(null);
    }
    analisar(declaracoes) {
        this.variaveis = {};
        this.atual = 0;
        this.diagnosticos = [];
        while (this.atual < declaracoes.length) {
            declaracoes[this.atual].aceitar(this);
            this.atual++;
        }
        return {
            diagnosticos: this.diagnosticos,
        };
    }
}
exports.AnalisadorSemanticoBirl = AnalisadorSemanticoBirl;
//# sourceMappingURL=analisador-semantico-birl.js.map