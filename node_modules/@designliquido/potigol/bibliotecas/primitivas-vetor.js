"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = {
    cabeça: (interpretador, vetor) => Promise.resolve(vetor[0]),
    cauda: (interpretador, vetor) => {
        let copia = [...vetor];
        copia.splice(0, 1);
        return Promise.resolve(copia);
    },
    contém: (interpretador, vetor, elemento) => Promise.resolve(vetor.includes(elemento)),
    descarte: (interpretador, vetor, elementos) => {
        let copia = [...vetor];
        copia.splice(0, elementos);
        return Promise.resolve(copia);
    },
    descarte_enquanto: async (interpretador, vetor, funcao) => {
        if (funcao === undefined || funcao === null) {
            return Promise.reject("É necessário passar uma função para o método 'descarte_enquanto'.");
        }
        const retorno = [...vetor];
        for (let elemento of vetor) {
            let resultado = await funcao.chamar(interpretador, [elemento]);
            if (resultado) {
                retorno.shift();
            }
            else {
                break;
            }
        }
        return retorno;
    },
    divida_quando: async (interpretador, vetor, funcao) => {
        if (vetor.length === 0) {
            return vetor;
        }
        if (funcao === undefined || funcao === null) {
            return Promise.reject("É necessário passar uma função para o método 'divida_quando'.");
        }
        const retorno = [];
        let elementoAnterior = vetor.shift();
        let retornoAcumulado = [elementoAnterior];
        for (let elemento of vetor) {
            let resultado = await funcao.chamar(interpretador, [elementoAnterior, elemento]);
            if (resultado) {
                elementoAnterior = elemento;
                retorno.push(retornoAcumulado);
                retornoAcumulado = [elemento];
            }
            else {
                retornoAcumulado.push(elemento);
            }
        }
        if (retornoAcumulado.length > 0) {
            retorno.push(retornoAcumulado);
        }
        return retorno;
    },
    imutável: (interpretador, vetor) => Promise.resolve(),
    injete: async (interpretador, vetor, funcao) => {
        // TODO: Terminar
        /* if (funcao === undefined || funcao === null) {
            return Promise.reject("É necessário passar uma função para o método 'injete'.");
        }

        let retorno: any;
        for (let elemento of vetor) {
            retorno = await funcao.chamar(interpretador, [retorno, elemento]);
        }

        return retorno; */
        return Promise.resolve();
    },
    insira: (interpretador, vetor, posicao, elemento) => {
        let copia = [...vetor];
        copia.splice(posicao - 1, 0, elemento);
        return Promise.resolve(copia);
    },
    inverta: (interpretador, vetor) => {
        let copia = [];
        for (let elemento of vetor) {
            copia.unshift(elemento);
        }
        return Promise.resolve(copia);
    },
    junte: (interpretador, vetor, separador) => Promise.resolve(vetor.join(separador)),
    mapeie: async (interpretador, vetor, funcao) => {
        if (funcao === undefined || funcao === null) {
            return Promise.reject("É necessário passar uma função para o método 'mapeie'.");
        }
        const retorno = [];
        for (let elemento of vetor) {
            let resultado = await funcao.chamar(interpretador, [elemento]);
            retorno.push(resultado);
        }
        return retorno;
    },
    ordene: (interpretador, vetor) => Promise.resolve(vetor.sort((a, b) => a - b)),
    pegue: (interpretador, vetor, elementos) => Promise.resolve(vetor.slice(0, elementos)),
    pegue_enquanto: async (interpretador, vetor, funcao) => {
        if (funcao === undefined || funcao === null) {
            return Promise.reject("É necessário passar uma função para o método 'pegue_enquanto'.");
        }
        const retorno = [];
        for (let elemento of vetor) {
            let resultado = await funcao.chamar(interpretador, [elemento]);
            if (resultado) {
                retorno.push(elemento);
            }
            else {
                break;
            }
        }
        return retorno;
    },
    posição: (interpretador, vetor, elemento) => Promise.resolve(vetor.indexOf(elemento) + 1),
    qual_tipo: (interpretador, vetor) => Promise.resolve('Lista'),
    remova: (interpretador, vetor, posicao) => {
        let copia = [...vetor];
        copia.splice(posicao - 1, 1);
        return Promise.resolve(copia);
    },
    selecione: async (interpretador, vetor, funcao) => {
        if (funcao === undefined || funcao === null) {
            return Promise.reject("É necessário passar uma função para o método 'selecione'.");
        }
        const retorno = [];
        for (let elemento of vetor) {
            if (await funcao.chamar(interpretador, [elemento])) {
                retorno.push(elemento);
            }
        }
        return retorno;
    },
    tamanho: (interpretador, vetor) => Promise.resolve(vetor.length),
    último: (interpretador, vetor) => Promise.resolve(vetor.length > 0 ? vetor[vetor.length - 1] : undefined),
    vazia: (interpretador, vetor) => Promise.resolve(vetor.length === 0),
};
//# sourceMappingURL=primitivas-vetor.js.map