"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.carregarBibliotecaGlobal = carregarBibliotecaGlobal;
exports.visitarDeclaracaoReatribuicaoVariavel = visitarDeclaracaoReatribuicaoVariavel;
exports.visitarExpressaoAcessoMetodoOuPropriedade = visitarExpressaoAcessoMetodoOuPropriedade;
exports.visitarExpressaoBinaria = visitarExpressaoBinaria;
exports.visitarExpressaoLeia = visitarExpressaoLeia;
exports.visitarExpressaoLeiaMultiplo = visitarExpressaoLeiaMultiplo;
exports.visitarExpressaoQualTipo = visitarExpressaoQualTipo;
exports.visitarExpressaoTupla = visitarExpressaoTupla;
exports.avaliarArgumentosEscreva = avaliarArgumentosEscreva;
exports.resolverInterpolacoes = resolverInterpolacoes;
exports.retirarInterpolacao = retirarInterpolacao;
const construtos_1 = require("@designliquido/delegua/construtos");
const estruturas_1 = require("@designliquido/delegua/estruturas");
const excecoes_1 = require("@designliquido/delegua/excecoes");
const inferenciador_1 = require("./inferenciador");
const estruturas_2 = require("../estruturas");
const construtos_2 = require("../construtos");
const bibliotecaGlobal = __importStar(require("../bibliotecas/biblioteca-global"));
const primitivas_numero_1 = __importDefault(require("../bibliotecas/primitivas-numero"));
const primitivas_texto_1 = __importDefault(require("../bibliotecas/primitivas-texto"));
const primitivas_vetor_1 = __importDefault(require("../bibliotecas/primitivas-vetor"));
const lexico_regular_1 = __importDefault(require("../tipos-de-simbolos/lexico-regular"));
const tiposNumericos = ['inteiro', 'numero', 'número', 'real'];
function carregarBibliotecaGlobal(pilhaEscoposExecucao) {
    pilhaEscoposExecucao.definirVariavel('abs', new estruturas_1.FuncaoPadrao(1, bibliotecaGlobal.abs));
    pilhaEscoposExecucao.definirVariavel('aleatório', new estruturas_1.FuncaoPadrao(0, bibliotecaGlobal.aleatorio));
    pilhaEscoposExecucao.definirVariavel('arccos', new estruturas_1.FuncaoPadrao(1, bibliotecaGlobal.arccos));
    pilhaEscoposExecucao.definirVariavel('arcsen', new estruturas_1.FuncaoPadrao(1, bibliotecaGlobal.arcsen));
    pilhaEscoposExecucao.definirVariavel('arctg', new estruturas_1.FuncaoPadrao(1, bibliotecaGlobal.arctg));
    pilhaEscoposExecucao.definirVariavel('cos', new estruturas_1.FuncaoPadrao(1, bibliotecaGlobal.cos));
    pilhaEscoposExecucao.definirVariavel('log', new estruturas_1.FuncaoPadrao(1, bibliotecaGlobal.log));
    pilhaEscoposExecucao.definirVariavel('log10', new estruturas_1.FuncaoPadrao(1, bibliotecaGlobal.log10));
    pilhaEscoposExecucao.definirVariavel('pi', new estruturas_1.FuncaoPadrao(0, bibliotecaGlobal.pi));
    pilhaEscoposExecucao.definirVariavel('raiz', new estruturas_1.FuncaoPadrao(1, bibliotecaGlobal.raiz));
    pilhaEscoposExecucao.definirVariavel('sen', new estruturas_1.FuncaoPadrao(1, bibliotecaGlobal.sen));
    pilhaEscoposExecucao.definirVariavel('tg', new estruturas_1.FuncaoPadrao(1, bibliotecaGlobal.tg));
}
async function visitarDeclaracaoReatribuicaoVariavel(interpretador, declaracao) {
    const valorFinal = await interpretador.avaliacaoDeclaracaoVarOuConst(declaracao);
    interpretador.pilhaEscoposExecucao.definirVariavel(declaracao.simbolo.lexema, valorFinal, declaracao.tipo);
    return null;
}
/**
 * Executa um acesso a método, normalmente de um objeto de classe.
 * @param expressao A expressão de acesso.
 * @returns O resultado da execução.
 */
async function visitarExpressaoAcessoMetodoOuPropriedade(interpretador, expressao) {
    const variavelObjeto = await interpretador.avaliar(expressao.objeto);
    const objeto = variavelObjeto.hasOwnProperty('valor') ? variavelObjeto.valor : variavelObjeto;
    if (objeto instanceof estruturas_1.ObjetoDeleguaClasse) {
        return objeto.obter(expressao.simbolo) || null;
    }
    // TODO: Isso está aqui porque Delégua trabalha com objetos
    // como dicionários internamente.
    // Verificar se Potigol também possui suporte a dicionários.
    if (objeto.constructor === Object) {
        return objeto[expressao.simbolo.lexema] || null;
    }
    // Função tradicional do JavaScript.
    // Normalmente executa quando uma biblioteca é importada.
    if (typeof objeto[expressao.simbolo.lexema] === 'function') {
        return objeto[expressao.simbolo.lexema];
    }
    // Objeto tradicional do JavaScript.
    // Normalmente executa quando uma biblioteca é importada.
    if (typeof objeto[expressao.simbolo.lexema] === 'object') {
        return objeto[expressao.simbolo.lexema];
    }
    if (objeto instanceof estruturas_1.DeleguaModulo) {
        return objeto.componentes[expressao.simbolo.lexema] || null;
    }
    let tipoObjeto = variavelObjeto.tipo;
    if (tipoObjeto === null || tipoObjeto === undefined) {
        tipoObjeto = (0, inferenciador_1.inferirTipoVariavel)(variavelObjeto);
    }
    switch (tipoObjeto) {
        case 'inteiro':
        case 'Inteiro': // TODO: Remover.
        case 'Real': // TODO: Remover. 
        case 'número':
            const metodoDePrimitivaNumero = primitivas_numero_1.default[expressao.simbolo.lexema];
            if (metodoDePrimitivaNumero) {
                return new estruturas_1.MetodoPrimitiva(objeto, metodoDePrimitivaNumero);
            }
            break;
        case 'texto':
            const metodoDePrimitivaTexto = primitivas_texto_1.default[expressao.simbolo.lexema];
            if (metodoDePrimitivaTexto) {
                return new estruturas_1.MetodoPrimitiva(objeto, metodoDePrimitivaTexto);
            }
            break;
        case 'vetor':
            const metodoDePrimitivaVetor = primitivas_vetor_1.default[expressao.simbolo.lexema];
            if (metodoDePrimitivaVetor) {
                return new estruturas_1.MetodoPrimitiva(objeto, metodoDePrimitivaVetor);
            }
            break;
    }
    return Promise.reject(new excecoes_1.ErroEmTempoDeExecucao(expressao.simbolo, `Método para objeto ou primitiva não encontrado: ${expressao.simbolo.lexema}.`, expressao.linha));
}
async function visitarExpressaoBinaria(interpretador, expressao) {
    const esquerda = await interpretador.avaliar(expressao.esquerda);
    const direita = await interpretador.avaliar(expressao.direita);
    const valorEsquerdo = (esquerda === null || esquerda === void 0 ? void 0 : esquerda.hasOwnProperty('valor')) ? esquerda.valor : esquerda;
    const valorDireito = (direita === null || direita === void 0 ? void 0 : direita.hasOwnProperty('valor')) ? direita.valor : direita;
    const tipoEsquerdo = (esquerda === null || esquerda === void 0 ? void 0 : esquerda.hasOwnProperty('tipo')) ? esquerda.tipo : (0, inferenciador_1.inferirTipoVariavel)(esquerda);
    const tipoDireito = (direita === null || direita === void 0 ? void 0 : direita.hasOwnProperty('tipo')) ? direita.tipo : (0, inferenciador_1.inferirTipoVariavel)(direita);
    switch (expressao.operador.tipo) {
        case lexico_regular_1.default.EXPONENCIACAO:
            this.verificarOperandosNumeros(expressao.operador, esquerda, direita);
            return Math.pow(valorEsquerdo, valorDireito);
        case lexico_regular_1.default.MAIOR:
            if (tiposNumericos.includes(tipoEsquerdo) && tiposNumericos.includes(tipoDireito)) {
                return Number(valorEsquerdo) > Number(valorDireito);
            }
            return String(valorEsquerdo) > String(valorDireito);
        case lexico_regular_1.default.MAIOR_IGUAL:
            this.verificarOperandosNumeros(expressao.operador, esquerda, direita);
            return Number(valorEsquerdo) >= Number(valorDireito);
        case lexico_regular_1.default.MENOR:
            if (tiposNumericos.includes(tipoEsquerdo) && tiposNumericos.includes(tipoDireito)) {
                return Number(valorEsquerdo) < Number(valorDireito);
            }
            return String(valorEsquerdo) < String(valorDireito);
        case lexico_regular_1.default.MENOR_IGUAL:
            this.verificarOperandosNumeros(expressao.operador, esquerda, direita);
            return Number(valorEsquerdo) <= Number(valorDireito);
        case lexico_regular_1.default.SUBTRACAO:
            this.verificarOperandosNumeros(expressao.operador, esquerda, direita);
            return Number(valorEsquerdo) - Number(valorDireito);
        case lexico_regular_1.default.ADICAO:
            if (tiposNumericos.includes(tipoEsquerdo) && tiposNumericos.includes(tipoDireito)) {
                return Number(valorEsquerdo) + Number(valorDireito);
            }
            return this.paraTexto(valorEsquerdo) + this.paraTexto(valorDireito);
        case lexico_regular_1.default.DIVISAO:
            this.verificarOperandosNumeros(expressao.operador, esquerda, direita);
            return Number(valorEsquerdo) / Number(valorDireito);
        case lexico_regular_1.default.DIVISAO_INTEIRA:
            this.verificarOperandosNumeros(expressao.operador, esquerda, direita);
            return Math.floor(Number(valorEsquerdo) / Number(valorDireito));
        case lexico_regular_1.default.MULTIPLICACAO:
            return Number(valorEsquerdo) * Number(valorDireito);
        case lexico_regular_1.default.MODULO:
            this.verificarOperandosNumeros(expressao.operador, esquerda, direita);
            return Number(valorEsquerdo) % Number(valorDireito);
        case lexico_regular_1.default.DIFERENTE:
            return !interpretador.eIgual(valorEsquerdo, valorDireito);
        case lexico_regular_1.default.IGUAL_IGUAL:
            return interpretador.eIgual(valorEsquerdo, valorDireito);
        case lexico_regular_1.default.CONCATENACAO_LISTA:
            if (!Array.isArray(valorDireito)) {
                throw new excecoes_1.ErroEmTempoDeExecucao(expressao.operador, 'Lado direito da concatenação não parece ser uma lista.');
            }
            return [valorEsquerdo].concat(valorDireito);
    }
}
async function visitarExpressaoLeia(interpretador, expressao) {
    let _resposta = "";
    await interpretador.interfaceEntradaSaida.question('> ', (resposta) => {
        _resposta = String(resposta);
    });
    // TODO: Ver o que acontece em Potigol quando tipos conflitam.
    switch (expressao.constructor.name) {
        case 'LeiaInteiro':
            return Promise.resolve(parseInt(_resposta));
        case 'LeiaReal':
            return Promise.resolve(Number(_resposta));
        case 'LeiaTexto':
            return Promise.resolve(String(_resposta));
    }
}
async function visitarExpressaoLeiaMultiplo(interpretador, expressao) {
    let respostas = [];
    // O argumento sempre vem preenchido aqui.
    // Se for um literal, o literal contém o número de valores a serem lidos
    // da entrada.
    let valores = 0;
    const argumento = expressao.argumentoCardinalidade;
    if (argumento instanceof construtos_1.Literal) {
        switch (argumento.valor) {
            case ',':
                await interpretador.interfaceEntradaSaida.question('> ', (resposta) => {
                    respostas = String(resposta)
                        .split(',')
                        .filter((valor) => !/(\s+)/.test(valor));
                });
                break;
            default:
                valores = argumento.valor;
                for (let i = 0; i < valores; i++) {
                    await interpretador.interfaceEntradaSaida.question('> ', (resposta) => {
                        respostas.push(resposta);
                    });
                }
                break;
        }
    }
    return Promise.resolve(respostas);
}
async function visitarExpressaoQualTipo(interpretador, expressao) {
    let qualTipo = expressao.valor;
    if ((expressao === null || expressao === void 0 ? void 0 : expressao.valor) instanceof construtos_2.ConstanteOuVariavel) {
        const nome = expressao === null || expressao === void 0 ? void 0 : expressao.valor.simbolo.lexema;
        qualTipo = interpretador.pilhaEscoposExecucao.topoDaPilha().ambiente.valores[nome].valor;
    }
    if (qualTipo instanceof construtos_1.Binario ||
        qualTipo instanceof construtos_1.Literal ||
        qualTipo instanceof construtos_2.QualTipo ||
        qualTipo instanceof construtos_1.Unario ||
        qualTipo instanceof construtos_1.Variavel) {
        qualTipo = await interpretador.avaliar(qualTipo);
        return qualTipo.tipo || (0, inferenciador_1.inferirTipoVariavel)(qualTipo);
    }
    return (0, inferenciador_1.inferirTipoVariavel)((qualTipo === null || qualTipo === void 0 ? void 0 : qualTipo.valores) || qualTipo);
}
async function visitarExpressaoTupla(interpretador, expressao) {
    const chaves = Object.keys(expressao);
    const valores = [];
    for (let chave of chaves) {
        const valor = await interpretador.avaliar(expressao[chave]);
        valores.push(valor);
    }
    const estruturaTupla = new estruturas_2.EstruturaTupla(valores);
    return estruturaTupla;
}
/**
 * `escreva` em Potigol tem apenas um argumento.
 * @param interpretador A instância do interpretador.
 * @param argumento
 * @returns
 */
async function avaliarArgumentosEscreva(interpretador, argumento) {
    let formatoTexto = '';
    if (argumento === undefined) {
        return formatoTexto;
    }
    const resultadoAvaliacao = await interpretador.avaliar(argumento);
    if (typeof resultadoAvaliacao.paraTexto === 'function') {
        formatoTexto = resultadoAvaliacao.paraTexto();
    }
    else {
        let valor = (resultadoAvaliacao === null || resultadoAvaliacao === void 0 ? void 0 : resultadoAvaliacao.hasOwnProperty('valor')) ? resultadoAvaliacao.valor : resultadoAvaliacao;
        formatoTexto = `${interpretador.paraTexto(valor)}`;
    }
    return formatoTexto;
}
/**
 * Resolve todas as interpolações em um texto.
 * @param {texto} textoOriginal O texto original com as variáveis interpoladas.
 * @returns Uma lista de variáveis interpoladas.
 */
async function resolverInterpolacoes(interpretador, textoOriginal, linha) {
    const variaveis = textoOriginal.match(interpretador.regexInterpolacao);
    let resultadosAvaliacaoSintatica = variaveis.map((s) => {
        const expressao = s.replace(/[\{\}]*/gm, '');
        let microLexador = interpretador.microLexador.mapear(expressao);
        const resultadoMicroAvaliadorSintatico = interpretador.microAvaliadorSintatico.analisar(microLexador, linha);
        return {
            nomeVariavel: expressao,
            resultadoMicroAvaliadorSintatico,
        };
    });
    // TODO: Verificar erros do `resultadosAvaliacaoSintatica`.
    const resolucoesPromises = await Promise.all(resultadosAvaliacaoSintatica
        .flatMap((r) => r.resultadoMicroAvaliadorSintatico.declaracoes)
        .map((d) => interpretador.avaliar(d)));
    return resolucoesPromises.map((item, indice) => ({
        variavel: resultadosAvaliacaoSintatica[indice].nomeVariavel,
        valor: item,
    }));
}
/**
 * Retira a interpolação de um texto.
 * @param {texto} texto O texto
 * @param {any[]} variaveis A lista de variaveis interpoladas
 * @returns O texto com o valor das variaveis.
 */
function retirarInterpolacao(texto, variaveis) {
    let textoFinal = texto;
    variaveis.forEach((elemento) => {
        var _a, _b, _c;
        if (((_a = elemento === null || elemento === void 0 ? void 0 : elemento.valor) === null || _a === void 0 ? void 0 : _a.tipo) === 'lógico') {
            textoFinal = textoFinal.replace('{' + elemento.variavel + '}', this.paraTexto((_b = elemento === null || elemento === void 0 ? void 0 : elemento.valor) === null || _b === void 0 ? void 0 : _b.valor));
        }
        else {
            textoFinal = textoFinal.replace('{' + elemento.variavel + '}', ((_c = elemento === null || elemento === void 0 ? void 0 : elemento.valor) === null || _c === void 0 ? void 0 : _c.valor) || (elemento === null || elemento === void 0 ? void 0 : elemento.valor));
        }
    });
    return textoFinal;
}
//# sourceMappingURL=comum.js.map