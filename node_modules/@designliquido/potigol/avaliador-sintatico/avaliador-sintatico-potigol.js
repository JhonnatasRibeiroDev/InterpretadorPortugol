"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AvaliadorSintaticoPotigol = void 0;
const construtos_1 = require("@designliquido/delegua/construtos");
const declaracoes_1 = require("@designliquido/delegua/declaracoes");
const avaliador_sintatico_base_1 = require("@designliquido/delegua/avaliador-sintatico/avaliador-sintatico-base");
const lexador_1 = require("@designliquido/delegua/lexador");
const erro_avaliador_sintatico_1 = require("@designliquido/delegua/avaliador-sintatico/erro-avaliador-sintatico");
const tuplas_1 = require("@designliquido/delegua/construtos/tuplas");
const construtos_2 = require("../construtos");
const declaracoes_2 = require("../declaracoes");
const micro_avaliador_sintatico_potigol_1 = require("./micro-avaliador-sintatico-potigol");
const pilha_escopos_variaveis_conhecidas_1 = require("./pilha-escopos-variaveis-conhecidas");
const qual_tipo_1 = require("../construtos/qual-tipo");
const lexico_regular_1 = __importDefault(require("../tipos-de-simbolos/lexico-regular"));
/**
 * TODO: Pensar numa forma de avaliar múltiplas constantes sem
 * transformar o retorno de `primario()` em um vetor.
 */
class AvaliadorSintaticoPotigol extends avaliador_sintatico_base_1.AvaliadorSintaticoBase {
    constructor() {
        super();
        this.tiposPotigolParaDelegua = {
            Caractere: 'texto',
            Inteiro: 'inteiro',
            Logico: 'lógico',
            Lógico: 'lógico',
            Real: 'numero',
            Texto: 'texto',
            undefined: undefined,
        };
        this.declaracoes = [];
        this.pilhaEscoposVariaveisConhecidas = new pilha_escopos_variaveis_conhecidas_1.PilhaEscoposVariaveisConhecidas();
    }
    /**
     * Com não há um `leia()` genérico em Potigol, mas sim três tipos de `leia` fortemente
     * tipados, consideramos que este dialeto não implementa `leia`.
     * @see primario
     */
    declaracaoLeia() {
        throw new Error('Método não implementado.');
    }
    /**
     * Testa se o primeiro parâmetro na lista de símbolos
     * pertence a uma declaração ou não.
     * @param simbolos Os símbolos que fazem parte da lista de argumentos
     * de uma chamada ou declaração de função.
     * @returns `true` se parâmetros são de declaração. `false` caso contrário.
     */
    testePrimeiroParametro(simbolos) {
        let atual = 0;
        // Primeiro teste: literal ou identificador
        if ([lexico_regular_1.default.INTEIRO, lexico_regular_1.default.LOGICO, lexico_regular_1.default.REAL, lexico_regular_1.default.TEXTO].includes(simbolos[atual].tipo)) {
            return false;
        }
        // Segundo teste: vírgula imediatamente após identificador,
        // ou simplesmente fim da lista de símbolos.
        atual++;
        if (atual === simbolos.length || simbolos[atual].tipo === lexico_regular_1.default.VIRGULA) {
            return false;
        }
        // Outros casos: dois-pontos após identificador, etc.
        return true;
    }
    /**
     * Retorna uma declaração de função iniciada por igual,
     * ou seja, com apenas uma instrução.
     * @param simboloPrimario O símbolo que identifica a função (nome),
     *                        também usado para fins de pragma.
     * @param parametros A lista de parâmetros da função.
     * @param tipoRetorno O tipo de retorno da função.
     * @returns Um construto do tipo `FuncaoDeclaracao`.
     */
    declaracaoFuncaoPotigolIniciadaPorIgual(simboloPrimario, parametros, tipoRetorno) {
        const corpo = new construtos_1.FuncaoConstruto(simboloPrimario.hashArquivo, simboloPrimario.linha, parametros, [
            new declaracoes_1.Retorna(simboloPrimario, this.expressao()),
        ]);
        if (tipoRetorno) {
            corpo.tipo = tipoRetorno.lexema;
        }
        return new declaracoes_1.FuncaoDeclaracao(simboloPrimario, corpo, tipoRetorno ? tipoRetorno.lexema : 'qualquer');
    }
    /**
     * Retorna uma declaração de função terminada por fim,
     * ou seja, com mais de uma instrução.
     * @param simboloPrimario O símbolo que identifica a função (nome).
     * @param parenteseEsquerdo O parêntese esquerdo, usado para fins de pragma.
     * @param parametros A lista de parâmetros da função.
     * @param tipoRetorno O tipo de retorno da função.
     * @returns Um construto do tipo `FuncaoDeclaracao`.
     */
    declaracaoFuncaoPotigolTerminadaPorFim(simboloPrimario, parenteseEsquerdo, parametros, tipoRetorno) {
        const corpo = this.corpoDaFuncao(simboloPrimario.lexema, parenteseEsquerdo, parametros);
        if (tipoRetorno) {
            corpo.tipo = tipoRetorno.lexema;
        }
        return new declaracoes_1.FuncaoDeclaracao(simboloPrimario, corpo, tipoRetorno.lexema);
    }
    corpoDaFuncao(nomeFuncao, simboloPragma, parametros) {
        const corpo = this.blocoEscopo();
        return new construtos_1.FuncaoConstruto(this.hashArquivo, Number(simboloPragma.linha), parametros, corpo);
    }
    declaracaoDeFuncaoOuMetodo(construtoPrimario) {
        // O parêntese esquerdo é considerado o símbolo inicial para
        // fins de pragma.
        const parenteseEsquerdo = this.avancarEDevolverAnterior();
        const simbolosEntreParenteses = [];
        while (!this.verificarTipoSimboloAtual(lexico_regular_1.default.PARENTESE_DIREITO)) {
            simbolosEntreParenteses.push(this.avancarEDevolverAnterior());
        }
        const resolucaoParametros = this.logicaComumParametrosPotigol(simbolosEntreParenteses);
        this.consumir(lexico_regular_1.default.PARENTESE_DIREITO, "Esperado ')' após parâmetros.");
        // Pode haver uma dica do tipo de retorno ou não.
        // Se houver, é uma declaração de função (verificado mais abaixo).
        let tipoRetorno = undefined;
        if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.DOIS_PONTOS)) {
            this.verificacaoTipo(this.simbolos[this.atual], 'Esperado tipo válido após dois-pontos como retorno de função.');
            tipoRetorno = this.avancarEDevolverAnterior();
        }
        // Se houver símbolo de igual, seja após fechamento de parênteses,
        // seja após a dica de retorno, é uma declaração de função.
        if (this.simbolos[this.atual].tipo === lexico_regular_1.default.IGUAL) {
            this.avancarEDevolverAnterior();
            return this.declaracaoFuncaoPotigolIniciadaPorIgual(construtoPrimario.simbolo, resolucaoParametros.parametros, tipoRetorno);
        }
        return this.declaracaoFuncaoPotigolTerminadaPorFim(construtoPrimario.simbolo, parenteseEsquerdo, resolucaoParametros.parametros, tipoRetorno);
    }
    finalizarChamada(entidadeChamada) {
        const simbolosEntreParenteses = [];
        while (!this.verificarTipoSimboloAtual(lexico_regular_1.default.PARENTESE_DIREITO)) {
            simbolosEntreParenteses.push(this.avancarEDevolverAnterior());
        }
        this.consumir(lexico_regular_1.default.PARENTESE_DIREITO, "Esperado ')' após parâmetros.");
        const argumentos = this.microAvaliadorSintatico.analisar({ simbolos: simbolosEntreParenteses }, entidadeChamada.linha);
        return new construtos_1.Chamada(this.hashArquivo, entidadeChamada, argumentos.declaracoes.filter((d) => d));
    }
    /**
     * Verificação comum de tipos.
     * Avança o símbolo se não houver erros.
     * @param simbolo O símbolo sendo analisado.
     * @param mensagemErro A mensagem de erro caso o símbolo atual não seja de tipo.
     */
    verificacaoTipo(simbolo, mensagemErro) {
        if (![lexico_regular_1.default.INTEIRO, lexico_regular_1.default.LOGICO, lexico_regular_1.default.REAL, lexico_regular_1.default.TEXTO].includes(simbolo.tipo)) {
            throw this.erro(simbolo, mensagemErro);
        }
    }
    logicaComumParametrosPotigol(simbolos) {
        const parametros = [];
        let indice = 0;
        let tipagemDefinida = false;
        while (indice < simbolos.length) {
            if (parametros.length >= 255) {
                this.erro(simbolos[indice], 'Não pode haver mais de 255 parâmetros');
            }
            const parametro = {};
            // TODO: verificar se Potigol trabalha com número variável de parâmetros.
            /* if (this.simbolos[this.atual].tipo === tiposDeSimbolos.MULTIPLICACAO) {
                this.consumir(tiposDeSimbolos.MULTIPLICACAO, null);
                parametro.abrangencia = 'multiplo';
            } else {
                parametro.abrangencia = 'padrao';
            } */
            parametro.abrangencia = 'padrao';
            if (simbolos[indice].tipo !== lexico_regular_1.default.IDENTIFICADOR) {
                throw this.erro(simbolos[indice], 'Esperado nome do parâmetro.');
            }
            parametro.nome = simbolos[indice];
            indice++;
            if (simbolos[indice].tipo === lexico_regular_1.default.DOIS_PONTOS) {
                indice++;
                this.verificacaoTipo(simbolos[indice], 'Esperado tipo do argumento após dois-pontos, em definição de função.');
                const tipoParametro = simbolos[indice];
                const resolucaoTipo = this.tiposPotigolParaDelegua[tipoParametro.lexema];
                parametro.tipoDado = resolucaoTipo;
                tipagemDefinida = true;
            }
            // TODO: Verificar se Potigol trabalha com valores padrão em argumentos.
            /* if (this.verificarSeSimboloAtualEIgualA(tiposDeSimbolos.IGUAL)) {
                parametro.valorPadrao = this.primario();
            } */
            parametros.push(parametro);
            // if (parametro.abrangencia === 'multiplo') break;
            indice++;
            if (indice < simbolos.length && simbolos[indice].tipo !== lexico_regular_1.default.VIRGULA) {
                throw this.erro(simbolos[indice], 'Esperado vírgula entre parâmetros de função.');
            }
            indice++;
        }
        return {
            parametros,
            tipagemDefinida,
        };
    }
    logicaLeiaMultiplo() {
        const simboloLeiaMultiplo = this.avancarEDevolverAnterior();
        this.consumir(lexico_regular_1.default.PARENTESE_ESQUERDO, `Esperado parêntese esquerdo após ${simboloLeiaMultiplo.lexema}.`);
        const argumento = this.expressao();
        this.consumir(lexico_regular_1.default.PARENTESE_DIREITO, `Esperado parêntese direito após número de parâmetros em chamada de ${simboloLeiaMultiplo.lexema}.`);
        switch (simboloLeiaMultiplo.tipo) {
            case lexico_regular_1.default.LEIA_INTEIROS:
                return new declaracoes_2.LeiaInteiros(simboloLeiaMultiplo, argumento);
            case lexico_regular_1.default.LEIA_REAIS:
                return new declaracoes_2.LeiaReais(simboloLeiaMultiplo, argumento);
            case lexico_regular_1.default.LEIA_TEXTOS:
                return new declaracoes_2.LeiaTextos(simboloLeiaMultiplo, argumento);
        }
    }
    primario() {
        const simboloAtual = this.simbolos[this.atual];
        switch (simboloAtual.tipo) {
            case lexico_regular_1.default.PARENTESE_ESQUERDO:
                this.avancarEDevolverAnterior();
                const expressao = this.ou();
                switch (this.simbolos[this.atual].tipo) {
                    case lexico_regular_1.default.VIRGULA:
                        // Tupla
                        const argumentos = [expressao];
                        while (this.simbolos[this.atual].tipo === lexico_regular_1.default.VIRGULA) {
                            this.avancarEDevolverAnterior();
                            argumentos.push(this.ou());
                        }
                        this.consumir(lexico_regular_1.default.PARENTESE_DIREITO, "Esperado ')' após a expressão.");
                        return new tuplas_1.SeletorTuplas(...argumentos);
                    default:
                        this.consumir(lexico_regular_1.default.PARENTESE_DIREITO, "Esperado ')' após a expressão.");
                        return new construtos_1.Agrupamento(this.hashArquivo, Number(simboloAtual.linha), expressao);
                }
            case lexico_regular_1.default.COLCHETE_ESQUERDO:
                this.avancarEDevolverAnterior();
                let valores = [];
                if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.COLCHETE_DIREITO)) {
                    return new construtos_1.Vetor(this.hashArquivo, Number(simboloAtual.linha), []);
                }
                while (!this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.COLCHETE_DIREITO)) {
                    const valor = this.atribuir();
                    valores.push(valor);
                    if (this.simbolos[this.atual].tipo !== lexico_regular_1.default.COLCHETE_DIREITO) {
                        this.consumir(lexico_regular_1.default.VIRGULA, 'Esperado vírgula antes da próxima expressão.');
                    }
                }
                return new construtos_1.Vetor(this.hashArquivo, Number(simboloAtual.linha), valores);
            case lexico_regular_1.default.CARACTERE:
            case lexico_regular_1.default.INTEIRO:
            case lexico_regular_1.default.LOGICO:
            case lexico_regular_1.default.REAL:
            case lexico_regular_1.default.TEXTO:
                const simboloLiteral = this.avancarEDevolverAnterior();
                const dicionarioTiposDelegua = {
                    'CARACTERE': 'texto',
                    'INTEIRO': 'inteiro',
                    'LOGICO': 'lógico',
                    'REAL': 'número',
                    'TEXTO': 'texto'
                };
                return new construtos_1.Literal(this.hashArquivo, Number(simboloLiteral.linha), simboloLiteral.literal, dicionarioTiposDelegua[simboloLiteral.tipo]);
            case lexico_regular_1.default.FALSO:
            case lexico_regular_1.default.VERDADEIRO:
                const simboloVerdadeiroFalso = this.avancarEDevolverAnterior();
                return new construtos_1.Literal(this.hashArquivo, Number(simboloVerdadeiroFalso.linha), simboloVerdadeiroFalso.tipo === lexico_regular_1.default.VERDADEIRO, 'lógico');
            case lexico_regular_1.default.LEIA_INTEIRO:
                const simboloLeiaInteiro = this.avancarEDevolverAnterior();
                return new declaracoes_2.LeiaInteiro(simboloLeiaInteiro, []);
            case lexico_regular_1.default.LEIA_REAL:
                const simboloLeiaReal = this.avancarEDevolverAnterior();
                return new declaracoes_2.LeiaReal(simboloLeiaReal, []);
            case lexico_regular_1.default.LEIA_TEXTO:
                const simboloLeiaTexto = this.avancarEDevolverAnterior();
                return new declaracoes_2.LeiaTexto(simboloLeiaTexto, []);
            case lexico_regular_1.default.LEIA_INTEIROS:
            case lexico_regular_1.default.LEIA_REAIS:
            case lexico_regular_1.default.LEIA_TEXTOS:
                return this.logicaLeiaMultiplo();
            default:
                const simboloIdentificador = this.avancarEDevolverAnterior();
                return new construtos_2.ConstanteOuVariavel(this.hashArquivo, simboloIdentificador);
        }
    }
    formato() {
        const expressao = this.primario();
        if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.FORMATO)) {
            // O próximo símbolo precisa ser um texto no padrão "%Nd" ou "%.Nf", onde N é um inteiro.
            const simboloMascaraFormato = this.consumir(lexico_regular_1.default.TEXTO, "Esperado máscara de formato após método 'formato'.");
            if (!/%((\d+)d|\.(\d+)f)/gi.test(simboloMascaraFormato.literal)) {
                throw this.erro(simboloMascaraFormato, 'Máscara para função de formato inválida.');
            }
            return new construtos_1.Chamada(this.hashArquivo, // new Expressao(new MetodoPrimitiva(expressao, primitivasNumero.formato)), undefined, [expressao]);
            new construtos_1.AcessoMetodoOuPropriedade(this.hashArquivo, expressao, new lexador_1.Simbolo(lexico_regular_1.default.FORMATO, 'formato', 'formato', expressao.linha, this.hashArquivo)), [new construtos_1.Literal(this.hashArquivo, expressao.linha, simboloMascaraFormato.literal)]);
        }
        return expressao;
    }
    /**
     * Concatenação de lista é expressa por dois símbolos de dois-pontos
     * em sequência
     * @returns Um construto, ou vindo da continuação da análise, ou um Binário.
     */
    concatenacaoLista() {
        let expressao = this.formato();
        if (this.atual < this.simbolos.length) {
            if (this.simbolos[this.atual].tipo === lexico_regular_1.default.DOIS_PONTOS &&
                this.verificarTipoProximoSimbolo(lexico_regular_1.default.DOIS_PONTOS)) {
                const primeiroDoisPontos = this.avancarEDevolverAnterior();
                this.avancarEDevolverAnterior();
                const ladoDireito = this.formato();
                // Como aqui precisamos resolver se o lado direito é constante ou variável,
                // e a concatenação funciona para o operando direito apenas como leitura,
                // é seguro emitir um construto de constante aqui.
                if (!(ladoDireito instanceof construtos_2.ConstanteOuVariavel)) {
                    throw this.erro(primeiroDoisPontos, 'Operando direito de uma concatenação de lista não parece ser uma constante ou variável.');
                }
                const ladoDireitoComoConstante = new construtos_1.Constante(ladoDireito.hashArquivo, ladoDireito.simbolo);
                expressao = new construtos_1.Binario(this.hashArquivo, expressao, new lexador_1.Simbolo(lexico_regular_1.default.CONCATENACAO_LISTA, '::', '::', primeiroDoisPontos.linha, primeiroDoisPontos.hashArquivo), ladoDireitoComoConstante);
            }
        }
        return expressao;
    }
    /**
     * Em Potigol, só é possível determinar a diferença entre uma chamada e uma
     * declaração de função depois dos argumentos.
     *
     * Chamadas não aceitam dicas de tipos de parâmetros.
     * @returns Um construto do tipo `AcessoMetodo`, `AcessoIndiceVariavel` ou `Constante`,
     * dependendo dos símbolos encontrados.
     */
    chamar() {
        let expressao = this.concatenacaoLista();
        while (true) {
            if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.PARENTESE_ESQUERDO)) {
                if (expressao instanceof construtos_2.ConstanteOuVariavel) {
                    expressao = new construtos_1.Constante(expressao.hashArquivo, expressao.simbolo);
                }
                expressao = this.finalizarChamada(expressao);
            }
            else if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.PONTO)) {
                if (this.verificarTipoSimboloAtual(lexico_regular_1.default.QUAL_TIPO)) {
                    const identificador = this.simbolos[this.atual - 2];
                    const simbolo = this.simbolos[this.atual];
                    const valor = expressao ? expressao : identificador.lexema;
                    this.avancarEDevolverAnterior();
                    return new qual_tipo_1.QualTipo(this.hashArquivo, simbolo, valor);
                }
                else {
                    const nome = this.consumir(lexico_regular_1.default.IDENTIFICADOR, "Esperado nome do método após '.'.");
                    const variavelMetodo = new construtos_1.Variavel(expressao.hashArquivo, expressao.simbolo);
                    expressao = new construtos_1.AcessoMetodoOuPropriedade(this.hashArquivo, variavelMetodo, nome);
                }
            }
            else if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.COLCHETE_ESQUERDO)) {
                const indice = this.expressao();
                const simboloFechamento = this.consumir(lexico_regular_1.default.COLCHETE_DIREITO, "Esperado ']' após escrita do indice.");
                const variavelVetor = new construtos_1.Variavel(expressao.hashArquivo, expressao.simbolo);
                expressao = new construtos_1.AcessoIndiceVariavel(this.hashArquivo, variavelVetor, indice, simboloFechamento);
            }
            else {
                if (expressao instanceof construtos_2.ConstanteOuVariavel) {
                    // Neste ponto, precisamos resolver se identificador é uma variável ou
                    // constante.
                    // Se houver menções a variáveis neste escopo ou em escopos anteriores,
                    // consideramos a expressão como variável.
                    // Caso contrário, consideramos como constante.
                    if (this.pilhaEscoposVariaveisConhecidas.variavelExiste(expressao.simbolo.lexema)) {
                        expressao = new construtos_1.Variavel(expressao.hashArquivo, expressao.simbolo);
                    }
                    else {
                        expressao = new construtos_1.Constante(expressao.hashArquivo, expressao.simbolo);
                    }
                }
                break;
            }
        }
        return expressao;
    }
    comparacaoIgualdade() {
        let expressao = this.comparar();
        while (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.DIFERENTE, lexico_regular_1.default.IGUAL_IGUAL)) {
            const operador = this.simbolos[this.atual - 1];
            const direito = this.comparar();
            expressao = new construtos_1.Binario(this.hashArquivo, expressao, operador, direito);
        }
        return expressao;
    }
    /**
     * Em Potigol, `escreva` aceita apenas um argumento.
     * @returns Uma declaração `Escreva`.
     */
    declaracaoEscreva() {
        const simboloAtual = this.avancarEDevolverAnterior();
        const argumento = this.ou();
        return new declaracoes_1.Escreva(Number(simboloAtual.linha), simboloAtual.hashArquivo, [argumento]);
    }
    /**
     * Em Potigol, `imprima` aceita apenas um argumento.
     * @returns Uma declaração `EscrevaMesmaLinha`, já que `imprima` em Potigol escreve
     * o resultado na saída na mesma linha.
     * @see https://potigol.github.io/docs/basico/entrada_saida.html
     */
    declaracaoImprima() {
        const simboloAtual = this.avancarEDevolverAnterior();
        const argumento = this.ou();
        return new declaracoes_1.EscrevaMesmaLinha(Number(simboloAtual.linha), simboloAtual.hashArquivo, [argumento]);
    }
    /**
     * Blocos de escopo em Potigol existem quando:
     *
     * - Em uma declaração de função ou método, após fecha parênteses, o próximo
     * símbolo obrigatório não é `=` e há pelo menos um `fim` até o final do código;
     * - Em uma declaração `se`;
     * - Em uma declaração `enquanto`;
     * - Em uma declaração `para`.
     * @returns Um vetor de `Declaracao`.
     */
    blocoEscopo() {
        let declaracoes = [];
        this.pilhaEscoposVariaveisConhecidas.empilhar([]);
        while (!this.estaNoFinal() && !this.verificarTipoSimboloAtual(lexico_regular_1.default.FIM)) {
            const retornoDeclaracao = this.resolverDeclaracaoForaDeBloco();
            if (Array.isArray(retornoDeclaracao)) {
                declaracoes = declaracoes.concat(retornoDeclaracao);
            }
            else {
                declaracoes.push(retornoDeclaracao);
            }
        }
        this.pilhaEscoposVariaveisConhecidas.removerUltimo();
        return declaracoes;
    }
    declaracaoSe() {
        const simboloSe = this.avancarEDevolverAnterior();
        const condicao = this.expressao();
        this.consumir(lexico_regular_1.default.ENTAO, "Esperado palavra reservada 'entao' após condição em declaração 'se'.");
        const declaracoes = [];
        do {
            declaracoes.push(this.resolverDeclaracaoForaDeBloco());
        } while (![lexico_regular_1.default.SENAO, lexico_regular_1.default.FIM].includes(this.simbolos[this.atual].tipo));
        let caminhoSenao = null;
        if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.SENAO)) {
            const simboloSenao = this.simbolos[this.atual - 1];
            const declaracoesSenao = [];
            do {
                declaracoesSenao.push(this.resolverDeclaracaoForaDeBloco());
            } while (![lexico_regular_1.default.FIM].includes(this.simbolos[this.atual].tipo));
            caminhoSenao = new declaracoes_1.Bloco(this.hashArquivo, Number(simboloSenao.linha), declaracoesSenao.filter((d) => d));
        }
        this.consumir(lexico_regular_1.default.FIM, "Esperado palavra-chave 'fim' para fechamento de declaração 'se'.");
        return new declaracoes_1.Se(condicao, new declaracoes_1.Bloco(this.hashArquivo, Number(simboloSe.linha), declaracoes.filter((d) => d)), [], caminhoSenao);
    }
    declaracaoEnquanto() {
        const simboloAtual = this.avancarEDevolverAnterior();
        const condicao = this.expressao();
        this.consumir(lexico_regular_1.default.FACA, "Esperado paravra reservada 'faca' após condição de continuidade em declaracão 'enquanto'.");
        const declaracoes = [];
        do {
            declaracoes.push(this.resolverDeclaracaoForaDeBloco());
        } while (![lexico_regular_1.default.FIM].includes(this.simbolos[this.atual].tipo));
        this.consumir(lexico_regular_1.default.FIM, "Esperado palavra-chave 'fim' para fechamento de declaração 'enquanto'.");
        return new declaracoes_1.Enquanto(condicao, new declaracoes_1.Bloco(simboloAtual.hashArquivo, Number(simboloAtual.linha), declaracoes.filter((d) => d)));
    }
    declaracaoPara() {
        const simboloPara = this.avancarEDevolverAnterior();
        const variavelIteracao = this.consumir(lexico_regular_1.default.IDENTIFICADOR, "Esperado identificador de variável após 'para'.");
        this.consumir(lexico_regular_1.default.DE, "Esperado palavra reservada 'de' após variável de controle de 'para'.");
        const literalOuVariavelInicio = this.adicaoOuSubtracao();
        this.consumir(lexico_regular_1.default.ATE, "Esperado palavra reservada 'ate' após valor inicial do laço de repetição 'para'.");
        const literalOuVariavelFim = this.adicaoOuSubtracao();
        let operadorCondicao = new lexador_1.Simbolo(lexico_regular_1.default.MENOR_IGUAL, '<=', null, Number(simboloPara.linha), this.hashArquivo);
        let operadorCondicaoIncremento = new lexador_1.Simbolo(lexico_regular_1.default.MENOR, '<', null, Number(simboloPara.linha), this.hashArquivo);
        // Isso existe porque o laço `para` do Potigol pode ter o passo positivo ou negativo
        // dependendo dos operandos de início e fim, que só são possíveis de determinar
        // em tempo de execução.
        // Quando um dos operandos é uma variável, tanto a condição do laço quanto o
        // passo são considerados indefinidos aqui.
        let passo;
        let resolverIncrementoEmExecucao = false;
        if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.PASSO)) {
            passo = this.unario();
        }
        else {
            if (literalOuVariavelInicio instanceof construtos_1.Literal && literalOuVariavelFim instanceof construtos_1.Literal) {
                if (literalOuVariavelInicio.valor > literalOuVariavelFim.valor) {
                    passo = new construtos_1.Unario(this.hashArquivo, new lexador_1.Simbolo(lexico_regular_1.default.SUBTRACAO, '-', undefined, simboloPara.linha, simboloPara.hashArquivo), new construtos_1.Literal(this.hashArquivo, Number(simboloPara.linha), 1), 'ANTES');
                    operadorCondicao = new lexador_1.Simbolo(lexico_regular_1.default.MAIOR_IGUAL, '>=', null, Number(simboloPara.linha), this.hashArquivo);
                    operadorCondicaoIncremento = new lexador_1.Simbolo(lexico_regular_1.default.MAIOR, '>', null, Number(simboloPara.linha), this.hashArquivo);
                }
                else {
                    passo = new construtos_1.Literal(this.hashArquivo, Number(simboloPara.linha), 1);
                }
            }
            else {
                // Passo e operador de condição precisam ser resolvidos em tempo de execução.
                passo = undefined;
                operadorCondicao = undefined;
                operadorCondicaoIncremento = undefined;
                resolverIncrementoEmExecucao = true;
            }
        }
        this.consumir(lexico_regular_1.default.FACA, "Esperado palavra reservada 'faca' após valor final do laço de repetição 'para'.");
        const declaracoesBlocoPara = [];
        let simboloAtualBlocoPara = this.simbolos[this.atual];
        while (simboloAtualBlocoPara.tipo !== lexico_regular_1.default.FIM) {
            declaracoesBlocoPara.push(this.resolverDeclaracaoForaDeBloco());
            simboloAtualBlocoPara = this.simbolos[this.atual];
        }
        this.consumir(lexico_regular_1.default.FIM, '');
        const corpo = new declaracoes_1.Bloco(this.hashArquivo, Number(simboloPara.linha) + 1, declaracoesBlocoPara.filter((d) => d));
        const para = new declaracoes_1.Para(this.hashArquivo, Number(simboloPara.linha), new construtos_1.Atribuir(this.hashArquivo, new construtos_1.Variavel(this.hashArquivo, variavelIteracao, 'inteiro'), literalOuVariavelInicio), new construtos_1.Binario(this.hashArquivo, new construtos_1.Variavel(this.hashArquivo, variavelIteracao), operadorCondicao, literalOuVariavelFim), new construtos_1.FimPara(this.hashArquivo, Number(simboloPara.linha), new construtos_1.Binario(this.hashArquivo, new construtos_1.Variavel(this.hashArquivo, variavelIteracao), operadorCondicaoIncremento, literalOuVariavelFim), new declaracoes_1.Expressao(new construtos_1.Atribuir(this.hashArquivo, new construtos_1.Variavel(this.hashArquivo, variavelIteracao, 'inteiro'), new construtos_1.Binario(this.hashArquivo, new construtos_1.Variavel(this.hashArquivo, variavelIteracao), new lexador_1.Simbolo(lexico_regular_1.default.ADICAO, '+', null, Number(simboloPara.linha), this.hashArquivo), passo)))), corpo);
        para.blocoPosExecucao = corpo;
        para.resolverIncrementoEmExecucao = resolverIncrementoEmExecucao;
        return para;
    }
    declaracaoEscolha() {
        this.avancarEDevolverAnterior();
        const condicao = this.expressao();
        const caminhos = [];
        let caminhoPadrao = null;
        while (!this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.FIM)) {
            this.consumir(lexico_regular_1.default.CASO, "Esperado palavra reservada 'caso' após condição de 'escolha'.");
            if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.TRACO_BAIXO)) {
                // Caso padrão
                if (caminhoPadrao !== null) {
                    const excecao = new erro_avaliador_sintatico_1.ErroAvaliadorSintatico(this.simbolos[this.atual], "Você só pode ter um caminho padrão em cada declaração de 'escolha'.");
                    this.erros.push(excecao);
                    throw excecao;
                }
                this.consumir(lexico_regular_1.default.SETA, "Esperado '=>' após palavra reservada 'caso'.");
                const declaracoesPadrao = [this.resolverDeclaracaoForaDeBloco()];
                // TODO: Verificar se Potigol admite bloco de escopo para `escolha`.
                /* const declaracoesPadrao = [];
                do {
                    declaracoesPadrao.push(this.declaracao());
                } while (!this.verificarSeSimboloAtualEIgualA(tiposDeSimbolos.CASO, tiposDeSimbolos.FIM)); */
                caminhoPadrao = {
                    declaracoes: declaracoesPadrao,
                };
                continue;
            }
            const caminhoCondicoes = [this.expressao()];
            this.consumir(lexico_regular_1.default.SETA, "Esperado '=>' após palavra reservada 'caso'.");
            const declaracoes = [this.resolverDeclaracaoForaDeBloco()];
            // TODO: Verificar se Potigol admite bloco de escopo para `escolha`.
            /* const declaracoes = [];
            do {
                declaracoes.push(this.declaracao());
            } while (!this.verificarSeSimboloAtualEIgualA(tiposDeSimbolos.CASO, tiposDeSimbolos.FIM)); */
            caminhos.push({
                condicoes: caminhoCondicoes,
                declaracoes,
            });
        }
        return new declaracoes_1.Escolha(condicao, caminhos, caminhoPadrao);
    }
    declaracaoDeConstantes(primeiroIdentificador) {
        // Normalmente o símbolo atual aqui será uma vírgula.
        this.avancarEDevolverAnterior();
        const identificadores = [primeiroIdentificador.simbolo];
        let tipo = null;
        do {
            identificadores.push(this.consumir(lexico_regular_1.default.IDENTIFICADOR, 'Esperado nome da constante.'));
        } while (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.VIRGULA));
        // TODO: Aparentemente, não é possível definir tipo para atribuição
        // múltipla de constantes. Se algo mudar nisso, o código abaixo poderá
        // voltar a ser usado.
        /* if (this.verificarSeSimboloAtualEIgualA(tiposDeSimbolos.DOIS_PONTOS)) {
            const tipoConstante = this.verificarDefinicaoTipoAtual();
            if (!tipoConstante) {
                throw this.erro(this.simboloAtual(), 'Tipo definido na constante não é válido.');
            }
            tipo = tipoConstante;
            this.avancarEDevolverAnterior();
        } */
        this.consumir(lexico_regular_1.default.IGUAL, "Esperado '=' após identificador em instrução 'constante'.");
        const inicializadores = [];
        do {
            let inicializador = this.expressao();
            if (identificadores.length > 1 && ['LeiaInteiro', 'LeiaReal', 'LeiaTexto'].includes(inicializador.constructor.name)) {
                switch (inicializador.constructor.name) {
                    case 'LeiaInteiro':
                        const inicializadorTipadoInteiro = inicializador;
                        inicializador = new declaracoes_2.LeiaInteiros(inicializadorTipadoInteiro.simbolo, new construtos_1.Literal(this.hashArquivo, Number(inicializadorTipadoInteiro.simbolo.linha), identificadores.length));
                        break;
                    case 'LeiaReal':
                        const inicializadorTipadoReal = inicializador;
                        inicializador = new declaracoes_2.LeiaReais(inicializadorTipadoReal.simbolo, new construtos_1.Literal(this.hashArquivo, Number(inicializadorTipadoReal.simbolo.linha), identificadores.length));
                        break;
                    case 'LeiaTexto':
                        const inicializadorTipadoTexto = inicializador;
                        inicializador = new declaracoes_2.LeiaTextos(inicializadorTipadoTexto.simbolo, new construtos_1.Literal(this.hashArquivo, Number(inicializadorTipadoTexto.simbolo.linha), identificadores.length));
                        break;
                }
            }
            inicializadores.push(inicializador);
        } while (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.VIRGULA));
        if (identificadores.length !== inicializadores.length) {
            // Pode ser que a inicialização seja feita por uma das
            // funções `leia`, que podem ler vários valores. Neste caso, não deve dar erro.
            if (!(inicializadores.length === 1 && ['LeiaInteiros', 'LeiaReais', 'LeiaTextos'].includes(inicializadores[0].constructor.name))) {
                throw this.erro(this.simbolos[this.atual], 'Quantidade de identificadores à esquerda do igual é diferente da quantidade de valores à direita.');
            }
            let tipoConversao;
            switch (inicializadores[0].constructor.name) {
                case 'LeiaInteiros':
                    tipoConversao = 'inteiro[]';
                    break;
                case 'LeiaInteiro':
                    tipoConversao = 'inteiro';
                    break;
                case 'LeiaReais':
                    tipoConversao = 'real[]';
                    break;
                case 'LeiaReal':
                    tipoConversao = 'real';
                    break;
                case 'LeiaTextos':
                    tipoConversao = 'texto[]';
                    break;
                case 'LeiaTexto':
                    tipoConversao = 'texto';
                    break;
                default:
                    tipoConversao = 'qualquer';
                    break;
            }
            return new declaracoes_1.ConstMultiplo(identificadores, inicializadores[0], tipoConversao);
        }
        let retorno = [];
        for (let [indice, identificador] of identificadores.entries()) {
            retorno.push(new declaracoes_1.Const(identificador, inicializadores[indice], tipo));
        }
        return retorno;
    }
    /**
     * Este método contempla dois cenários:
     *
     * - A atribuição de variáveis em si (o primeiro símbolo é a palavra reservada `var`);
     * - Uma reatribuição de uma ou mais variáveis (o primeiro símbolo a ser lido é uma
     * vírgula, e o primeiro identificador é passado como argumento). Neste caso, não há
     * a palavra reservada `var`.
     * @param primeiroIdentificador Um construto de variável. É defiido em reatribuições.
     * @returns Um vetor de declarações `Var`.
     */
    declaracaoDeVariaveisPotigol(primeiroIdentificador) {
        const identificadores = [];
        let simboloVar;
        // Se houver primeiro identificador definido (reatribuição),
        // o símbolo atual aqui será uma vírgula.
        if (primeiroIdentificador) {
            this.avancarEDevolverAnterior();
            identificadores.push(primeiroIdentificador.simbolo);
        }
        else {
            simboloVar = this.avancarEDevolverAnterior();
        }
        do {
            identificadores.push(this.consumir(lexico_regular_1.default.IDENTIFICADOR, 'Esperado nome de variável.'));
        } while (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.VIRGULA));
        this.consumir(lexico_regular_1.default.REATRIBUIR, "Esperado ':=' após identificador em instrução 'var'.");
        const inicializadores = [];
        do {
            inicializadores.push(this.expressao());
        } while (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.VIRGULA));
        if (identificadores.length !== inicializadores.length) {
            throw this.erro(simboloVar, 'Quantidade de identificadores à esquerda do igual é diferente da quantidade de valores à direita.');
        }
        const retorno = [];
        const escopoAtual = this.pilhaEscoposVariaveisConhecidas.topoDaPilha();
        for (let [indice, identificador] of identificadores.entries()) {
            retorno.push(new declaracoes_1.Var(identificador, inicializadores[indice]));
            escopoAtual.push(identificador.lexema);
        }
        return retorno;
    }
    logicaAtribuicaoComDicaDeTipo(expressao) {
        // A dica de tipo é opcional.
        // Só que, se a avaliação entra na dica, só
        // podemos ter uma constante apenas.
        this.avancarEDevolverAnterior();
        if (![
            lexico_regular_1.default.CARACTERE,
            lexico_regular_1.default.INTEIRO,
            lexico_regular_1.default.LOGICO,
            lexico_regular_1.default.LÓGICO,
            lexico_regular_1.default.REAL,
            lexico_regular_1.default.TEXTO,
        ].includes(this.simbolos[this.atual].tipo)) {
            throw this.erro(this.simbolos[this.atual], 'Esperado tipo após dois-pontos e nome de identificador.');
        }
        return this.avancarEDevolverAnterior();
    }
    declaracaoFazer() {
        throw new Error('Método não implementado.');
    }
    /**
     * Uma declaração de tipo nada mais é do que um declaração de classe.
     * Em Potigol, classe e tipo são praticamente a mesma coisa.
     *
     * @returns Um construto do tipo `Classe`.
     */
    declaracaoTipo() {
        const simboloTipo = this.avancarEDevolverAnterior();
        const construto = this.primario();
        // TODO: Verificar se Potigol trabalha com herança.
        /* let superClasse = null;
        if (this.verificarSeSimboloAtualEIgualA(tiposDeSimbolos.HERDA)) {
            this.consumir(tiposDeSimbolos.IDENTIFICADOR, 'Esperado nome da Superclasse.');
            superClasse = new Variavel(this.hashArquivo, this.simbolos[this.atual - 1]);
        } */
        const metodos = [];
        const propriedades = [];
        while (!this.verificarTipoSimboloAtual(lexico_regular_1.default.FIM) && !this.estaNoFinal()) {
            const identificador = this.consumir(lexico_regular_1.default.IDENTIFICADOR, 'Esperado nome de propriedade ou método.');
            if (this.simbolos[this.atual].tipo === lexico_regular_1.default.PARENTESE_ESQUERDO) {
                // Método
                const construtoMetodo = new construtos_1.Constante(identificador.hashArquivo, identificador);
                metodos.push(this.declaracaoDeFuncaoOuMetodo(construtoMetodo));
            }
            else {
                // Propriedade
                this.consumir(lexico_regular_1.default.DOIS_PONTOS, 'Esperado dois-pontos após nome de propriedade em declaração de tipo.');
                this.verificacaoTipo(this.simbolos[this.atual], 'Esperado tipo do argumento após dois-pontos, em definição de função.');
                const tipoPropriedade = this.avancarEDevolverAnterior();
                propriedades.push(new declaracoes_1.PropriedadeClasse(identificador, this.tiposPotigolParaDelegua[tipoPropriedade.lexema]));
            }
        }
        this.consumir(lexico_regular_1.default.FIM, "Esperado 'fim' após o escopo do tipo.");
        // Depois de verificadas todas as propriedades anotadas com tipo,
        // Precisamos gerar um construtor com todas elas na ordem em que
        // foram lidas.
        const instrucoesConstrutor = [];
        for (let propriedade of propriedades) {
            instrucoesConstrutor.push(new declaracoes_1.Expressao(new construtos_1.DefinirValor(propriedade.hashArquivo, propriedade.linha, new construtos_1.Isto(propriedade.hashArquivo, propriedade.linha, new lexador_1.Simbolo(lexico_regular_1.default.ISTO, 'isto', undefined, simboloTipo.linha, simboloTipo.hashArquivo)), propriedade.nome, new construtos_1.Variavel(propriedade.hashArquivo, propriedade.nome))));
        }
        const construtorConstruto = new construtos_1.FuncaoConstruto(simboloTipo.hashArquivo, simboloTipo.linha, propriedades.map((p) => ({
            abrangencia: 'padrao',
            nome: p.nome,
        })), instrucoesConstrutor);
        const construtor = new declaracoes_1.FuncaoDeclaracao(new lexador_1.Simbolo(lexico_regular_1.default.CONSTRUTOR, 'construtor', undefined, simboloTipo.hashArquivo, simboloTipo.linha), construtorConstruto, undefined);
        metodos.unshift(construtor);
        return new declaracoes_1.Classe(construto.simbolo, undefined, metodos, propriedades);
    }
    atribuir() {
        const expressao = this.ou();
        if (!this.estaNoFinal()) {
            let tipoVariavelOuConstante;
            if (expressao instanceof construtos_1.Constante) {
                // Atribuição constante.
                if (this.simbolos[this.atual].tipo === lexico_regular_1.default.DOIS_PONTOS) {
                    tipoVariavelOuConstante = this.logicaAtribuicaoComDicaDeTipo(expressao);
                }
                switch (this.simbolos[this.atual].tipo) {
                    case lexico_regular_1.default.VIRGULA:
                        return this.declaracaoDeConstantes(expressao);
                    case lexico_regular_1.default.IGUAL:
                        this.avancarEDevolverAnterior();
                        const valorAtribuicao = this.ou();
                        return new declaracoes_1.Const(expressao.simbolo, valorAtribuicao, tipoVariavelOuConstante
                            ? this.tiposPotigolParaDelegua[tipoVariavelOuConstante.lexema]
                            : undefined);
                }
            }
            else if (expressao instanceof construtos_1.Variavel) {
                // Reatribuição de variável.
                switch (this.simbolos[this.atual].tipo) {
                    case lexico_regular_1.default.VIRGULA:
                        return this.declaracaoDeVariaveisPotigol(expressao);
                    case lexico_regular_1.default.REATRIBUIR:
                        this.avancarEDevolverAnterior();
                        const valorAtribuicao = this.ou();
                        return new declaracoes_2.ReatribuicaoVariavel(expressao.simbolo, valorAtribuicao, tipoVariavelOuConstante
                            ? this.tiposPotigolParaDelegua[tipoVariavelOuConstante.lexema]
                            : undefined);
                }
            }
        }
        return expressao;
    }
    /**
     * Em Potigol, uma definição de função normalmente começa com um
     * identificador - que não é uma palavra reservada - seguido de parênteses.
     * Este ponto de entrada verifica o símbolo atual e o próximo.
     *
     * Diferentemente dos demais dialetos, verificamos logo de cara se
     * temos uma definição ou chamada de função, isto porque definições
     * nunca aparecem do lado direito de uma atribuição, a não ser que
     * estejam entre parênteses (_currying_).
     *
     * Se o próximo símbolo for parênteses, ou é uma definiçao de função,
     * ou uma chamada de função.
     */
    expressaoOuDefinicaoFuncao() {
        if (!this.estaNoFinal() && this.simbolos[this.atual].tipo === lexico_regular_1.default.IDENTIFICADOR) {
            if (this.atual + 1 < this.simbolos.length) {
                switch (this.simbolos[this.atual + 1].tipo) {
                    case lexico_regular_1.default.PARENTESE_ESQUERDO:
                        const construtoPrimario = this.primario();
                        return this.declaracaoDeFuncaoOuMetodo(construtoPrimario);
                }
            }
        }
        return this.atribuir();
    }
    resolverDeclaracaoForaDeBloco() {
        const simboloAtual = this.simbolos[this.atual];
        switch (simboloAtual.tipo) {
            case lexico_regular_1.default.ENQUANTO:
                return this.declaracaoEnquanto();
            case lexico_regular_1.default.ESCOLHA:
                return this.declaracaoEscolha();
            case lexico_regular_1.default.ESCREVA:
                return this.declaracaoEscreva();
            case lexico_regular_1.default.IMPRIMA:
                return this.declaracaoImprima();
            case lexico_regular_1.default.PARA:
                return this.declaracaoPara();
            case lexico_regular_1.default.SE:
                return this.declaracaoSe();
            case lexico_regular_1.default.TIPO:
                return this.declaracaoTipo();
            case lexico_regular_1.default.VARIAVEL:
                return this.declaracaoDeVariaveisPotigol();
            default:
                return this.expressaoOuDefinicaoFuncao();
        }
    }
    analisar(retornoLexador, hashArquivo) {
        this.microAvaliadorSintatico = new micro_avaliador_sintatico_potigol_1.MicroAvaliadorSintaticoPotigol(hashArquivo);
        this.erros = [];
        this.atual = 0;
        this.blocos = 0;
        this.pilhaEscoposVariaveisConhecidas = new pilha_escopos_variaveis_conhecidas_1.PilhaEscoposVariaveisConhecidas();
        this.pilhaEscoposVariaveisConhecidas.empilhar([]);
        this.hashArquivo = hashArquivo || 0;
        this.simbolos = (retornoLexador === null || retornoLexador === void 0 ? void 0 : retornoLexador.simbolos) || [];
        this.declaracoes = [];
        while (!this.estaNoFinal()) {
            const retornoDeclaracao = this.resolverDeclaracaoForaDeBloco();
            if (Array.isArray(retornoDeclaracao)) {
                this.declaracoes = this.declaracoes.concat(retornoDeclaracao);
            }
            else {
                this.declaracoes.push(retornoDeclaracao);
            }
        }
        return {
            declaracoes: this.declaracoes,
            erros: this.erros,
        };
    }
}
exports.AvaliadorSintaticoPotigol = AvaliadorSintaticoPotigol;
//# sourceMappingURL=avaliador-sintatico-potigol.js.map