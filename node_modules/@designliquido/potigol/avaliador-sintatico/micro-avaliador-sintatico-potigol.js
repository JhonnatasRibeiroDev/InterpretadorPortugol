"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MicroAvaliadorSintaticoPotigol = void 0;
const construtos_1 = require("@designliquido/delegua/construtos");
const micro_avaliador_sintatico_base_1 = require("@designliquido/delegua/avaliador-sintatico/micro-avaliador-sintatico-base");
const tuplas_1 = require("@designliquido/delegua/construtos/tuplas");
const lexador_1 = require("@designliquido/delegua/lexador");
const micro_lexico_1 = __importDefault(require("../tipos-de-simbolos/micro-lexico"));
/**
 * O Micro Avaliador Sintático funciona em dois momentos:
 *
 * - Avaliação de elementos dentro de interpolações de texto (interpretador);
 * - Avaliação de argumentos de funções (avaliador sintático).
 */
class MicroAvaliadorSintaticoPotigol extends micro_avaliador_sintatico_base_1.MicroAvaliadorSintaticoBase {
    constructor(hashArquivo) {
        super();
        this.hashArquivo = hashArquivo;
        this.declaracoes = [];
    }
    primario() {
        const simboloAtual = this.simbolos[this.atual];
        switch (simboloAtual.tipo) {
            case micro_lexico_1.default.PARENTESE_ESQUERDO:
                this.avancarEDevolverAnterior();
                const expressao = this.ou();
                switch (this.simbolos[this.atual].tipo) {
                    case micro_lexico_1.default.VIRGULA:
                        // Tupla
                        const argumentos = [expressao];
                        while (this.simbolos[this.atual].tipo === micro_lexico_1.default.VIRGULA) {
                            this.avancarEDevolverAnterior();
                            argumentos.push(this.ou());
                        }
                        this.consumir(micro_lexico_1.default.PARENTESE_DIREITO, "Esperado ')' após a expressão.");
                        return new tuplas_1.SeletorTuplas(...argumentos);
                    default:
                        this.consumir(micro_lexico_1.default.PARENTESE_DIREITO, "Esperado ')' após a expressão.");
                        return new construtos_1.Agrupamento(this.hashArquivo, Number(simboloAtual.linha), expressao);
                }
            case micro_lexico_1.default.FORMATO:
            case micro_lexico_1.default.CARACTERE:
            case micro_lexico_1.default.INTEIRO:
            case micro_lexico_1.default.LOGICO:
            case micro_lexico_1.default.REAL:
            case micro_lexico_1.default.TEXTO:
                const simboloLiteral = this.avancarEDevolverAnterior();
                return new construtos_1.Literal(this.hashArquivo, Number(simboloLiteral.linha), simboloLiteral.literal);
            case micro_lexico_1.default.FALSO:
            case micro_lexico_1.default.VERDADEIRO:
                const simboloVerdadeiroFalso = this.avancarEDevolverAnterior();
                return new construtos_1.Literal(this.hashArquivo, Number(simboloVerdadeiroFalso.linha), simboloVerdadeiroFalso.tipo === micro_lexico_1.default.VERDADEIRO);
            case micro_lexico_1.default.VIRGULA:
                return undefined;
            default:
                const simboloIdentificador = this.avancarEDevolverAnterior();
                // Diferentemente da avaliação sintática tradicional, mesmo que o símbolo
                // seja uma variável, sempre resolve como constante.
                return new construtos_1.Constante(this.hashArquivo, simboloIdentificador);
        }
    }
    formato() {
        const expressao = this.primario();
        if (this.verificarSeSimboloAtualEIgualA(micro_lexico_1.default.FORMATO)) {
            // O próximo símbolo precisa ser um texto no padrão "%Nd" ou "%.Nf", onde N é um inteiro.
            const simboloMascaraFormato = this.consumir(micro_lexico_1.default.TEXTO, "Esperado máscara de formato após método 'formato'.");
            if (!/%((\d+)d|\.(\d+)f)/gi.test(simboloMascaraFormato.literal)) {
                throw this.erro(simboloMascaraFormato, 'Máscara para função de formato inválida.');
            }
            return new construtos_1.Chamada(this.hashArquivo, // new Expressao(new MetodoPrimitiva(expressao, primitivasNumero.formato)), undefined, [expressao]);
            new construtos_1.AcessoMetodoOuPropriedade(this.hashArquivo, expressao, new lexador_1.Simbolo(micro_lexico_1.default.FORMATO, 'formato', 'formato', expressao.linha, this.hashArquivo)), [new construtos_1.Literal(this.hashArquivo, expressao.linha, simboloMascaraFormato.literal)]);
        }
        return expressao;
    }
    chamar() {
        return this.formato();
    }
    analisar(retornoLexador, linha) {
        this.erros = [];
        this.atual = 0;
        this.linha = linha;
        this.simbolos = (retornoLexador === null || retornoLexador === void 0 ? void 0 : retornoLexador.simbolos) || [];
        this.declaracoes = [];
        while (this.atual < this.simbolos.length) {
            this.declaracoes.push(this.declaracao());
        }
        return {
            declaracoes: this.declaracoes,
            erros: this.erros,
        };
    }
}
exports.MicroAvaliadorSintaticoPotigol = MicroAvaliadorSintaticoPotigol;
//# sourceMappingURL=micro-avaliador-sintatico-potigol.js.map