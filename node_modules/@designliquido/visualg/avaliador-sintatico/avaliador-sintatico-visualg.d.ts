import { RetornoLexador, RetornoAvaliadorSintatico } from '@designliquido/delegua/interfaces/retornos';
import { AvaliadorSintaticoBase } from '@designliquido/delegua/avaliador-sintatico/avaliador-sintatico-base';
import { Aleatorio, Classe, Declaracao, Enquanto, Escolha, Escreva, EscrevaMesmaLinha, Fazer, FuncaoDeclaracao, Leia, Para, Retorna, Se } from '@designliquido/delegua/declaracoes';
import { Chamada, Construto, FuncaoConstruto, Comentario } from '@designliquido/delegua/construtos';
import { ParametroInterface, SimboloInterface } from '@designliquido/delegua/interfaces';
import { TipoDadosElementar } from '@designliquido/delegua/tipo-dados-elementar';
import { LimpaTela } from '../construtos/limpa-tela';
export declare class AvaliadorSintaticoVisuAlg extends AvaliadorSintaticoBase {
    blocoPrincipalIniciado: boolean;
    fimAlgoritmoEncontrado: boolean;
    tiposConhecidos: string[];
    funcoesProcedimentosConhecidos: string[];
    constructor();
    private validarSegmentoAlgoritmo;
    private criarVetorNDimensional;
    private validarDimensoesVetor;
    private logicaComumParametroVisuAlg;
    /**
     * Validação do segmento de declaração de variáveis (opcional).
     * @returns Vetor de Construtos para inicialização de variáveis.
     */
    private validarSegmentoVar;
    private validarSegmentoInicio;
    estaNoFinal(): boolean;
    primario(): Construto;
    comparacaoIgualdade(): Construto;
    ou(): Construto;
    /**
     * Método que resolve atribuições.
     * @returns Um construto do tipo `Atribuir`, `Conjunto` ou `AtribuicaoPorIndice`.
     */
    atribuir(): Construto;
    expressao(): Construto;
    blocoEscopo(): any[];
    /**
     * A finalização de chamada no VisuAlg é um pouco diferente.
     * Como há uma detecção de procedimentos e funções na avaliação de construtos primários,
     * `entidadeChmada` já pode vir como uma chamada.
     * O que este método faz é apenas complementar os argumentos.
     * @param entidadeChamada Um construto. Normalmente uma `Chamada`.
     * @returns Ou a entidade chamada enriquecida, ou uma nova `Chamada`.
     */
    finalizarChamada(entidadeChamada: Construto): Chamada;
    chamar(): Construto;
    verificarDefinicaoTipoAtual(): TipoDadosElementar;
    corpoDaFuncao(tipo: any): FuncaoConstruto;
    declaracaoComentario(): Comentario;
    declaracaoEnquanto(): Enquanto;
    private logicaCasosEscolha;
    declaracaoEscolha(): Escolha;
    private logicaComumArgumentosEscreva;
    declaracaoEscreva(): Escreva;
    declaracaoEscrevaMesmaLinha(): EscrevaMesmaLinha;
    /**
     * Criação de declaração "repita".
     * @returns Um construto do tipo Fazer
     */
    declaracaoFazer(): Fazer;
    /**
     * Criação de declaração "interrompa".
     * Em VisuAlg, "sustar" é chamada de "interrompa".
     * @returns Uma declaração do tipo Sustar.
     */
    private declaracaoInterrompa;
    /**
     * Análise de uma declaração `leia()`. No VisuAlg, `leia()` aceita 1..N argumentos.
     * @returns Uma declaração `Leia`.
     */
    declaracaoLeia(): Leia;
    declaracaoPara(): Para;
    logicaComumParametros(): ParametroInterface[];
    /**
     * Procedimentos nada mais são do que funções que não retornam valor.
     */
    declaracaoProcedimento(): FuncaoDeclaracao;
    declaracaoRetorna(): Retorna;
    declaracaoSe(): Se;
    private gerarConstrutorParaTipo;
    /**
     * No VisuAlg não existe o conceito de classe, mas existe o conceito de registro,
     * que é como se fosse uma classe sem métodos.
     * Por isso aqui retornamos `Classe`
     * @returns {Classe} Uma declaração de Classe, que serve como um tipo.
     */
    declaracaoTipo(): Classe;
    declaracaoAleatorio(): Aleatorio;
    expressaoLimpaTela(): LimpaTela;
    resolverDeclaracaoForaDeBloco(): Declaracao | Declaracao[] | Construto | Construto[] | any;
    /**
     * No VisuAlg, há uma determinada cadência de validação de símbolos.
     * - O primeiro símbolo é `algoritmo`, seguido por um identificador e
     * uma quebra de linha.
     * - Os próximos símbolo pode `var`, que pode ser seguido por uma série de
     * declarações de variáveis e finalizado por uma quebra de linha,
     * ou ainda `funcao` ou `procedimento`, seguidos dos devidos símbolos que definem
     * os blocos.
     * - O penúltimo símbolo é `inicio`, seguido por uma quebra de linha.
     * Pode haver ou não declarações dentro do bloco.
     * - O último símbolo deve ser `fimalgoritmo`, que também é usado para
     * definir quando não existem mais construtos a serem adicionados.
     * @param retornoLexador Os símbolos entendidos pelo Lexador.
     * @param hashArquivo Obrigatório por interface mas não usado aqui.
     */
    analisar(retornoLexador: RetornoLexador<SimboloInterface>, hashArquivo: number): RetornoAvaliadorSintatico<Declaracao>;
}
//# sourceMappingURL=avaliador-sintatico-visualg.d.ts.map