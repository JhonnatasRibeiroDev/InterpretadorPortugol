"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AvaliadorSintaticoVisuAlg = void 0;
const avaliador_sintatico_base_1 = require("@designliquido/delegua/avaliador-sintatico/avaliador-sintatico-base");
const declaracoes_1 = require("@designliquido/delegua/declaracoes");
const construtos_1 = require("@designliquido/delegua/construtos");
const lexador_1 = require("@designliquido/delegua/lexador");
const avaliador_sintatico_1 = require("@designliquido/delegua/avaliador-sintatico");
const limpa_tela_1 = require("../construtos/limpa-tela");
const lexico_regular_1 = __importDefault(require("../tipos-de-simbolos/lexico-regular"));
class AvaliadorSintaticoVisuAlg extends avaliador_sintatico_base_1.AvaliadorSintaticoBase {
    constructor() {
        super();
        this.blocoPrincipalIniciado = false;
        this.fimAlgoritmoEncontrado = false;
        this.tiposConhecidos = [];
        this.funcoesProcedimentosConhecidos = [];
    }
    validarSegmentoAlgoritmo() {
        this.consumir(lexico_regular_1.default.ALGORITMO, "Esperada expressão 'algoritmo' para inicializar programa.");
        const descricaoAlgoritmo = this.consumir(lexico_regular_1.default.CARACTERE, "Esperada cadeia de caracteres após palavra-chave 'algoritmo'.");
        this.consumir(lexico_regular_1.default.QUEBRA_LINHA, "Esperado quebra de linha após definição do segmento 'algoritmo'.");
        return descricaoAlgoritmo;
    }
    criarVetorNDimensional(linhaOriginal, dimensoes, construtoInicializacao = undefined) {
        if (dimensoes.length > 0) {
            const dimensao = dimensoes[0] + 1;
            const resto = dimensoes.slice(1);
            const novasDimensoes = [];
            for (let i = 0; i <= dimensao; i++) {
                novasDimensoes.push(this.criarVetorNDimensional(linhaOriginal, resto, construtoInicializacao));
            }
            const novoVetor = new construtos_1.Vetor(this.hashArquivo, linhaOriginal, novasDimensoes);
            return novoVetor;
        }
        return construtoInicializacao;
    }
    validarDimensoesVetor() {
        let dimensoes = [];
        do {
            const numeroInicial = this.consumir(lexico_regular_1.default.NUMERO, 'Esperado índice inicial para inicialização de dimensão de vetor.');
            this.consumir(lexico_regular_1.default.PONTO, 'Esperado primeiro ponto após índice inicial para inicialização de dimensão de vetor.');
            this.consumir(lexico_regular_1.default.PONTO, 'Esperado segundo ponto após índice inicial para inicialização de dimensão de vetor.');
            const numeroFinal = this.consumir(lexico_regular_1.default.NUMERO, 'Esperado índice final para inicialização de dimensão de vetor.');
            dimensoes.push(Number(numeroFinal.literal) - Number(numeroInicial.literal));
        } while (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.VIRGULA));
        return dimensoes;
    }
    logicaComumParametroVisuAlg() {
        const identificadores = [];
        let referencia = this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.VAR);
        do {
            identificadores.push(this.consumir(lexico_regular_1.default.IDENTIFICADOR, 'Esperado nome de variável.'));
        } while (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.VIRGULA));
        this.consumir(lexico_regular_1.default.DOIS_PONTOS, 'Esperado dois-pontos após nome de variável.');
        if (![
            lexico_regular_1.default.CARACTER,
            lexico_regular_1.default.CARACTERE,
            lexico_regular_1.default.INTEIRO,
            lexico_regular_1.default.LOGICO,
            lexico_regular_1.default.REAL,
            lexico_regular_1.default.VETOR,
        ].includes(this.simbolos[this.atual].tipo) &&
            !this.tiposConhecidos.includes(this.simbolos[this.atual].lexema)) {
            throw this.erro(this.simbolos[this.atual], `Tipo de variável não conhecido: ${this.simbolos[this.atual].lexema}`);
        }
        const simboloTipo = this.avancarEDevolverAnterior();
        let tipoVariavel = simboloTipo.tipo;
        if (tipoVariavel === lexico_regular_1.default.IDENTIFICADOR) {
            tipoVariavel = simboloTipo.lexema;
        }
        return {
            identificadores,
            tipo: tipoVariavel,
            simbolo: simboloTipo,
            referencia: referencia,
        };
    }
    /**
     * Validação do segmento de declaração de variáveis (opcional).
     * @returns Vetor de Construtos para inicialização de variáveis.
     */
    validarSegmentoVar() {
        // Podem haver linhas de comentários acima de `var`, que geram
        // quebras de linha.
        while (this.simbolos[this.atual].tipo === lexico_regular_1.default.QUEBRA_LINHA) {
            this.avancarEDevolverAnterior();
        }
        if (!this.verificarTipoSimboloAtual(lexico_regular_1.default.VAR)) {
            return [];
        }
        const inicializacoes = [];
        this.avancarEDevolverAnterior(); // Var
        while (!this.verificarTipoSimboloAtual(lexico_regular_1.default.INICIO)) {
            // Se ainda houver quebras de linha, volta para o começo do `while`.
            if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.QUEBRA_LINHA)) {
                continue;
            }
            const simboloAtual = this.simbolos[this.atual];
            switch (simboloAtual.tipo) {
                case lexico_regular_1.default.COMENTARIO:
                    inicializacoes.push(this.declaracaoComentario());
                    break;
                case lexico_regular_1.default.FUNCAO:
                case lexico_regular_1.default.FUNÇÃO:
                    const dadosFuncao = this.funcao('funcao');
                    this.funcoesProcedimentosConhecidos.push(dadosFuncao.simbolo.lexema);
                    inicializacoes.push(dadosFuncao);
                    break;
                case lexico_regular_1.default.PROCEDIMENTO:
                    const dadosProcedimento = this.declaracaoProcedimento();
                    inicializacoes.push(dadosProcedimento);
                    break;
                default:
                    const dadosVariaveis = this.logicaComumParametroVisuAlg();
                    // Se chegou até aqui, variáveis são válidas.
                    // Devem ser declaradas com um valor inicial padrão.
                    if (dadosVariaveis.tipo === lexico_regular_1.default.VETOR) {
                        this.consumir(lexico_regular_1.default.COLCHETE_ESQUERDO, 'Esperado colchete esquerdo após palavra reservada "vetor".');
                        const dimensoes = this.validarDimensoesVetor();
                        this.consumir(lexico_regular_1.default.COLCHETE_DIREITO, 'Esperado colchete direito após declaração de dimensões de vetor.');
                        this.consumir(lexico_regular_1.default.DE, 'Esperado palavra reservada "de" após declaração de dimensões de vetor.');
                        const simboloTipo = this.simbolos[this.atual];
                        if (![
                            lexico_regular_1.default.CARACTER,
                            lexico_regular_1.default.CARACTERE,
                            lexico_regular_1.default.INTEIRO,
                            lexico_regular_1.default.LOGICO,
                            lexico_regular_1.default.REAL,
                            lexico_regular_1.default.VETOR,
                        ].includes(simboloTipo.tipo) &&
                            !this.tiposConhecidos.includes(simboloTipo.lexema)) {
                            throw this.erro(simboloTipo, 'Tipo de variável ou registro não conhecido para inicialização de vetor.');
                        }
                        for (let identificador of dadosVariaveis.identificadores) {
                            if (this.tiposConhecidos.includes(simboloTipo.lexema)) {
                                const tipoInferido = `${simboloTipo.lexema}[]`;
                                inicializacoes.push(new declaracoes_1.Var(identificador, this.criarVetorNDimensional(simboloAtual.linha, dimensoes, new construtos_1.Chamada(this.hashArquivo, new construtos_1.Constante(this.hashArquivo, new lexador_1.Simbolo(lexico_regular_1.default.IDENTIFICADOR, simboloTipo.lexema, simboloTipo.lexema, identificador.linha, this.hashArquivo)), [])), tipoInferido));
                            }
                            else {
                                const tipoInferido = `${simboloTipo.lexema}[]`;
                                inicializacoes.push(new declaracoes_1.Var(identificador, new construtos_1.Literal(this.hashArquivo, Number(dadosVariaveis.simbolo.linha), this.criarVetorNDimensional(simboloAtual.linha, dimensoes)), tipoInferido));
                            }
                        }
                        this.atual++;
                    }
                    else {
                        for (let identificador of dadosVariaveis.identificadores) {
                            const tipo = dadosVariaveis.tipo;
                            switch (dadosVariaveis.tipo) {
                                case lexico_regular_1.default.CARACTER:
                                case lexico_regular_1.default.CARACTERE:
                                    inicializacoes.push(new declaracoes_1.Var(identificador, new construtos_1.Literal(this.hashArquivo, Number(dadosVariaveis.simbolo.linha), ''), tipo));
                                    break;
                                case lexico_regular_1.default.INTEIRO:
                                case lexico_regular_1.default.REAL:
                                    inicializacoes.push(new declaracoes_1.Var(identificador, new construtos_1.Literal(this.hashArquivo, Number(dadosVariaveis.simbolo.linha), 0), tipo));
                                    break;
                                case lexico_regular_1.default.LOGICO:
                                    inicializacoes.push(new declaracoes_1.Var(identificador, new construtos_1.Literal(this.hashArquivo, Number(dadosVariaveis.simbolo.linha), false), tipo));
                                    break;
                                default:
                                    // Neste caso, o tipo pode ser um registro.
                                    // Se for, verificamos aqui.
                                    if (!this.tiposConhecidos.includes(dadosVariaveis.tipo)) {
                                        throw this.erro(identificador, `Tipo ${dadosVariaveis.tipo} não parece ser de um tipo conhecido ou registro.`);
                                    }
                                    inicializacoes.push(new declaracoes_1.Var(identificador, 
                                    // A inicialização de um registro é uma chamada ao
                                    // construtor de classe.
                                    new construtos_1.Chamada(this.hashArquivo, new construtos_1.Constante(this.hashArquivo, new lexador_1.Simbolo(lexico_regular_1.default.IDENTIFICADOR, dadosVariaveis.tipo, dadosVariaveis.tipo, identificador.linha, this.hashArquivo)), []), dadosVariaveis.tipo));
                            }
                        }
                    }
                    break;
            }
            this.consumir(lexico_regular_1.default.QUEBRA_LINHA, 'Esperado quebra de linha após declaração de variável.');
        }
        return inicializacoes;
    }
    validarSegmentoInicio(algoritmoOuFuncao) {
        const simboloInicio = this.consumir(lexico_regular_1.default.INICIO, `Esperada expressão 'inicio' para marcar escopo de ${algoritmoOuFuncao}.`);
        return simboloInicio;
    }
    estaNoFinal() {
        return this.atual === this.simbolos.length;
    }
    primario() {
        const simboloAtual = this.simbolos[this.atual];
        if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.FALSO))
            return new construtos_1.Literal(this.hashArquivo, Number(simboloAtual.linha), false);
        if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.VERDADEIRO))
            return new construtos_1.Literal(this.hashArquivo, Number(simboloAtual.linha), true);
        if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.IDENTIFICADOR, lexico_regular_1.default.METODO_BIBLIOTECA_GLOBAL)) {
            const simboloIdentificadorOuMetodo = this.simbolos[this.atual - 1];
            const variavel = new construtos_1.Variavel(this.hashArquivo, simboloIdentificadorOuMetodo);
            // Chamada de função ou procedimento sem parâmetros.
            if (this.funcoesProcedimentosConhecidos.includes(simboloIdentificadorOuMetodo.lexema)) {
                return new construtos_1.Chamada(this.hashArquivo, variavel, []);
            }
            return variavel;
        }
        if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.NUMERO, lexico_regular_1.default.CARACTER, lexico_regular_1.default.CARACTERE)) {
            const simboloAnterior = this.simbolos[this.atual - 1];
            return new construtos_1.Literal(this.hashArquivo, Number(simboloAnterior.linha), simboloAnterior.literal);
        }
        if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.PARENTESE_ESQUERDO)) {
            const expressao = this.expressao();
            this.consumir(lexico_regular_1.default.PARENTESE_DIREITO, "Esperado ')' após a expressão.");
            return new construtos_1.Agrupamento(this.hashArquivo, Number(simboloAtual.linha), expressao);
        }
        throw this.erro(this.simbolos[this.atual], 'Esperado expressão.');
    }
    comparacaoIgualdade() {
        let expressao = this.comparar();
        while (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.DIFERENTE, lexico_regular_1.default.IGUAL)) {
            const simboloAnterior = this.simbolos[this.atual - 1];
            const direito = this.comparar();
            expressao = new construtos_1.Binario(this.hashArquivo, expressao, simboloAnterior, direito);
        }
        return expressao;
    }
    ou() {
        let expressao = this.e();
        while (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.OU, lexico_regular_1.default.XOU)) {
            const operador = this.simbolos[this.atual - 1];
            const direito = this.e();
            expressao = new construtos_1.Logico(this.hashArquivo, expressao, operador, direito);
        }
        return expressao;
    }
    /**
     * Método que resolve atribuições.
     * @returns Um construto do tipo `Atribuir`, `Conjunto` ou `AtribuicaoPorIndice`.
     */
    atribuir() {
        const expressao = this.ou();
        if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.SETA_ATRIBUICAO)) {
            const setaAtribuicao = this.simbolos[this.atual - 1];
            const valor = this.atribuir();
            switch (expressao.constructor.name) {
                case 'Variavel':
                    return new construtos_1.Atribuir(this.hashArquivo, expressao, valor);
                case 'AcessoIndiceVariavel':
                    const expressaoAcessoIndiceVariavel = expressao;
                    return new construtos_1.AtribuicaoPorIndice(this.hashArquivo, expressaoAcessoIndiceVariavel.linha, expressaoAcessoIndiceVariavel.entidadeChamada, expressaoAcessoIndiceVariavel.indice, valor);
                case 'AcessoElementoMatriz':
                    const expressaoAcessoElementoMatriz = expressao;
                    return new construtos_1.AtribuicaoPorIndicesMatriz(this.hashArquivo, expressaoAcessoElementoMatriz.linha, expressaoAcessoElementoMatriz.entidadeChamada, expressaoAcessoElementoMatriz.indicePrimario, expressaoAcessoElementoMatriz.indiceSecundario, valor);
                case 'AcessoMetodoOuPropriedade':
                    const expressaAcessoMetodoOuPropriedade = expressao;
                    return new construtos_1.DefinirValor(expressaAcessoMetodoOuPropriedade.hashArquivo, expressaAcessoMetodoOuPropriedade.linha, expressaAcessoMetodoOuPropriedade.objeto, expressaAcessoMetodoOuPropriedade.simbolo, valor);
                default:
                    throw this.erro(setaAtribuicao, 'Tarefa de atribuição inválida');
            }
        }
        return expressao;
    }
    expressao() {
        if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.LEIA))
            return this.declaracaoLeia();
        return this.atribuir();
    }
    blocoEscopo() {
        const declaracoes = [];
        while (![lexico_regular_1.default.FIM_FUNCAO, lexico_regular_1.default.FIM_FUNÇÃO, lexico_regular_1.default.FIM_PROCEDIMENTO].includes(this.simbolos[this.atual].tipo) &&
            !this.estaNoFinal()) {
            declaracoes.push(this.resolverDeclaracaoForaDeBloco());
        }
        // Se chegou até aqui, simplesmente consome o símbolo.
        this.avancarEDevolverAnterior();
        return declaracoes;
    }
    /**
     * A finalização de chamada no VisuAlg é um pouco diferente.
     * Como há uma detecção de procedimentos e funções na avaliação de construtos primários,
     * `entidadeChmada` já pode vir como uma chamada.
     * O que este método faz é apenas complementar os argumentos.
     * @param entidadeChamada Um construto. Normalmente uma `Chamada`.
     * @returns Ou a entidade chamada enriquecida, ou uma nova `Chamada`.
     */
    finalizarChamada(entidadeChamada) {
        const argumentos = [];
        while (!this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.PARENTESE_DIREITO)) {
            if (argumentos.length >= 255) {
                throw this.erro(this.simbolos[this.atual], 'Não pode haver mais de 255 argumentos.');
            }
            argumentos.push(this.expressao());
            this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.VIRGULA);
        }
        if (entidadeChamada instanceof construtos_1.Chamada) {
            entidadeChamada.argumentos = argumentos;
            return entidadeChamada;
        }
        return new construtos_1.Chamada(this.hashArquivo, entidadeChamada, argumentos);
    }
    chamar() {
        let expressao = this.primario();
        while (true) {
            if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.PARENTESE_ESQUERDO)) {
                expressao = this.finalizarChamada(expressao);
            }
            else if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.PONTO)) {
                const nome = this.consumir(lexico_regular_1.default.IDENTIFICADOR, "Esperado nome da propriedade após '.'.");
                expressao = new construtos_1.AcessoMetodoOuPropriedade(this.hashArquivo, expressao, nome);
            }
            else if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.COLCHETE_ESQUERDO)) {
                const indices = [];
                do {
                    indices.push(this.expressao());
                } while (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.VIRGULA));
                const simboloFechamento = this.consumir(lexico_regular_1.default.COLCHETE_DIREITO, "Esperado ']' após escrita do indice.");
                if (!indices[1]) {
                    expressao = new construtos_1.AcessoIndiceVariavel(this.hashArquivo, expressao, indices[0], simboloFechamento);
                }
                else {
                    expressao = new construtos_1.AcessoElementoMatriz(this.hashArquivo, expressao, indices[0], indices[1], simboloFechamento);
                }
            }
            else {
                break;
            }
        }
        return expressao;
    }
    verificarDefinicaoTipoAtual() {
        const tipos = ['inteiro', 'qualquer', 'real', 'texto', 'vazio', 'vetor', 'caracter'];
        // TODO: Remover isso. O máximo que o avaliador sintático
        // deveria olhar é o símbolo anterior, não dois
        // símbolos para trás.
        const lexema = this.simbolos[this.atual - 2].lexema.toLowerCase();
        const contemTipo = tipos.find((tipo) => tipo === lexema);
        if (contemTipo && this.verificarTipoProximoSimbolo(lexico_regular_1.default.COLCHETE_ESQUERDO)) {
            const tiposVetores = ['inteiro[]', 'qualquer[]', 'real[]', 'texto[]', 'caracter[]'];
            this.avancarEDevolverAnterior();
            if (!this.verificarTipoProximoSimbolo(lexico_regular_1.default.COLCHETE_DIREITO)) {
                throw this.erro(this.simbolos[this.atual - 1], "Esperado símbolo de fechamento do vetor ']'.");
            }
            const contemTipoVetor = tiposVetores.find((tipo) => tipo === `${lexema}[]`);
            this.avancarEDevolverAnterior();
            return contemTipoVetor;
        }
        return contemTipo;
    }
    corpoDaFuncao(tipo) {
        const simboloAnterior = this.simbolos[this.atual - 1];
        // Parâmetros
        const parametros = this.logicaComumParametros();
        this.consumir(lexico_regular_1.default.DOIS_PONTOS, 'Esperado dois-pontos após nome de função.');
        // Tipo retornado pela função.
        let tipoRetorno = null;
        if (!this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.INTEIRO, lexico_regular_1.default.CARACTER, lexico_regular_1.default.CARACTERE, lexico_regular_1.default.REAL, lexico_regular_1.default.LOGICO)) {
            throw this.erro(this.simbolos[this.atual], 'Esperado um tipo válido para retorno de função');
        }
        this.consumir(lexico_regular_1.default.QUEBRA_LINHA, "Esperado quebra de linha após tipo retornado por 'funcao'.");
        tipoRetorno = this.verificarDefinicaoTipoAtual();
        const inicializacoes = this.validarSegmentoVar();
        this.validarSegmentoInicio('função');
        const corpo = inicializacoes.concat(this.blocoEscopo());
        return new construtos_1.FuncaoConstruto(this.hashArquivo, Number(simboloAnterior.linha), parametros, corpo.filter((d) => d), tipoRetorno);
    }
    declaracaoComentario() {
        const simboloComentario = this.avancarEDevolverAnterior();
        return new construtos_1.Comentario(simboloComentario.hashArquivo, simboloComentario.linha, simboloComentario.literal, false);
    }
    declaracaoEnquanto() {
        const simboloAtual = this.avancarEDevolverAnterior();
        const condicao = this.expressao();
        if (!this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.FACA, lexico_regular_1.default.FAÇA)) {
            this.consumir(this.simbolos[this.atual].tipo, "Esperado paravra reservada 'faca' ou 'faça' após condição de continuidade em declaracão 'enquanto'.");
        }
        this.consumir(lexico_regular_1.default.QUEBRA_LINHA, "Esperado quebra de linha após palavra reservada 'faca' em declaracão 'enquanto'.");
        const declaracoes = [];
        do {
            declaracoes.push(this.resolverDeclaracaoForaDeBloco());
        } while (![lexico_regular_1.default.FIM_ENQUANTO].includes(this.simbolos[this.atual].tipo));
        this.consumir(lexico_regular_1.default.FIM_ENQUANTO, "Esperado palavra-chave 'fimenquanto' para fechamento de declaração 'enquanto'.");
        this.consumir(lexico_regular_1.default.QUEBRA_LINHA, "Esperado quebra de linha após palavra-chave 'fimenquanto'.");
        return new declaracoes_1.Enquanto(condicao, new declaracoes_1.Bloco(simboloAtual.hashArquivo, Number(simboloAtual.linha), declaracoes.filter((d) => d)));
    }
    logicaCasosEscolha() {
        const literais = [];
        let simboloAtualCaso = this.simbolos[this.atual];
        while (simboloAtualCaso.tipo !== lexico_regular_1.default.QUEBRA_LINHA) {
            literais.push(this.primario());
            this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.VIRGULA);
            simboloAtualCaso = this.simbolos[this.atual];
        }
        return literais;
    }
    declaracaoEscolha() {
        const simboloAtual = this.avancarEDevolverAnterior();
        // Parênteses são opcionais para delimitar o identificador.
        this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.PARENTESE_ESQUERDO);
        const identificador = this.primario();
        this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.PARENTESE_DIREITO);
        this.consumir(lexico_regular_1.default.QUEBRA_LINHA, "Esperado quebra de linha após variável ou literal de declaração 'caso'.");
        while (this.simbolos[this.atual].tipo === lexico_regular_1.default.QUEBRA_LINHA) {
            this.avancarEDevolverAnterior();
        }
        // Blocos de caso
        const caminhos = [];
        let simboloAtualBlocoCaso = this.avancarEDevolverAnterior();
        while (![lexico_regular_1.default.OUTRO_CASO, lexico_regular_1.default.FIM_ESCOLHA].includes(simboloAtualBlocoCaso.tipo)) {
            const caminhoCondicoes = this.logicaCasosEscolha();
            const declaracoes = [];
            do {
                declaracoes.push(this.resolverDeclaracaoForaDeBloco());
            } while (![lexico_regular_1.default.CASO, lexico_regular_1.default.OUTRO_CASO, lexico_regular_1.default.FIM_ESCOLHA].includes(this.simbolos[this.atual].tipo));
            caminhos.push({
                condicoes: caminhoCondicoes.filter((c) => c),
                declaracoes: declaracoes.filter((d) => d),
            });
            while (this.simbolos[this.atual].tipo === lexico_regular_1.default.QUEBRA_LINHA) {
                this.avancarEDevolverAnterior();
            }
            simboloAtualBlocoCaso = this.avancarEDevolverAnterior();
        }
        let caminhoPadrao = null;
        if (simboloAtualBlocoCaso.tipo === lexico_regular_1.default.OUTRO_CASO) {
            const declaracoes = [];
            do {
                declaracoes.push(this.resolverDeclaracaoForaDeBloco());
            } while (!this.verificarTipoSimboloAtual(lexico_regular_1.default.FIM_ESCOLHA));
            caminhoPadrao = {
                declaracoes: declaracoes.filter((d) => d),
            };
            simboloAtualBlocoCaso = this.avancarEDevolverAnterior();
        }
        if (simboloAtualBlocoCaso.tipo !== lexico_regular_1.default.FIM_ESCOLHA) {
            throw this.erro(this.simbolos[this.atual], "Esperado palavra-chave 'fimescolha' para fechamento de declaração 'escolha'.");
        }
        this.consumir(lexico_regular_1.default.QUEBRA_LINHA, "Esperado quebra de linha após palavra-chave 'fimescolha'.");
        return new declaracoes_1.Escolha(identificador, caminhos, caminhoPadrao);
    }
    logicaComumArgumentosEscreva() {
        const argumentos = [];
        if (!this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.PARENTESE_ESQUERDO)) {
            return argumentos;
        }
        const simboloParenteses = this.simbolos[this.atual - 1];
        // Sem não houver parâmetros, retorna vetor com literal vazio.
        if (this.simbolos[this.atual].tipo === lexico_regular_1.default.PARENTESE_DIREITO) {
            this.avancarEDevolverAnterior();
            return [
                new construtos_1.FormatacaoEscrita(this.hashArquivo, Number(simboloParenteses.linha), new construtos_1.Literal(this.hashArquivo, Number(simboloParenteses.linha), '')),
            ];
        }
        do {
            const valor = this.expressao();
            let espacos = 0;
            let casasDecimais = 0;
            if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.DOIS_PONTOS)) {
                // Espaços
                const simboloEspacos = this.consumir(lexico_regular_1.default.NUMERO, 'Esperado número após sinal de dois-pontos após identificador como argumento.');
                espacos = Number(simboloEspacos.lexema) - 1;
            }
            if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.DOIS_PONTOS)) {
                // Casas decimais
                const simboloCasasDecimais = this.consumir(lexico_regular_1.default.NUMERO, 'Esperado número após segundo sinal de dois-pontos após identificador como argumento.');
                casasDecimais = Number(simboloCasasDecimais.lexema);
            }
            argumentos.push(new construtos_1.FormatacaoEscrita(this.hashArquivo, Number(simboloParenteses.linha), valor, espacos, casasDecimais));
        } while (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.VIRGULA));
        this.consumir(lexico_regular_1.default.PARENTESE_DIREITO, "Esperado ')' após os valores em escreva.");
        // A linha pode simplesmente terminar com um comentário. Neste caso,
        // não verificamos a quebra de linha.
        if (this.simbolos[this.atual].tipo !== lexico_regular_1.default.COMENTARIO) {
            this.consumir(lexico_regular_1.default.QUEBRA_LINHA, "Esperado quebra de linha após fechamento de parênteses pós instrução 'escreva'.");
        }
        return argumentos;
    }
    declaracaoEscreva() {
        const simboloAtual = this.avancarEDevolverAnterior();
        const argumentos = this.logicaComumArgumentosEscreva();
        return new declaracoes_1.Escreva(Number(simboloAtual.linha), this.hashArquivo, argumentos);
    }
    declaracaoEscrevaMesmaLinha() {
        const simboloAtual = this.avancarEDevolverAnterior();
        const argumentos = this.logicaComumArgumentosEscreva();
        return new declaracoes_1.EscrevaMesmaLinha(Number(simboloAtual.linha), this.hashArquivo, argumentos);
    }
    /**
     * Criação de declaração "repita".
     * @returns Um construto do tipo Fazer
     */
    declaracaoFazer() {
        const simboloAtual = this.avancarEDevolverAnterior();
        this.consumir(lexico_regular_1.default.QUEBRA_LINHA, "Esperado quebra de linha após instrução 'repita'.");
        const declaracoes = [];
        do {
            declaracoes.push(this.resolverDeclaracaoForaDeBloco());
        } while (![lexico_regular_1.default.ATE, lexico_regular_1.default.ATÉ].includes(this.simbolos[this.atual].tipo));
        if (!this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.ATE, lexico_regular_1.default.ATÉ)) {
            this.consumir(this.simbolos[this.atual].tipo, "Esperado palavra-chave 'ate' ou 'até' após declaração de bloco em instrução 'repita'.");
        }
        const condicao = this.expressao();
        this.consumir(lexico_regular_1.default.QUEBRA_LINHA, "Esperado quebra de linha após condição de continuidade em instrução 'repita'.");
        return new declaracoes_1.Fazer(this.hashArquivo, Number(simboloAtual.linha), new declaracoes_1.Bloco(this.hashArquivo, Number(simboloAtual.linha), declaracoes.filter((d) => d)), condicao);
    }
    /**
     * Criação de declaração "interrompa".
     * Em VisuAlg, "sustar" é chamada de "interrompa".
     * @returns Uma declaração do tipo Sustar.
     */
    declaracaoInterrompa() {
        const simboloAtual = this.avancarEDevolverAnterior();
        // TODO: Contar blocos para colocar esta condição de erro.
        /* if (this.blocos < 1) {
            throw this.erro(this.simbolos[this.atual - 1], "'interrompa' deve estar dentro de um laço de repetição.");
        } */
        return new declaracoes_1.Sustar(simboloAtual);
    }
    /**
     * Análise de uma declaração `leia()`. No VisuAlg, `leia()` aceita 1..N argumentos.
     * @returns Uma declaração `Leia`.
     */
    declaracaoLeia() {
        const simboloLeia = this.avancarEDevolverAnterior();
        this.consumir(lexico_regular_1.default.PARENTESE_ESQUERDO, "Esperado '(' antes do argumento em instrução `leia`.");
        const argumentos = [];
        do {
            argumentos.push(this.expressao());
        } while (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.VIRGULA));
        this.consumir(lexico_regular_1.default.PARENTESE_DIREITO, "Esperado ')' após o argumento em instrução `leia`.");
        this.consumir(lexico_regular_1.default.QUEBRA_LINHA, 'Esperado quebra de linha após fechamento de parênteses pós instrução `leia`.');
        return new declaracoes_1.Leia(simboloLeia, argumentos);
    }
    declaracaoPara() {
        const simboloPara = this.avancarEDevolverAnterior();
        const variavelIteracao = this.consumir(lexico_regular_1.default.IDENTIFICADOR, "Esperado identificador de variável após 'para'.");
        if (!this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.DE, lexico_regular_1.default.SETA_ATRIBUICAO)) {
            throw this.erro(this.simbolos[this.atual], "Esperado palavra reservada 'de' ou seta de atribuição após variável de controle de 'para'.");
        }
        const literalOuVariavelInicio = this.adicaoOuSubtracao();
        this.consumir(lexico_regular_1.default.ATE, "Esperado palavra reservada 'ate' após valor inicial do laço de repetição 'para'.");
        const literalOuVariavelFim = this.adicaoOuSubtracao();
        let operadorCondicao = new lexador_1.Simbolo(lexico_regular_1.default.MENOR_IGUAL, '<=', null, Number(simboloPara.linha), this.hashArquivo);
        let operadorCondicaoIncremento = new lexador_1.Simbolo(lexico_regular_1.default.MENOR, '<', null, Number(simboloPara.linha), this.hashArquivo);
        // Isso existe porque o laço `para` do VisuAlg pode ter o passo positivo ou negativo
        // dependendo dos operandos de início e fim, que só são possíveis de determinar
        // em tempo de execução.
        // Quando um dos operandos é uma variável, tanto a condição do laço quanto o
        // passo são considerados indefinidos aqui.
        let passo;
        let resolverIncrementoEmExecucao = false;
        if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.PASSO)) {
            passo = this.unario();
            if (passo.hasOwnProperty('operador') && passo.operador.tipo === lexico_regular_1.default.SUBTRACAO) {
                operadorCondicao = new lexador_1.Simbolo(lexico_regular_1.default.MAIOR_IGUAL, '', '', Number(simboloPara.linha), this.hashArquivo);
                operadorCondicaoIncremento = new lexador_1.Simbolo(lexico_regular_1.default.MAIOR, '', '', Number(simboloPara.linha), this.hashArquivo);
            }
        }
        else {
            if (literalOuVariavelInicio instanceof construtos_1.Literal && literalOuVariavelFim instanceof construtos_1.Literal) {
                if (literalOuVariavelInicio.valor > literalOuVariavelFim.valor) {
                    passo = new construtos_1.Unario(this.hashArquivo, new lexador_1.Simbolo(lexico_regular_1.default.SUBTRACAO, '-', undefined, simboloPara.linha, simboloPara.hashArquivo), new construtos_1.Literal(this.hashArquivo, Number(simboloPara.linha), 1), 'ANTES');
                    operadorCondicao = new lexador_1.Simbolo(lexico_regular_1.default.MAIOR_IGUAL, '', '', Number(simboloPara.linha), this.hashArquivo);
                    operadorCondicaoIncremento = new lexador_1.Simbolo(lexico_regular_1.default.MAIOR, '', '', Number(simboloPara.linha), this.hashArquivo);
                }
                else {
                    passo = new construtos_1.Literal(this.hashArquivo, Number(simboloPara.linha), 1);
                }
            }
            else {
                // Passo e operador de condição precisam ser resolvidos em tempo de execução.
                passo = new construtos_1.Literal(this.hashArquivo, Number(simboloPara.linha), 1);
                operadorCondicao = undefined;
                operadorCondicaoIncremento = undefined;
                resolverIncrementoEmExecucao = true;
            }
        }
        if (!this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.FACA, lexico_regular_1.default.FAÇA)) {
            this.consumir(this.simbolos[this.atual].tipo, "Esperado palavra reservada 'faca' ou 'faça' após valor final do laço de repetição 'para'.");
        }
        this.consumir(lexico_regular_1.default.QUEBRA_LINHA, "Esperado quebra de linha após palavra reservada 'faca' do laço de repetição 'para'.");
        const declaracoesBlocoPara = [];
        let simboloAtualBlocoPara = this.simbolos[this.atual];
        while (simboloAtualBlocoPara.tipo !== lexico_regular_1.default.FIM_PARA) {
            declaracoesBlocoPara.push(this.resolverDeclaracaoForaDeBloco());
            simboloAtualBlocoPara = this.simbolos[this.atual];
        }
        this.consumir(lexico_regular_1.default.FIM_PARA, 'Aqui nunca deve ocorrer erro.');
        this.consumir(lexico_regular_1.default.QUEBRA_LINHA, "Esperado quebra de linha após palavra reservada 'fimpara'.");
        const corpo = new declaracoes_1.Bloco(this.hashArquivo, Number(simboloPara.linha) + 1, declaracoesBlocoPara.filter((d) => d));
        const para = new declaracoes_1.Para(this.hashArquivo, Number(simboloPara.linha), 
        // Inicialização.
        new construtos_1.Atribuir(this.hashArquivo, new construtos_1.Variavel(this.hashArquivo, variavelIteracao, 'inteiro'), literalOuVariavelInicio), 
        // Condição.
        new construtos_1.Binario(this.hashArquivo, new construtos_1.Variavel(this.hashArquivo, variavelIteracao, 'inteiro'), operadorCondicao, literalOuVariavelFim), 
        // Incremento, feito em construto especial `FimPara`.
        new construtos_1.FimPara(this.hashArquivo, Number(simboloPara.linha), new construtos_1.Binario(this.hashArquivo, new construtos_1.Variavel(this.hashArquivo, variavelIteracao, 'inteiro'), operadorCondicaoIncremento, literalOuVariavelFim), new declaracoes_1.Expressao(new construtos_1.Atribuir(this.hashArquivo, new construtos_1.Variavel(this.hashArquivo, variavelIteracao, 'inteiro'), new construtos_1.Binario(this.hashArquivo, new construtos_1.Variavel(this.hashArquivo, variavelIteracao, 'inteiro'), new lexador_1.Simbolo(lexico_regular_1.default.ADICAO, '+', null, Number(simboloPara.linha), this.hashArquivo), passo)))), corpo);
        para.blocoPosExecucao = corpo;
        para.resolverIncrementoEmExecucao = resolverIncrementoEmExecucao;
        return para;
    }
    logicaComumParametros() {
        const parametros = [];
        if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.PARENTESE_ESQUERDO)) {
            while (!this.verificarTipoSimboloAtual(lexico_regular_1.default.PARENTESE_DIREITO)) {
                const dadosParametros = this.logicaComumParametroVisuAlg();
                for (let parametro of dadosParametros.identificadores) {
                    parametros.push({
                        abrangencia: 'padrao',
                        nome: parametro,
                        referencia: dadosParametros.referencia,
                        tipoDado: dadosParametros.tipo,
                    });
                }
            }
            // Consumir parêntese direito
            this.consumir(lexico_regular_1.default.PARENTESE_DIREITO, 'Esperado parêntese direito para finalização da leitura de parâmetros.');
        }
        return parametros;
    }
    /**
     * Procedimentos nada mais são do que funções que não retornam valor.
     */
    declaracaoProcedimento() {
        const simboloProcedimento = this.avancarEDevolverAnterior();
        const nomeProcedimento = this.consumir(lexico_regular_1.default.IDENTIFICADOR, 'Esperado nome do procedimento após palavra-chave `procedimento`.');
        // Parâmetros
        const parametros = this.logicaComumParametros();
        const inicializacoes = this.validarSegmentoVar();
        this.validarSegmentoInicio('procedimento');
        const corpo = inicializacoes.concat(this.blocoEscopo());
        this.funcoesProcedimentosConhecidos.push(nomeProcedimento.lexema);
        return new declaracoes_1.FuncaoDeclaracao(nomeProcedimento, new construtos_1.FuncaoConstruto(this.hashArquivo, Number(simboloProcedimento.linha), parametros, corpo.filter((d) => d)));
    }
    declaracaoRetorna() {
        const simboloRetorna = this.avancarEDevolverAnterior();
        let valor = null;
        if ([
            lexico_regular_1.default.CARACTER,
            lexico_regular_1.default.CARACTERE,
            lexico_regular_1.default.IDENTIFICADOR,
            lexico_regular_1.default.NUMERO,
            lexico_regular_1.default.VERDADEIRO,
            lexico_regular_1.default.NEGACAO,
            lexico_regular_1.default.FALSO,
            lexico_regular_1.default.PARENTESE_ESQUERDO,
        ].includes(this.simbolos[this.atual].tipo)) {
            valor = this.expressao();
        }
        return new declaracoes_1.Retorna(simboloRetorna, valor);
    }
    declaracaoSe() {
        const simboloSe = this.avancarEDevolverAnterior();
        const condicao = this.expressao();
        if (!this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.ENTAO, lexico_regular_1.default.ENTÃO)) {
            this.consumir(this.simbolos[this.atual].tipo, "Esperado palavra reservada 'entao' ou 'então' após condição em declaração 'se'.");
        }
        this.consumir(lexico_regular_1.default.QUEBRA_LINHA, "Esperado quebra de linha após palavra reservada 'entao' em declaração 'se'.");
        const declaracoes = [];
        do {
            declaracoes.push(this.resolverDeclaracaoForaDeBloco());
        } while (![lexico_regular_1.default.SENAO, lexico_regular_1.default.SENÃO, lexico_regular_1.default.FIM_SE].includes(this.simbolos[this.atual].tipo));
        let caminhoSenao = null;
        if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.SENAO, lexico_regular_1.default.SENÃO)) {
            const simboloSenao = this.simbolos[this.atual - 1];
            const declaracoesSenao = [];
            do {
                declaracoesSenao.push(this.resolverDeclaracaoForaDeBloco());
            } while (![lexico_regular_1.default.FIM_SE].includes(this.simbolos[this.atual].tipo));
            caminhoSenao = new declaracoes_1.Bloco(this.hashArquivo, Number(simboloSenao.linha), declaracoesSenao.filter((d) => d));
        }
        this.consumir(lexico_regular_1.default.FIM_SE, "Esperado palavra-chave 'fimse' para fechamento de declaração 'se'.");
        this.consumir(lexico_regular_1.default.QUEBRA_LINHA, "Esperado quebra de linha após palavra-chave 'fimse'.");
        return new declaracoes_1.Se(condicao, new declaracoes_1.Bloco(this.hashArquivo, Number(simboloSe.linha), declaracoes.filter((d) => d)), [], caminhoSenao);
    }
    gerarConstrutorParaTipo(simboloTipo, propriedades) {
        const instrucoesConstrutor = [];
        for (let propriedade of propriedades) {
            let valorInicializacao;
            switch (propriedade.tipo) {
                case 'inteiro':
                case 'real':
                    valorInicializacao = 0;
                    break;
                case 'caracter':
                case 'caractere':
                    valorInicializacao = '';
                    break;
                case 'logico':
                case 'lógico':
                    valorInicializacao = false;
                    break;
            }
            instrucoesConstrutor.push(new declaracoes_1.Expressao(new construtos_1.DefinirValor(propriedade.hashArquivo, propriedade.linha, new construtos_1.Isto(propriedade.hashArquivo, propriedade.linha, new lexador_1.Simbolo('ISTO', 'isto', undefined, simboloTipo.linha, simboloTipo.hashArquivo)), propriedade.nome, new construtos_1.Literal(propriedade.hashArquivo, propriedade.linha, valorInicializacao))));
        }
        const construtorConstruto = new construtos_1.FuncaoConstruto(simboloTipo.hashArquivo, simboloTipo.linha, propriedades.map((p) => ({
            abrangencia: 'padrao',
            nome: p.nome,
        })), instrucoesConstrutor);
        const construtor = new declaracoes_1.FuncaoDeclaracao(new lexador_1.Simbolo('CONSTRUTOR', 'construtor', undefined, simboloTipo.hashArquivo, simboloTipo.linha), construtorConstruto, undefined);
        return construtor;
    }
    /**
     * No VisuAlg não existe o conceito de classe, mas existe o conceito de registro,
     * que é como se fosse uma classe sem métodos.
     * Por isso aqui retornamos `Classe`
     * @returns {Classe} Uma declaração de Classe, que serve como um tipo.
     */
    declaracaoTipo() {
        this.avancarEDevolverAnterior(); // 'tipo'
        const nomeTipo = this.consumir(lexico_regular_1.default.IDENTIFICADOR, 'Esperado identificador com o nome do tipo a ser declarado.');
        this.consumir(lexico_regular_1.default.IGUAL, 'Esperado símbolo de igual após nome do tipo.');
        this.consumir(lexico_regular_1.default.REGISTRO, 'Esperado expressão "registro" após sinal de igual em declaração de tipo.');
        this.consumir(lexico_regular_1.default.QUEBRA_LINHA, 'Esperado quebra de linha após palavra reservada "registro".');
        let propriedades = [];
        while (this.simbolos[this.atual].tipo !== lexico_regular_1.default.FIM_REGISTRO) {
            const nomePropriedade = this.consumir(lexico_regular_1.default.IDENTIFICADOR, 'Esperado identificador como nome de propriedade em especificação de registro.');
            this.consumir(lexico_regular_1.default.DOIS_PONTOS, 'Esperado dois-pontos após nome de propriedade em especificação de registro.');
            if (!this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.INTEIRO, lexico_regular_1.default.CARACTERE, lexico_regular_1.default.REAL, lexico_regular_1.default.LOGICO)) {
                throw this.erro(this.simbolos[this.atual], `Esperado um tipo válido de propriedade em especificação de registro. Atual: ${this.simbolos[this.atual].lexema}.`);
            }
            const tipoPropriedade = this.simboloAnterior();
            this.consumir(lexico_regular_1.default.QUEBRA_LINHA, 'Esperado quebra de linha após tipo de propriedade em especificação de registro.');
            propriedades.push(new declaracoes_1.PropriedadeClasse(nomePropriedade, tipoPropriedade.lexema));
        }
        this.consumir(lexico_regular_1.default.FIM_REGISTRO, 'Não deve ocorrer erro aqui.');
        this.tiposConhecidos.push(nomeTipo.lexema);
        // Em teoria, um registro é inicializado implicitamente.
        // Para isso, geramos um construtor que inicializa todas as propriedades
        // com valores padrão.
        const construtor = this.gerarConstrutorParaTipo(nomeTipo, propriedades);
        return new declaracoes_1.Classe(nomeTipo, undefined, [construtor], propriedades, []);
    }
    declaracaoAleatorio() {
        const simboloAleatorio = this.avancarEDevolverAnterior();
        let argumentos = {
            min: 0,
            max: 0,
        };
        if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.NUMERO)) {
            this.consumir(lexico_regular_1.default.VIRGULA, "Esperado ',' após declaração do primeiro número.");
            // TODO: Remover isso. O máximo que o avaliador sintático
            // deveria olhar é o símbolo anterior, não dois
            // símbolos para trás.
            argumentos.min = Number(this.simbolos[this.atual - 2].literal);
            this.consumir(lexico_regular_1.default.NUMERO, "Esperado um número após ','.");
            argumentos.max = Number(this.simbolos[this.atual - 1].literal);
        }
        else if (!this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.ON)) {
            this.consumir(simboloAleatorio.tipo, "Esperado palavra reservada 'ON'ou 'on' ou combinação de número'(min, max)' após declaração 'aleatorio'");
            argumentos = null;
        }
        this.consumir(lexico_regular_1.default.QUEBRA_LINHA, 'Esperado quebra de linha após declaração do último número.');
        const decoracoes = [];
        do {
            const decoracao = this.resolverDeclaracaoForaDeBloco();
            if (decoracao instanceof declaracoes_1.Leia)
                decoracao.eParaInterromper = true;
            decoracoes.push(decoracao);
        } while (![lexico_regular_1.default.ALEATORIO, lexico_regular_1.default.FIM_ALGORITMO].includes(this.simbolos[this.atual].tipo));
        if (this.verificarSeSimboloAtualEIgualA(lexico_regular_1.default.ALEATORIO)) {
            this.consumir(lexico_regular_1.default.OFF, "Esperado palavra reservada 'off' ou 'OFF' após declaração 'aleatorio'.");
        }
        return new declaracoes_1.Aleatorio(simboloAleatorio.linha, simboloAleatorio.hashArquivo, new declaracoes_1.Bloco(simboloAleatorio.hashArquivo, Number(simboloAleatorio.linha), decoracoes.filter((d) => d)), argumentos);
    }
    expressaoLimpaTela() {
        const simboloLimpaTela = this.avancarEDevolverAnterior();
        return new limpa_tela_1.LimpaTela(simboloLimpaTela.hashArquivo, simboloLimpaTela.linha);
    }
    resolverDeclaracaoForaDeBloco() {
        const simboloAtual = this.simbolos[this.atual];
        switch (simboloAtual.tipo) {
            case lexico_regular_1.default.ALEATORIO:
                return this.declaracaoAleatorio();
            case lexico_regular_1.default.COMENTARIO:
                return this.declaracaoComentario();
            case lexico_regular_1.default.ENQUANTO:
                return this.declaracaoEnquanto();
            case lexico_regular_1.default.ESCOLHA:
                return this.declaracaoEscolha();
            case lexico_regular_1.default.ESCREVA:
                return this.declaracaoEscrevaMesmaLinha();
            case lexico_regular_1.default.ESCREVA_LINHA:
                return this.declaracaoEscreva();
            case lexico_regular_1.default.FIM_ALGORITMO:
                this.fimAlgoritmoEncontrado = true;
                this.avancarEDevolverAnterior();
                return null;
            case lexico_regular_1.default.FUNCAO:
                return this.funcao('funcao');
            case lexico_regular_1.default.INICIO:
                const simboloInicio = this.validarSegmentoInicio('algoritmo');
                return new declaracoes_1.InicioAlgoritmo(simboloInicio.linha, simboloInicio.hashArquivo);
            case lexico_regular_1.default.INTERROMPA:
                return this.declaracaoInterrompa();
            case lexico_regular_1.default.LEIA:
                return this.declaracaoLeia();
            case lexico_regular_1.default.LIMPA_TELA:
                return this.expressaoLimpaTela();
            case lexico_regular_1.default.PARA:
                return this.declaracaoPara();
            case lexico_regular_1.default.PARENTESE_DIREITO:
                throw new Error('Não deveria estar caindo aqui.');
            case lexico_regular_1.default.PROCEDIMENTO:
                return this.declaracaoProcedimento();
            case lexico_regular_1.default.QUEBRA_LINHA:
                this.avancarEDevolverAnterior();
                return null;
            case lexico_regular_1.default.REPITA:
                return this.declaracaoFazer();
            case lexico_regular_1.default.RETORNE:
                return this.declaracaoRetorna();
            case lexico_regular_1.default.SE:
                return this.declaracaoSe();
            case lexico_regular_1.default.TIPO:
                return this.declaracaoTipo();
            case lexico_regular_1.default.VAR:
                if (this.blocoPrincipalIniciado) {
                    throw this.erro(this.simbolos[this.atual], 'Sintaxe incorreta: início do bloco principal já foi declarado.');
                }
                return this.validarSegmentoVar();
            default:
                return new declaracoes_1.Expressao(this.expressao());
        }
    }
    /**
     * No VisuAlg, há uma determinada cadência de validação de símbolos.
     * - O primeiro símbolo é `algoritmo`, seguido por um identificador e
     * uma quebra de linha.
     * - Os próximos símbolo pode `var`, que pode ser seguido por uma série de
     * declarações de variáveis e finalizado por uma quebra de linha,
     * ou ainda `funcao` ou `procedimento`, seguidos dos devidos símbolos que definem
     * os blocos.
     * - O penúltimo símbolo é `inicio`, seguido por uma quebra de linha.
     * Pode haver ou não declarações dentro do bloco.
     * - O último símbolo deve ser `fimalgoritmo`, que também é usado para
     * definir quando não existem mais construtos a serem adicionados.
     * @param retornoLexador Os símbolos entendidos pelo Lexador.
     * @param hashArquivo Obrigatório por interface mas não usado aqui.
     */
    analisar(retornoLexador, hashArquivo) {
        this.erros = [];
        this.atual = 0;
        this.blocos = 0;
        this.blocoPrincipalIniciado = false;
        this.fimAlgoritmoEncontrado = false;
        this.tiposConhecidos = [];
        this.funcoesProcedimentosConhecidos = [];
        this.hashArquivo = hashArquivo || 0;
        this.simbolos = (retornoLexador === null || retornoLexador === void 0 ? void 0 : retornoLexador.simbolos) || [];
        while (this.verificarTipoSimboloAtual(lexico_regular_1.default.QUEBRA_LINHA)) {
            this.avancarEDevolverAnterior();
        }
        let declaracoes = [];
        const simboloNomeAlgoritmo = this.validarSegmentoAlgoritmo();
        declaracoes.push(new declaracoes_1.CabecalhoPrograma(simboloNomeAlgoritmo.linha, simboloNomeAlgoritmo.hashArquivo, simboloNomeAlgoritmo.literal));
        while (!this.estaNoFinal()) {
            const declaracao = this.resolverDeclaracaoForaDeBloco();
            if (Array.isArray(declaracao)) {
                declaracoes = declaracoes.concat(declaracao);
            }
            else {
                declaracoes.push(declaracao);
            }
        }
        const ultimoSimbolo = this.simbolos[this.simbolos.length - 1];
        if (ultimoSimbolo.tipo !== lexico_regular_1.default.FIM_ALGORITMO && !this.fimAlgoritmoEncontrado) {
            throw new avaliador_sintatico_1.ErroAvaliadorSintatico(ultimoSimbolo, `Programa não termina com 'fimalgoritmo'. Último símbolo: '${ultimoSimbolo.lexema || ultimoSimbolo.literal || ultimoSimbolo.tipo}'.`);
        }
        return {
            declaracoes: declaracoes.filter((d) => d),
            erros: this.erros,
        };
    }
}
exports.AvaliadorSintaticoVisuAlg = AvaliadorSintaticoVisuAlg;
//# sourceMappingURL=avaliador-sintatico-visualg.js.map