"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnalisadorSemanticoVisuAlg = void 0;
const construtos_1 = require("@designliquido/delegua/construtos");
const declaracoes_1 = require("@designliquido/delegua/declaracoes");
const analisador_semantico_base_1 = require("@designliquido/delegua/analisador-semantico/analisador-semantico-base");
const erros_1 = require("@designliquido/delegua/interfaces/erros");
const pilha_variaveis_1 = require("./pilha-variaveis");
class AnalisadorSemanticoVisuAlg extends analisador_semantico_base_1.AnalisadorSemanticoBase {
    constructor() {
        super();
        this.pilhaVariaveis = new pilha_variaveis_1.PilhaVariaveis();
        this.variaveis = {};
        this.funcoes = {};
        this.atual = 0;
        this.diagnosticos = [];
    }
    adicionarDiagnostico(simbolo, mensagem, severidade = erros_1.DiagnosticoSeveridade.ERRO) {
        this.diagnosticos.push({
            simbolo: simbolo,
            mensagem: mensagem,
            hashArquivo: simbolo.hashArquivo,
            linha: simbolo.linha,
            severidade: severidade,
        });
    }
    visitarExpressaoDeAtribuicao(expressao) {
        const { alvo, valor } = expressao;
        // Provavelmente o alvo é sempre `Variavel`
        const alvoVariavel = alvo;
        let variavel = this.variaveis[alvoVariavel.simbolo.lexema];
        if (!variavel) {
            this.adicionarDiagnostico(alvoVariavel.simbolo, `Variável ${alvoVariavel.simbolo.lexema} ainda não foi declarada.`);
            return Promise.resolve();
        }
        if (variavel.tipo) {
            if (valor instanceof construtos_1.Literal && variavel.tipo.includes('[]')) {
                this.adicionarDiagnostico(alvoVariavel.simbolo, `Atribuição inválida, esperado tipo '${variavel.tipo}' na atribuição.`);
                return Promise.resolve();
            }
            if (valor instanceof construtos_1.Vetor && !variavel.tipo.includes('[]')) {
                this.adicionarDiagnostico(alvoVariavel.simbolo, `Atribuição inválida, esperado tipo '${variavel.tipo}' na atribuição.`);
                return Promise.resolve();
            }
            if (valor instanceof construtos_1.Literal) {
                let valorLiteral = typeof valor.valor;
                if (!['qualquer'].includes(variavel.tipo)) {
                    if (valorLiteral === 'string') {
                        if (variavel.tipo.toLowerCase() != 'caractere') {
                            this.adicionarDiagnostico(alvoVariavel.simbolo, `Esperado tipo '${variavel.tipo}' na atribuição.`);
                            return Promise.resolve();
                        }
                    }
                    if (valorLiteral === 'number') {
                        if (!['inteiro', 'real'].includes(variavel.tipo.toLowerCase())) {
                            this.adicionarDiagnostico(alvoVariavel.simbolo, `Esperado tipo '${variavel.tipo}' na atribuição.`);
                            return Promise.resolve();
                        }
                    }
                }
            }
        }
        if (variavel) {
            this.variaveis[alvoVariavel.simbolo.lexema].valor = valor;
        }
    }
    gerarNumeroAleatorio(min, max) {
        return Math.floor(Math.random() * (max - min) + min);
    }
    encontrarLeiaNoAleatorio(declaracao, menorNumero, maiorNumero) {
        if ('declaracoes' in declaracao) {
            // Se a declaração tiver um campo 'declaracoes', ela é um Bloco
            const declaracoes = declaracao.declaracoes;
            for (const subDeclaracao of declaracoes) {
                this.encontrarLeiaNoAleatorio(subDeclaracao, menorNumero, maiorNumero);
            }
        }
        else if (declaracao instanceof declaracoes_1.Leia) {
            // Se encontrarmos um Leia, podemos efetuar as operações imediatamente
            for (const argumento of declaracao.argumentos) {
                this.atualizarVariavelComValorAleatorio(argumento, menorNumero, maiorNumero);
            }
        }
    }
    atualizarVariavelComValorAleatorio(variavel, menorNumero, maiorNumero) {
        if (this.variaveis[variavel.simbolo.lexema]) {
            let valor = 0;
            if (this.variaveis[variavel.simbolo.lexema].tipo.toLowerCase() === 'inteiro' ||
                this.variaveis[variavel.simbolo.lexema].tipo.toLowerCase() === 'real')
                valor = this.gerarNumeroAleatorio(menorNumero, maiorNumero);
            else if (this.variaveis[variavel.simbolo.lexema].tipo.toLowerCase() === 'caracter')
                valor = this.palavraAleatoriaCom5Digitos();
            this.variaveis[variavel.simbolo.lexema].valor = valor;
        }
    }
    palavraAleatoriaCom5Digitos() {
        const caracteres = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
        let palavra = '';
        for (let i = 0; i < 5; i++) {
            const indiceAleatorio = Math.floor(Math.random() * caracteres.length);
            palavra += caracteres.charAt(indiceAleatorio);
        }
        return palavra;
    }
    visitarDeclaracaoAleatorio(declaracao) {
        //Isso acontece quando não é informado os número máximos e mínimos
        let menorNumero = 0;
        let maiorNumero = 100;
        if (declaracao.argumentos) {
            menorNumero = Math.min(declaracao.argumentos.min, declaracao.argumentos.max);
            maiorNumero = Math.max(declaracao.argumentos.min, declaracao.argumentos.max);
        }
        for (let corpoDeclaracao of declaracao.corpo.declaracoes) {
            this.encontrarLeiaNoAleatorio(corpoDeclaracao, menorNumero, maiorNumero);
        }
        return Promise.resolve();
    }
    visitarDeclaracaoVar(declaracao) {
        this.variaveis[declaracao.simbolo.lexema] = {
            imutavel: false,
            tipo: declaracao.tipo,
            valor: declaracao.inicializador !== null
                ? declaracao.inicializador.valor !== undefined
                    ? declaracao.inicializador.valor
                    : declaracao.inicializador
                : undefined,
            valorDefinido: true,
        };
        return Promise.resolve();
    }
    visitarDeclaracaoDeExpressao(declaracao) {
        switch (declaracao.expressao.constructor.name) {
            case 'Atribuir':
                this.visitarExpressaoDeAtribuicao(declaracao.expressao);
                break;
            case 'Chamada':
                this.visitarExpressaoDeChamada(declaracao.expressao);
                break;
            default:
                console.log(declaracao.expressao);
                break;
        }
        return Promise.resolve();
    }
    visitarDeclaracaoDefinicaoFuncao(declaracao) {
        for (let parametro of declaracao.funcao.parametros) {
            if (parametro.hasOwnProperty('tipoDado') && !parametro.tipoDado) {
                this.adicionarDiagnostico(declaracao.simbolo, `O tipo '${parametro.tipoDado}' não é valido`);
            }
        }
        if (declaracao.funcao.parametros.length >= 255) {
            this.adicionarDiagnostico(declaracao.simbolo, 'Não pode haver mais de 255 parâmetros');
        }
        this.funcoes[declaracao.simbolo.lexema] = {
            valor: declaracao.funcao,
        };
        // TODO: Ao inspecionar corpo da função, verificar se todas as
        // declarações `Retorna` retornam um tipo diferente do tipo da função
        // (se for função).
        return Promise.resolve();
    }
    visitarDeclaracaoEscrevaMesmaLinha(declaracao) {
        declaracao.argumentos.forEach((argumento) => {
            var _a;
            if (argumento.expressao instanceof construtos_1.Variavel) {
                if (!this.variaveis[argumento.expressao.simbolo.lexema]) {
                    this.adicionarDiagnostico(argumento.expressao.simbolo, `Variável '${argumento.expressao.simbolo.lexema}' não existe.`);
                    return Promise.resolve();
                }
                if (((_a = this.variaveis[argumento.expressao.simbolo.lexema]) === null || _a === void 0 ? void 0 : _a.valor) === undefined) {
                    this.adicionarDiagnostico(argumento.expressao.simbolo, `Variável '${argumento.expressao.simbolo.lexema}' não foi inicializada.`, erros_1.DiagnosticoSeveridade.AVISO);
                }
            }
        });
        return Promise.resolve();
    }
    visitarExpressaoDeChamada(expressao) {
        if (expressao.entidadeChamada instanceof construtos_1.Variavel) {
            const variavel = expressao.entidadeChamada;
            const funcaoChamada = this.variaveis[variavel.simbolo.lexema] || this.funcoes[variavel.simbolo.lexema];
            if (!funcaoChamada) {
                this.adicionarDiagnostico(variavel.simbolo, `Função '${variavel.simbolo.lexema}' não foi declarada.`);
                return Promise.resolve();
            }
            const funcao = funcaoChamada.valor;
            if (funcao.parametros.length != expressao.argumentos.length) {
                this.adicionarDiagnostico(variavel.simbolo, `Esperava ${funcao.parametros.length} ${funcao.parametros.length > 1 ? 'argumentos' : 'argumento'}, mas obteve ${expressao.argumentos.length}.`);
            }
            for (let [indice, argumento] of expressao.argumentos.entries()) {
                const parametroCorrespondente = funcao.parametros[indice];
                const tipoDadoParametro = parametroCorrespondente.tipoDado.toLowerCase();
                if (argumento instanceof construtos_1.Variavel) {
                    const lexemaVariavelCorrespondente = argumento.simbolo.lexema;
                    const tipoVariavelCorrespondente = this.variaveis[lexemaVariavelCorrespondente].tipo.toLowerCase();
                    if (tipoVariavelCorrespondente !== tipoDadoParametro) {
                        this.adicionarDiagnostico(variavel.simbolo, `O tipo do valor passado para o parâmetro '${parametroCorrespondente.nome.lexema}' (${tipoVariavelCorrespondente}) é diferente do esperado pela função (${tipoDadoParametro}).`);
                    }
                }
                if (argumento instanceof construtos_1.Literal) {
                    switch (argumento.valor.constructor.name) {
                        case 'Number':
                            if (!['inteiro', 'real'].includes(tipoDadoParametro)) {
                                this.adicionarDiagnostico(variavel.simbolo, `O tipo do valor passado para o parâmetro '${parametroCorrespondente.nome.lexema}' (inteiro ou real) é diferente do esperado pela função (${tipoDadoParametro}).`);
                            }
                            break;
                        // TODO: Finalizar.
                    }
                }
            }
        }
        return Promise.resolve();
    }
    visitarExpressaoLeia(declaracao) {
        for (let argumento of declaracao.argumentos) {
            const argumentoComoVariavel = argumento;
            // TODO: Reabilitar na próxima versão do núcleo de Delégua.
            // this.variaveis[argumentoComoVariavel.simbolo.lexema].valorDefinido = true;
        }
        return Promise.resolve();
    }
    visitarExpressaoRetornar(declaracao) {
        return Promise.resolve(null);
    }
    analisar(declaracoes) {
        this.variaveis = {};
        this.atual = 0;
        this.diagnosticos = [];
        while (this.atual < declaracoes.length) {
            declaracoes[this.atual].aceitar(this);
            this.atual++;
        }
        return {
            diagnosticos: this.diagnosticos,
        };
    }
}
exports.AnalisadorSemanticoVisuAlg = AnalisadorSemanticoVisuAlg;
//# sourceMappingURL=analisador-semantico-visualg.js.map