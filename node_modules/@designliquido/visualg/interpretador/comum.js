"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.carregarBibliotecaGlobalCaracter = carregarBibliotecaGlobalCaracter;
exports.carregarBibliotecaGlobalNumerica = carregarBibliotecaGlobalNumerica;
exports.visitarDeclaracaoCabecalhoPrograma = visitarDeclaracaoCabecalhoPrograma;
exports.visitarDeclaracaoClasse = visitarDeclaracaoClasse;
exports.visitarDeclaracaoDefinicaoFuncao = visitarDeclaracaoDefinicaoFuncao;
exports.visitarDeclaracaoInicioAlgoritmo = visitarDeclaracaoInicioAlgoritmo;
exports.atribuirVariavel = atribuirVariavel;
exports.visitarDeclaracaoVar = visitarDeclaracaoVar;
exports.visitarExpressaoAcessoIndiceVariavel = visitarExpressaoAcessoIndiceVariavel;
exports.visitarExpressaoAtribuicaoPorIndice = visitarExpressaoAtribuicaoPorIndice;
exports.visitarExpressaoBinaria = visitarExpressaoBinaria;
exports.visitarExpressaoLogica = visitarExpressaoLogica;
exports.resolverIncrementoPara = resolverIncrementoPara;
exports.visitarExpressaoAcessoElementoMatriz = visitarExpressaoAcessoElementoMatriz;
exports.visitarExpressaoAtribuicaoPorIndicesMatriz = visitarExpressaoAtribuicaoPorIndicesMatriz;
exports.visitarDeclaracaoAleatorio = visitarDeclaracaoAleatorio;
exports.visitarExpressaoFormatacaoEscrita = visitarExpressaoFormatacaoEscrita;
exports.visitarExpressaoLeia = visitarExpressaoLeia;
const construtos_1 = require("@designliquido/delegua/construtos");
const declaracoes_1 = require("@designliquido/delegua/declaracoes");
const lexador_1 = require("@designliquido/delegua/lexador");
const excecoes_1 = require("@designliquido/delegua/excecoes");
const estruturas_1 = require("@designliquido/delegua/estruturas");
const inferenciador_1 = require("./inferenciador");
const lexico_regular_1 = __importDefault(require("../tipos-de-simbolos/lexico-regular"));
const bibliotecaCaracteres = __importStar(require("../bibliotecas/caracteres"));
const bibliotecaNumerica = __importStar(require("../bibliotecas/numerica"));
const estruturas_2 = require("./estruturas");
function carregarBibliotecaGlobalCaracter(pilhaEscoposExecucao) {
    pilhaEscoposExecucao.definirVariavel('asc', new estruturas_1.FuncaoPadrao(1, bibliotecaCaracteres.asc));
    pilhaEscoposExecucao.definirVariavel('carac', new estruturas_1.FuncaoPadrao(1, bibliotecaCaracteres.carac));
    pilhaEscoposExecucao.definirVariavel('caracpnum', new estruturas_1.FuncaoPadrao(1, bibliotecaCaracteres.caracpnum));
    pilhaEscoposExecucao.definirVariavel('compr', new estruturas_1.FuncaoPadrao(1, bibliotecaCaracteres.compr));
    pilhaEscoposExecucao.definirVariavel('copia', new estruturas_1.FuncaoPadrao(3, bibliotecaCaracteres.copia));
    pilhaEscoposExecucao.definirVariavel('maiusc', new estruturas_1.FuncaoPadrao(1, bibliotecaCaracteres.maiusc));
    pilhaEscoposExecucao.definirVariavel('minusc', new estruturas_1.FuncaoPadrao(1, bibliotecaCaracteres.minusc));
    pilhaEscoposExecucao.definirVariavel('numpcarac', new estruturas_1.FuncaoPadrao(1, bibliotecaCaracteres.numpcarac));
    pilhaEscoposExecucao.definirVariavel('pos', new estruturas_1.FuncaoPadrao(2, bibliotecaCaracteres.pos));
}
function carregarBibliotecaGlobalNumerica(pilhaEscoposExecucao) {
    pilhaEscoposExecucao.definirVariavel('abs', new estruturas_1.FuncaoPadrao(1, bibliotecaNumerica.abs));
    pilhaEscoposExecucao.definirVariavel('arccos', new estruturas_1.FuncaoPadrao(1, bibliotecaNumerica.arccos));
    pilhaEscoposExecucao.definirVariavel('arcsen', new estruturas_1.FuncaoPadrao(1, bibliotecaNumerica.arcsen));
    pilhaEscoposExecucao.definirVariavel('arctan', new estruturas_1.FuncaoPadrao(1, bibliotecaNumerica.arctan));
    pilhaEscoposExecucao.definirVariavel('cos', new estruturas_1.FuncaoPadrao(1, bibliotecaNumerica.cos));
    pilhaEscoposExecucao.definirVariavel('cotan', new estruturas_1.FuncaoPadrao(1, bibliotecaNumerica.cotan));
    pilhaEscoposExecucao.definirVariavel('exp', new estruturas_1.FuncaoPadrao(2, bibliotecaNumerica.exp));
    pilhaEscoposExecucao.definirVariavel('grauprad', new estruturas_1.FuncaoPadrao(1, bibliotecaNumerica.grauprad));
    pilhaEscoposExecucao.definirVariavel('int', new estruturas_1.FuncaoPadrao(1, bibliotecaNumerica.int));
    pilhaEscoposExecucao.definirVariavel('log', new estruturas_1.FuncaoPadrao(1, bibliotecaNumerica.log));
    pilhaEscoposExecucao.definirVariavel('logn', new estruturas_1.FuncaoPadrao(1, bibliotecaNumerica.logn));
    pilhaEscoposExecucao.definirVariavel('pi', new estruturas_1.FuncaoPadrao(0, bibliotecaNumerica.pi));
    pilhaEscoposExecucao.definirVariavel('quad', new estruturas_1.FuncaoPadrao(1, bibliotecaNumerica.quad));
    pilhaEscoposExecucao.definirVariavel('radpgrau', new estruturas_1.FuncaoPadrao(1, bibliotecaNumerica.radpgrau));
    pilhaEscoposExecucao.definirVariavel('raizq', new estruturas_1.FuncaoPadrao(1, bibliotecaNumerica.raizq));
    pilhaEscoposExecucao.definirVariavel('rand', new estruturas_1.FuncaoPadrao(0, bibliotecaNumerica.rand));
    pilhaEscoposExecucao.definirVariavel('randi', new estruturas_1.FuncaoPadrao(1, bibliotecaNumerica.randi));
    pilhaEscoposExecucao.definirVariavel('sen', new estruturas_1.FuncaoPadrao(1, bibliotecaNumerica.sen));
    pilhaEscoposExecucao.definirVariavel('tan', new estruturas_1.FuncaoPadrao(1, bibliotecaNumerica.tan));
}
async function visitarDeclaracaoCabecalhoPrograma(interpretador, declaracao) {
    return Promise.resolve();
}
/**
 * Uma declaração de "classe" no VisuAlg nada mais é que a definição de um registro.
 * Não há propriedades e não há herança. Por isso usamos uma versão simplificada
 * da implementação original de Delégua.
 * @param declaracao A declaração de registro.
 * @returns Sempre retorna nulo, por ser requerido pelo contrato de visita.
 */
async function visitarDeclaracaoClasse(interpretador, declaracao) {
    const metodos = {};
    if (declaracao.metodos.length > 0) {
        const declaracaoConstrutor = declaracao.metodos[0];
        const funcao = new estruturas_2.VisuAlgFuncao('construtor', declaracaoConstrutor.funcao, undefined, true);
        metodos['construtor'] = funcao;
    }
    const descritorTipoClasse = new estruturas_1.DescritorTipoClasse(declaracao.simbolo, undefined, metodos, declaracao.propriedades);
    interpretador.pilhaEscoposExecucao.definirConstante(declaracao.simbolo.lexema, descritorTipoClasse);
    interpretador.tiposConhecidos.push(declaracao.simbolo.lexema);
    return null;
}
async function visitarDeclaracaoDefinicaoFuncao(interpretador, declaracao) {
    const funcao = new estruturas_2.VisuAlgFuncao(declaracao.simbolo.lexema, declaracao.funcao);
    interpretador.pilhaEscoposExecucao.definirVariavel(declaracao.simbolo.lexema, funcao);
}
async function visitarDeclaracaoInicioAlgoritmo(interpretador, declaracao) {
    return Promise.resolve();
}
function converterValor(valor, tipo) {
    switch (tipo) {
        case 'inteiro':
            return parseInt(valor);
        case 'lógico':
            return Boolean(valor);
        case 'número':
        case 'real':
            return Number(valor);
        case 'texto':
            return String(valor);
        default:
            return valor;
    }
}
async function atribuirVariavel(interpretador, expressao, valor) {
    if (expressao instanceof construtos_1.Variavel) {
        interpretador.pilhaEscoposExecucao.atribuirVariavel(expressao.simbolo, valor);
        return;
    }
    if (expressao instanceof construtos_1.AcessoElementoMatriz) {
        const promises = await Promise.all([
            avaliar(interpretador, expressao.indicePrimario),
            avaliar(interpretador, expressao.indiceSecundario),
            avaliar(interpretador, expressao.entidadeChamada),
        ]);
        let indicePrimario = promises[0];
        let indiceSecundario = promises[1];
        let entidadeChamada = promises[2];
        entidadeChamada = entidadeChamada.hasOwnProperty('valor') ? entidadeChamada.valor : entidadeChamada;
        indicePrimario = indicePrimario.hasOwnProperty('valor') ? indicePrimario.valor : indicePrimario;
        indiceSecundario = indiceSecundario.hasOwnProperty('valor') ? indiceSecundario.valor : indiceSecundario;
        if (Array.isArray(entidadeChamada)) {
            if (indicePrimario < 0 && entidadeChamada.length !== 0) {
                while (indicePrimario < 0) {
                    indicePrimario += entidadeChamada.length;
                }
            }
            if (indiceSecundario < 0 && entidadeChamada.length !== 0) {
                while (indiceSecundario < 0) {
                    indiceSecundario += entidadeChamada.length;
                }
            }
            while (entidadeChamada.length < indicePrimario || entidadeChamada.length < indiceSecundario) {
                entidadeChamada.push(null);
            }
            entidadeChamada[indicePrimario][indiceSecundario] = valor;
            return Promise.resolve();
        }
        if (entidadeChamada instanceof construtos_1.Vetor) {
            const primeiraDimensao = entidadeChamada.valores[indicePrimario];
            const tipoElementar = primeiraDimensao.tipo.replace('[]', '');
            primeiraDimensao.valores[indiceSecundario] = converterValor(valor, tipoElementar);
            return Promise.resolve();
        }
    }
    if (expressao instanceof construtos_1.AcessoIndiceVariavel) {
        const promises = await Promise.all([
            interpretador.avaliar(expressao.entidadeChamada),
            interpretador.avaliar(expressao.indice),
        ]);
        let alvo = promises[0];
        let indice = promises[1];
        let valorAlvo;
        let valorIndice;
        if (alvo.hasOwnProperty('valor')) {
            valorAlvo = alvo.valor;
        }
        else {
            valorAlvo = alvo;
        }
        if (indice.hasOwnProperty('valor')) {
            valorIndice = indice.valor;
        }
        else {
            valorIndice = indice;
        }
        const subtipo = String(alvo.tipo).replace('[]', '');
        const valorResolvido = converterValor(valor, subtipo);
        if (valorAlvo instanceof construtos_1.Vetor) {
            valorAlvo.valores[valorIndice] = valorResolvido;
        }
        else {
            valorAlvo[valorIndice] = valorResolvido;
        }
        return;
    }
    if (expressao instanceof construtos_1.AcessoMetodoOuPropriedade) {
        // Há apenas duas possibilidades aqui:
        // 1. A entidade é uma variável
        // 2. A entidade é um elemento de um vetor.
        let referenciaVariavel;
        let tipoBaseVariavel;
        if (expressao.objeto instanceof construtos_1.AcessoIndiceVariavel) {
            referenciaVariavel = await interpretador.avaliar(expressao.objeto.entidadeChamada);
            tipoBaseVariavel = referenciaVariavel.tipo.replace('[]', '');
        }
        else {
            referenciaVariavel = await interpretador.avaliar(expressao.objeto);
            tipoBaseVariavel = referenciaVariavel.tipo;
        }
        // A única forma de o avaliador sintático gerar uma expressão do tipo
        // `AcessoMetodoOuPropriedade` é se o `objeto` é um registro.
        // Portanto, temos que pesquisar aqui o tipo da propriedade.
        const tipoRelacionado = interpretador.pilhaEscoposExecucao.obterVariavelPorNome(tipoBaseVariavel);
        const descritorTipoRelacionado = tipoRelacionado.hasOwnProperty('valor')
            ? tipoRelacionado.valor
            : tipoRelacionado;
        const propriedadeRelacionada = descritorTipoRelacionado.propriedades.find((p) => p.nome.lexema === expressao.simbolo.lexema);
        if (!propriedadeRelacionada) {
            throw new excecoes_1.ErroEmTempoDeExecucao(expressao.simbolo, `Propriedade "${expressao.simbolo.lexema}" não existe no tipo ${descritorTipoRelacionado.simboloOriginal.lexema}.`);
        }
        let variavelObjeto = await interpretador.avaliar(expressao.objeto);
        const valorVariavelObjeto = variavelObjeto.hasOwnProperty('valor')
            ? variavelObjeto.valor
            : variavelObjeto;
        let valorConvertido = converterValor(valor, propriedadeRelacionada.tipo);
        valorVariavelObjeto.definir(expressao.simbolo, valorConvertido);
    }
}
async function avaliar(interpretador, expressao) {
    return await expressao.aceitar(interpretador);
}
function eIgual(esquerda, direita) {
    if (esquerda === null && direita === null)
        return true;
    if (esquerda === null)
        return false;
    return esquerda === direita;
}
function eVerdadeiro(objeto) {
    if (objeto === null)
        return false;
    if (typeof objeto === 'boolean')
        return Boolean(objeto);
    if (objeto.hasOwnProperty('valor')) {
        return Boolean(objeto.valor);
    }
    return true;
}
function verificarOperandosNumeros(operador, direita, esquerda) {
    const tipoDireita = direita.tipo ? direita.tipo : typeof direita === 'number' ? 'número' : String(NaN);
    const tipoEsquerda = esquerda.tipo ? esquerda.tipo : typeof esquerda === 'number' ? 'número' : String(NaN);
    const tiposNumericos = ['inteiro', 'numero', 'número', 'real'];
    if (tiposNumericos.includes(tipoDireita.toLowerCase()) && tiposNumericos.includes(tipoEsquerda.toLowerCase()))
        return;
    throw new excecoes_1.ErroEmTempoDeExecucao(operador, 'Operadores precisam ser números.', operador.linha);
}
function inicializacaoVetorOuMatriz(vetor, valorPadrao, tipoVetor) {
    vetor.tipo = tipoVetor;
    for (let i = 0; i < vetor.valores.length; i++) {
        if (vetor.valores[i] instanceof construtos_1.Vetor) {
            inicializacaoVetorOuMatriz(vetor.valores[i], valorPadrao, tipoVetor);
        }
        else {
            vetor.valores[i] = valorPadrao;
        }
    }
}
/**
 * Executa expressão de definição de variável.
 * @param declaracao A declaração Var
 * @returns Sempre retorna nulo.
 */
async function visitarDeclaracaoVar(interpretador, declaracao) {
    let valorFinal = await interpretador.avaliacaoDeclaracaoVarOuConst(declaracao);
    const tipoInferido = declaracao.tipo;
    if (String(declaracao.tipo).includes('[]')) {
        switch (declaracao.tipo) {
            case 'caracter[]':
            case 'caractere[]': // TODO: Reduzir para 'caracter' na análise sintática.
            case 'texto[]':
                inicializacaoVetorOuMatriz(valorFinal, '', tipoInferido);
                break;
            case 'inteiro[]':
            case 'real[]':
                inicializacaoVetorOuMatriz(valorFinal, 0, tipoInferido);
                break;
        }
    }
    interpretador.pilhaEscoposExecucao.definirVariavel(declaracao.simbolo.lexema, valorFinal, tipoInferido);
    return null;
}
async function visitarExpressaoAcessoIndiceVariavel(interpretador, expressao) {
    const promises = await Promise.all([
        interpretador.avaliar(expressao.entidadeChamada),
        interpretador.avaliar(expressao.indice),
    ]);
    const variavelObjeto = promises[0];
    const indice = promises[1];
    const objeto = variavelObjeto.hasOwnProperty('valor') ? variavelObjeto.valor : variavelObjeto;
    let valorIndice = indice.hasOwnProperty('valor') ? indice.valor : indice;
    if (Array.isArray(objeto)) {
        if (!Number.isInteger(valorIndice)) {
            return Promise.reject(new excecoes_1.ErroEmTempoDeExecucao(expressao.simboloFechamento, 'Somente inteiros podem ser usados para indexar um vetor.', expressao.linha));
        }
        if (valorIndice < 0 && objeto.length !== 0) {
            while (valorIndice < 0) {
                valorIndice += objeto.length;
            }
        }
        if (valorIndice >= objeto.length) {
            return Promise.reject(new excecoes_1.ErroEmTempoDeExecucao(expressao.simboloFechamento, 'Índice do vetor fora do intervalo.', expressao.linha));
        }
        return objeto[valorIndice];
    }
    if (objeto instanceof construtos_1.Vetor) {
        return objeto.valores[valorIndice];
    }
    if (objeto.constructor === Object ||
        objeto instanceof estruturas_1.ObjetoDeleguaClasse ||
        objeto instanceof estruturas_2.VisuAlgFuncao ||
        objeto instanceof estruturas_1.DescritorTipoClasse) {
        return objeto[valorIndice] || null;
    }
    if (typeof objeto === 'string') {
        if (!Number.isInteger(valorIndice)) {
            return Promise.reject(new excecoes_1.ErroEmTempoDeExecucao(expressao.simboloFechamento, 'Somente inteiros podem ser usados para indexar um vetor.', expressao.linha));
        }
        if (valorIndice < 0 && objeto.length !== 0) {
            while (valorIndice < 0) {
                valorIndice += objeto.length;
            }
        }
        if (valorIndice >= objeto.length) {
            return Promise.reject(new excecoes_1.ErroEmTempoDeExecucao(expressao.simboloFechamento, 'Índice fora do tamanho.', expressao.linha));
        }
        return objeto.charAt(valorIndice);
    }
    return Promise.reject(new excecoes_1.ErroEmTempoDeExecucao(expressao.entidadeChamada.nome, 'Somente listas, dicionários, classes e objetos podem ter seus valores indexados.', expressao.linha));
}
async function visitarExpressaoAtribuicaoPorIndice(interpretador, expressao) {
    const promises = await Promise.all([
        interpretador.avaliar(expressao.objeto),
        interpretador.avaliar(expressao.indice),
        interpretador.avaliar(expressao.valor),
    ]);
    let objeto = promises[0];
    let indice = promises[1];
    const valor = promises[2];
    objeto = objeto.hasOwnProperty('valor') ? objeto.valor : objeto;
    indice = indice.hasOwnProperty('valor') ? indice.valor : indice;
    if (Array.isArray(objeto)) {
        if (indice < 0 && objeto.length !== 0) {
            while (indice < 0) {
                indice += objeto.length;
            }
        }
        while (objeto.length < indice) {
            objeto.push(null);
        }
        objeto[indice] = valor;
    }
    else if (objeto instanceof construtos_1.Vetor) {
        objeto.valores[indice] = valor;
    }
    else if (objeto.constructor === Object ||
        objeto instanceof estruturas_1.ObjetoDeleguaClasse ||
        objeto instanceof estruturas_2.VisuAlgFuncao ||
        objeto instanceof estruturas_1.DescritorTipoClasse) {
        objeto[indice] = valor;
    }
    else {
        return Promise.reject(new excecoes_1.ErroEmTempoDeExecucao(expressao.objeto.nome, 'Somente listas, dicionários, classes e objetos podem ser mudados por sobrescrita.', expressao.linha));
    }
}
/**
 * Método de visita de expressão binária.
 * Reintroduzido pelas particularidades do VisuAlg.
 * @param expressao A expressão binária.
 * @returns O resultado da resolução da expressão.
 */
async function visitarExpressaoBinaria(interpretador, expressao) {
    try {
        const promises = await Promise.all([
            avaliar(interpretador, expressao.esquerda),
            avaliar(interpretador, expressao.direita),
        ]);
        const esquerda = promises[0];
        const direita = promises[1];
        let valorEsquerdo = (esquerda === null || esquerda === void 0 ? void 0 : esquerda.hasOwnProperty('valor')) ? esquerda.valor : esquerda;
        let valorDireito = (direita === null || direita === void 0 ? void 0 : direita.hasOwnProperty('valor')) ? direita.valor : direita;
        // No VisuAlg, uma variável pode resolver para função porque funções não precisam ter parênteses.
        // Esta parte evita o problema.
        if (valorEsquerdo && valorEsquerdo.hasOwnProperty('funcao')) {
            valorEsquerdo = valorEsquerdo.funcao();
        }
        if (valorDireito && valorDireito.hasOwnProperty('funcao')) {
            valorDireito = valorDireito.funcao();
        }
        const tipoEsquerdo = (esquerda === null || esquerda === void 0 ? void 0 : esquerda.hasOwnProperty('tipo')) ? esquerda.tipo : (0, inferenciador_1.inferirTipoVariavel)(esquerda);
        const tipoDireito = (direita === null || direita === void 0 ? void 0 : direita.hasOwnProperty('tipo')) ? direita.tipo : (0, inferenciador_1.inferirTipoVariavel)(direita);
        switch (expressao.operador.tipo) {
            case lexico_regular_1.default.EXPONENCIACAO:
                verificarOperandosNumeros(expressao.operador, esquerda, direita);
                return Math.pow(valorEsquerdo, valorDireito);
            case lexico_regular_1.default.MAIOR:
                verificarOperandosNumeros(expressao.operador, esquerda, direita);
                return Number(valorEsquerdo) > Number(valorDireito);
            case lexico_regular_1.default.MAIOR_IGUAL:
                verificarOperandosNumeros(expressao.operador, esquerda, direita);
                return Number(valorEsquerdo) >= Number(valorDireito);
            case lexico_regular_1.default.MENOR:
                verificarOperandosNumeros(expressao.operador, esquerda, direita);
                return Number(valorEsquerdo) < Number(valorDireito);
            case lexico_regular_1.default.MENOR_IGUAL:
                verificarOperandosNumeros(expressao.operador, esquerda, direita);
                return Number(valorEsquerdo) <= Number(valorDireito);
            case lexico_regular_1.default.SUBTRACAO:
                verificarOperandosNumeros(expressao.operador, esquerda, direita);
                return Number(valorEsquerdo) - Number(valorDireito);
            case lexico_regular_1.default.ADICAO:
                let tiposNumericos = ['inteiro', 'numero', 'número', 'real'];
                if (tiposNumericos.includes(tipoEsquerdo.toLowerCase()) &&
                    tiposNumericos.includes(tipoDireito.toLowerCase())) {
                    return Number(valorEsquerdo) + Number(valorDireito);
                }
                else {
                    return String(valorEsquerdo) + String(valorDireito);
                }
            case lexico_regular_1.default.DIVISAO:
                verificarOperandosNumeros(expressao.operador, esquerda, direita);
                return Number(valorEsquerdo) / Number(valorDireito);
            case lexico_regular_1.default.DIVISAO_INTEIRA:
                verificarOperandosNumeros(expressao.operador, esquerda, direita);
                return Math.floor(Number(valorEsquerdo) / Number(valorDireito));
            case lexico_regular_1.default.MULTIPLICACAO:
                if (tipoEsquerdo === 'texto' || tipoDireito === 'texto') {
                    // Sem ambos os valores resolvem como texto, multiplica normal.
                    // Se apenas um resolve como texto, o outro repete o
                    // texto n vezes, sendo n o valor do outro.
                    if (tipoEsquerdo === 'texto' && tipoDireito === 'texto') {
                        return Number(valorEsquerdo) * Number(valorDireito);
                    }
                    if (tipoEsquerdo === 'texto') {
                        return valorEsquerdo.repeat(Number(valorDireito));
                    }
                    return valorDireito.repeat(Number(valorEsquerdo));
                }
                return Number(valorEsquerdo) * Number(valorDireito);
            case lexico_regular_1.default.MODULO:
                verificarOperandosNumeros(expressao.operador, esquerda, direita);
                return Number(valorEsquerdo) % Number(valorDireito);
            case lexico_regular_1.default.DIFERENTE:
                return !eIgual(valorEsquerdo, valorDireito);
            case lexico_regular_1.default.IGUAL:
                return eIgual(valorEsquerdo, valorDireito);
        }
    }
    catch (erro) {
        return Promise.reject(erro);
    }
}
async function visitarExpressaoLogica(interpretador, expressao) {
    const esquerda = await avaliar(interpretador, expressao.esquerda);
    // se um estado for verdadeiro, retorna verdadeiro
    if (expressao.operador.tipo === lexico_regular_1.default.OU) {
        if (eVerdadeiro(esquerda))
            return esquerda;
    }
    // se a primeira variável é verdadeiro, retorna a segunda invertida
    if (expressao.operador.tipo === lexico_regular_1.default.XOU) {
        const valorDireito = await avaliar(interpretador, expressao.direita);
        return eVerdadeiro(esquerda) !== eVerdadeiro(valorDireito);
    }
    // se um estado for falso, retorna falso
    if (expressao.operador.tipo === lexico_regular_1.default.E) {
        if (!eVerdadeiro(esquerda))
            return esquerda;
    }
    return await avaliar(interpretador, expressao.direita);
}
/* Isso existe porque o laço `para` do VisuAlg pode ter o passo positivo ou negativo
 * dependendo dos operandos de início e fim, que só são possíveis de determinar
 * em tempo de execução.
 * Quando um dos operandos é uma variável, tanto a condição do laço quanto o
 * passo são considerados indefinidos aqui.
 */
async function resolverIncrementoPara(interpretador, declaracao) {
    if (declaracao.resolverIncrementoEmExecucao) {
        const promises = await Promise.all([
            avaliar(interpretador, declaracao.condicao.esquerda),
            avaliar(interpretador, declaracao.condicao.direita),
        ]);
        const operandoEsquerdo = promises[0];
        const operandoDireito = promises[1];
        const valorAtualEsquerdo = operandoEsquerdo.hasOwnProperty('valor') ? operandoEsquerdo.valor : operandoEsquerdo;
        const valorAtualDireito = operandoDireito.hasOwnProperty('valor') ? operandoDireito.valor : operandoDireito;
        if (valorAtualEsquerdo < valorAtualDireito) {
            declaracao.condicao.operador = new lexador_1.Simbolo(lexico_regular_1.default.MENOR_IGUAL, '', '', Number(declaracao.linha), declaracao.hashArquivo);
            declaracao.incrementar.condicaoPara.operador = new lexador_1.Simbolo(lexico_regular_1.default.MENOR, '', '', Number(declaracao.linha), declaracao.hashArquivo);
            declaracao.incrementar.incremento.expressao.valor.direita = new construtos_1.Literal(declaracao.hashArquivo, Number(declaracao.linha), 1);
        }
        else {
            declaracao.condicao.operador = new lexador_1.Simbolo(lexico_regular_1.default.MAIOR_IGUAL, '', '', Number(declaracao.linha), declaracao.hashArquivo);
            declaracao.incrementar.condicaoPara.operador = new lexador_1.Simbolo(lexico_regular_1.default.MAIOR, '', '', Number(declaracao.linha), declaracao.hashArquivo);
            declaracao.incrementar.incremento.expressao.valor.direita = new construtos_1.Unario(declaracao.hashArquivo, new lexador_1.Simbolo(lexico_regular_1.default.SUBTRACAO, '-', undefined, declaracao.linha, declaracao.hashArquivo), new construtos_1.Literal(declaracao.hashArquivo, Number(declaracao.linha), 1), 'ANTES');
        }
    }
}
async function visitarExpressaoAcessoElementoMatriz(interpretador, expressao) {
    const promises = await Promise.all([
        avaliar(interpretador, expressao.entidadeChamada),
        avaliar(interpretador, expressao.indicePrimario),
        avaliar(interpretador, expressao.indiceSecundario),
    ]);
    const variavelObjeto = promises[0];
    const indicePrimario = promises[1];
    const indiceSecundario = promises[2];
    const objeto = variavelObjeto.hasOwnProperty('valor') ? variavelObjeto.valor : variavelObjeto;
    let valorIndicePrimario = indicePrimario.hasOwnProperty('valor') ? indicePrimario.valor : indicePrimario;
    let valorIndiceSecundario = indiceSecundario.hasOwnProperty('valor') ? indiceSecundario.valor : indiceSecundario;
    if (!Number.isInteger(valorIndicePrimario) || !Number.isInteger(valorIndiceSecundario)) {
        return Promise.reject(new excecoes_1.ErroEmTempoDeExecucao(expressao.simboloFechamento, 'Somente inteiros podem ser usados para indexar um vetor.', expressao.linha));
    }
    if (Array.isArray(objeto)) {
        if (valorIndicePrimario < 0 && objeto.length !== 0) {
            while (valorIndicePrimario < 0) {
                valorIndicePrimario += objeto.length;
            }
        }
        if (valorIndiceSecundario < 0 && objeto.length !== 0) {
            while (valorIndiceSecundario < 0) {
                valorIndiceSecundario += objeto.length;
            }
        }
        if (valorIndicePrimario >= objeto.length || valorIndiceSecundario >= objeto.length) {
            return Promise.reject(new excecoes_1.ErroEmTempoDeExecucao(expressao.simboloFechamento, 'Índice do vetor fora do intervalo.', expressao.linha));
        }
        return objeto[valorIndicePrimario][valorIndiceSecundario];
    }
    if (objeto instanceof construtos_1.Vetor) {
        const vetorPrimario = objeto.valores[valorIndicePrimario];
        return vetorPrimario.valores[valorIndiceSecundario];
    }
    return Promise.reject(new excecoes_1.ErroEmTempoDeExecucao(expressao.entidadeChamada.valor, 'Somente listas, dicionários, classes e objetos podem ser mudados por sobrescrita.', expressao.linha));
}
async function visitarExpressaoAtribuicaoPorIndicesMatriz(interpretador, expressao) {
    const promises = await Promise.all([
        avaliar(interpretador, expressao.objeto),
        avaliar(interpretador, expressao.indicePrimario),
        avaliar(interpretador, expressao.indiceSecundario),
        avaliar(interpretador, expressao.valor),
    ]);
    let objeto = promises[0];
    let indicePrimario = promises[1];
    let indiceSecundario = promises[2];
    const valor = promises[3];
    objeto = objeto.hasOwnProperty('valor') ? objeto.valor : objeto;
    indicePrimario = indicePrimario.hasOwnProperty('valor') ? indicePrimario.valor : indicePrimario;
    indiceSecundario = indiceSecundario.hasOwnProperty('valor') ? indiceSecundario.valor : indiceSecundario;
    if (Array.isArray(objeto)) {
        if (indicePrimario < 0 && objeto.length !== 0) {
            while (indicePrimario < 0) {
                indicePrimario += objeto.length;
            }
        }
        if (indiceSecundario < 0 && objeto.length !== 0) {
            while (indiceSecundario < 0) {
                indiceSecundario += objeto.length;
            }
        }
        while (objeto.length < indicePrimario || objeto.length < indiceSecundario) {
            objeto.push(null);
        }
        objeto[indicePrimario][indiceSecundario] = valor;
        return Promise.resolve();
    }
    if (objeto instanceof construtos_1.Vetor) {
        const primeiraDimensao = objeto.valores[indicePrimario];
        const tipoElementar = primeiraDimensao.tipo.replace('[]', '');
        primeiraDimensao.valores[indiceSecundario] = converterValor(valor, tipoElementar);
        return Promise.resolve();
    }
    return Promise.reject(new excecoes_1.ErroEmTempoDeExecucao(expressao.objeto.nome, 'Somente listas, dicionários, classes e objetos podem ser mudados por sobrescrita.', expressao.linha));
}
async function encontrarLeiaNoAleatorio(interpretador, declaracao, menorNumero, maiorNumero) {
    if ('declaracoes' in declaracao) {
        // Se a declaração tiver um campo 'declaracoes', ela é um Bloco
        const declaracoes = declaracao.declaracoes;
        for (const subDeclaracao of declaracoes) {
            encontrarLeiaNoAleatorio(interpretador, subDeclaracao, menorNumero, maiorNumero);
        }
    }
    else if (declaracao instanceof declaracoes_1.Leia) {
        // Se encontrarmos um Leia, podemos efetuar as operações imediatamente
        for (const argumento of declaracao.argumentos) {
            const arg1 = await interpretador.avaliar(argumento);
            const tipoDe = arg1.tipo || (0, inferenciador_1.inferirTipoVariavel)(arg1);
            const valor = tipoDe === 'texto' ? palavraAleatoriaCom5Digitos() : gerarNumeroAleatorio(menorNumero, maiorNumero);
            atribuirVariavel(interpretador, argumento, valor);
        }
    }
}
function gerarNumeroAleatorio(min, max) {
    return Math.floor(Math.random() * (max - min) + min);
}
function palavraAleatoriaCom5Digitos() {
    const caracteres = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
    let palavra = '';
    for (let i = 0; i < 5; i++) {
        const indiceAleatorio = Math.floor(Math.random() * caracteres.length);
        palavra += caracteres.charAt(indiceAleatorio);
    }
    return palavra;
}
async function visitarDeclaracaoAleatorio(interpretador, expressao) {
    let retornoExecucao;
    try {
        let menorNumero = 0;
        let maiorNumero = 100;
        if (expressao.argumentos) {
            menorNumero = Math.min(expressao.argumentos.min, expressao.argumentos.max);
            maiorNumero = Math.max(expressao.argumentos.min, expressao.argumentos.max);
        }
        for (let corpoDeclaracao of expressao.corpo.declaracoes) {
            encontrarLeiaNoAleatorio(interpretador, corpoDeclaracao, menorNumero, maiorNumero);
            retornoExecucao = await interpretador.executar(corpoDeclaracao, false);
        }
    }
    catch (error) {
        interpretador.erros.push({
            erroInterno: error,
            linha: expressao.linha,
            hashArquivo: expressao.hashArquivo,
        });
        return Promise.reject(error);
    }
    return retornoExecucao;
}
/**
 * Formata uma saída de acordo com o número e espaços e casas decimais solicitados.
 * @param declaracao A declaração de formatação de escrita.
 * @returns {string} A saída formatada como texto e os respectivos parâmetros aplicados.
 */
async function visitarExpressaoFormatacaoEscrita(interpretador, declaracao) {
    let resultado = '';
    const conteudo = await interpretador.avaliar(declaracao.expressao);
    const valorConteudo = (conteudo === null || conteudo === void 0 ? void 0 : conteudo.hasOwnProperty('valor')) ? conteudo.valor : conteudo;
    const tipoConteudo = (conteudo === null || conteudo === void 0 ? void 0 : conteudo.hasOwnProperty('tipo')) ? conteudo.tipo : typeof conteudo;
    resultado = valorConteudo;
    if (['real', 'inteiro'].includes(tipoConteudo) && declaracao.casasDecimais > 0) {
        resultado = valorConteudo.toLocaleString('pt', {
            minimumFractionDigits: declaracao.casasDecimais,
            maximumFractionDigits: declaracao.casasDecimais,
        });
    }
    if (declaracao.espacos > 0) {
        resultado = ' '.repeat(declaracao.espacos) + resultado;
    }
    return resultado;
}
/**
 * Customização da leitura de dados de entrada.
 * A interrupção da execução para leitura de dados do usuário
 * ocorre quando o modo aleatório não está habilitado.
 * @param interpretador A instância do interpretador.
 * @param expressao A expressão `Leia`
 * @param mensagemPrompt A mensagem de prompt. Normalmente é o último conteúdo da função `escreva()`
 *                       ou ainda `escreval()`, e é usada em prompts Web, como por exemplo `window.prompt`.
 */
async function visitarExpressaoLeia(interpretador, expressao, mensagemPrompt) {
    // Verifica se a leitura deve ser interrompida antes de prosseguir
    if (!expressao.eParaInterromper) {
        for (let argumento of expressao.argumentos) {
            const promessaLeitura = () => new Promise((resolucao) => interpretador.interfaceEntradaSaida.question(interpretador.deveEscreverPrompt ? mensagemPrompt : '', (resposta) => {
                mensagemPrompt = '> ';
                resolucao(resposta);
            }));
            const valorLido = await promessaLeitura();
            await atribuirVariavel(interpretador, argumento, valorLido);
        }
    }
}
//# sourceMappingURL=comum.js.map